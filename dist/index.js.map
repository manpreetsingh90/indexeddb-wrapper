{"version":3,"file":"index.js","sources":["../src/ErrorHandler.js","../src/SchemaManager.js","../src/TransactionManager.js","../src/MigrationManager.js","../src/ConnectionManager.js","../src/QueryEngine.js","../src/IDBWrapper.js"],"sourcesContent":["/**\r\n * Base error class for IndexedDB operations\r\n */\r\nexport class IDBError extends Error {\r\n  constructor(message, originalError = null) {\r\n    super(message);\r\n    this.name = 'IDBError';\r\n    this.originalError = originalError;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when database connection fails\r\n */\r\nexport class ConnectionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'ConnectionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when schema validation fails\r\n */\r\nexport class SchemaError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'SchemaError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration fails\r\n */\r\nexport class MigrationError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction fails\r\n */\r\nexport class TransactionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionError';\r\n  }\r\n}","import { SchemaError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages schema validation and object store creation\r\n */\r\nexport default class SchemaManager {\r\n  /**\r\n   * Validates the schema structure\r\n   * @param {Object} schema - The schema definition\r\n   * @throws {SchemaError} If schema is invalid\r\n   */\r\n  static validateSchema(schema) {\r\n    if (!schema || typeof schema !== 'object') {\r\n      throw new SchemaError('Schema must be an object');\r\n    }\r\n\r\n    if (!schema.stores || typeof schema.stores !== 'object') {\r\n      throw new SchemaError('Schema must have a stores property');\r\n    }\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!storeConfig || typeof storeConfig !== 'object') {\r\n        throw new SchemaError(`Store ${storeName} configuration must be an object`);\r\n      }\r\n\r\n      if (!storeConfig.keyPath) {\r\n        throw new SchemaError(`Store ${storeName} must have a keyPath`);\r\n      }\r\n\r\n      // Validate indexes\r\n      if (storeConfig.indexes) {\r\n        if (typeof storeConfig.indexes !== 'object') {\r\n          throw new SchemaError(`Indexes for store ${storeName} must be an object`);\r\n        }\r\n\r\n        for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n          if (typeof indexConfig !== 'object') {\r\n            throw new SchemaError(`Index ${indexName} in store ${storeName} must be an object`);\r\n          }\r\n\r\n          if (!indexConfig.keyPath && !indexConfig.unique) {\r\n            // Allow minimal config, but warn if no keyPath\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates object stores and indexes in the database\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The schema definition\r\n   */\r\n  static createSchema(db, schema) {\r\n    this.validateSchema(schema);\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        const store = db.createObjectStore(storeName, {\r\n          keyPath: storeConfig.keyPath,\r\n          autoIncrement: storeConfig.autoIncrement || false\r\n        });\r\n\r\n        if (storeConfig.indexes) {\r\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n            const keyPath = indexConfig.keyPath || indexName;\r\n            store.createIndex(indexName, keyPath, {\r\n              unique: indexConfig.unique || false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the existing schema matches the expected schema\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The expected schema\r\n   * @returns {boolean} True if schema matches\r\n   */\r\n  static checkSchemaConsistency(db, schema) {\r\n    // This would be more complex in a real implementation\r\n    // For now, just check if stores exist\r\n    for (const storeName of Object.keys(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}","import { TransactionError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages IndexedDB transactions\r\n */\r\nexport default class TransactionManager {\r\n  /**\r\n   * Executes an operation within a transaction\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} operation - Function that receives the transaction and performs operations\r\n   * @returns {Promise} Result of the operation\r\n   */\r\n  static async execute(db, storeNames, mode, operation) {\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(storeNames, mode);\r\n\r\n      transaction.onerror = () => {\r\n        reject(new TransactionError('Transaction failed', transaction.error));\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        reject(new TransactionError('Transaction aborted'));\r\n      };\r\n\r\n      let operationResult;\r\n\r\n      try {\r\n        operationResult = operation(transaction);\r\n\r\n        // If operation returns a promise, wait for it\r\n        if (operationResult && typeof operationResult.then === 'function') {\r\n          operationResult.then((result) => {\r\n            transaction.oncomplete = () => resolve(result);\r\n          }).catch(reject);\r\n        } else {\r\n          // For synchronous operations, resolve on complete\r\n          transaction.oncomplete = () => resolve(operationResult);\r\n        }\r\n      } catch (error) {\r\n        reject(new TransactionError('Operation failed', error));\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a promise-based wrapper for IDBRequest\r\n   * @param {IDBRequest} request - The IndexedDB request\r\n   * @returns {Promise} Resolves with the result\r\n   */\r\n  static promisifyRequest(request) {\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => reject(new TransactionError('Request failed', request.error));\r\n    });\r\n  }\r\n}","import { MigrationError } from './ErrorHandler.js';\r\nimport TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles schema migrations\r\n */\r\nexport default class MigrationManager {\r\n  /**\r\n   * Runs migrations from old version to new version\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Array<Function>} migrations - Array of migration functions\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   */\r\n  static async runMigrations(db, migrations, fromVersion, toVersion) {\r\n    if (!migrations || fromVersion >= toVersion) return;\r\n\r\n    for (let i = fromVersion; i < toVersion; i++) {\r\n      const migrationIndex = i; // migrations[0] is for version 1->2\r\n\r\n      if (migrations[migrationIndex]) {\r\n        try {\r\n          await TransactionManager.execute(db, [], 'readwrite', (transaction) => {\r\n            return migrations[migrationIndex](db, transaction);\r\n          });\r\n        } catch (error) {\r\n          throw new MigrationError(`Migration from version ${i} to ${i + 1} failed`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","import { ConnectionError } from './ErrorHandler.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport MigrationManager from './MigrationManager.js';\r\n\r\n/**\r\n * Manages IndexedDB database connections\r\n */\r\nexport default class ConnectionManager {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.db = null;\r\n    this.oldVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>} The database instance\r\n   */\r\n  open() {\r\n    return new Promise((resolve, reject) => {\r\n      if (!window.indexedDB) {\r\n        reject(new ConnectionError('IndexedDB not supported'));\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => {\r\n        reject(new ConnectionError('Failed to open database', request.error));\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        this.db = event.target.result;\r\n        this.oldVersion = event.oldVersion;\r\n        SchemaManager.createSchema(this.db, this.schema);\r\n      };\r\n\r\n      request.onsuccess = async () => {\r\n        this.db = request.result;\r\n        if (this.oldVersion < this.version) {\r\n          try {\r\n            await MigrationManager.runMigrations(this.db, this.migrations, this.oldVersion, this.version);\r\n          } catch (error) {\r\n            reject(error);\r\n            return;\r\n          }\r\n        }\r\n        resolve(this.db);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is currently open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.db !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.db;\r\n  }\r\n}","import TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles advanced querying with filters and operators\r\n */\r\nexport default class QueryEngine {\r\n  /**\r\n   * Executes a query with filters\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  static async query(db, storeName, filters = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      const results = [];\r\n\r\n      // For now, implement basic filtering\r\n      // In a full implementation, this would use indexes and cursors efficiently\r\n\r\n      if (Object.keys(filters).length === 0) {\r\n        // No filters, return all\r\n        return new Promise((resolve, reject) => {\r\n          const request = store.openCursor();\r\n          request.onsuccess = (event) => {\r\n            const cursor = event.target.result;\r\n            if (cursor) {\r\n              results.push(cursor.value);\r\n              cursor.continue();\r\n            } else {\r\n              resolve(results);\r\n            }\r\n          };\r\n          request.onerror = () => reject(request.error);\r\n        });\r\n      }\r\n\r\n      // Simple implementation: get all and filter in memory\r\n      // TODO: Optimize with indexes\r\n      const allRecords = await new Promise((resolve, reject) => {\r\n        const request = store.openCursor();\r\n        const records = [];\r\n        request.onsuccess = (event) => {\r\n          const cursor = event.target.result;\r\n          if (cursor) {\r\n            records.push(cursor.value);\r\n            cursor.continue();\r\n          } else {\r\n            resolve(records);\r\n          }\r\n        };\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n\r\n      return allRecords.filter(record => this.matchesFilters(record, filters));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches the given filters\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} filters - Filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesFilters(record, filters) {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      if (typeof value === 'object' && value !== null) {\r\n        // Operator-based filter\r\n        if (!this.evaluateOperator(record[key], value)) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Equality filter\r\n        if (record[key] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Evaluates operator-based conditions\r\n   * @param {*} fieldValue - Value from the record\r\n   * @param {Object} operator - Operator object (e.g., { $gt: 5 })\r\n   * @returns {boolean}\r\n   */\r\n  static evaluateOperator(fieldValue, operator) {\r\n    const [op, value] = Object.entries(operator)[0];\r\n\r\n    switch (op) {\r\n      case '$gt':\r\n        return fieldValue > value;\r\n      case '$gte':\r\n        return fieldValue >= value;\r\n      case '$lt':\r\n        return fieldValue < value;\r\n      case '$lte':\r\n        return fieldValue <= value;\r\n      case '$eq':\r\n        return fieldValue === value;\r\n      case '$ne':\r\n        return fieldValue !== value;\r\n      case '$regex':\r\n        return new RegExp(value).test(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}","import ConnectionManager from './ConnectionManager.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport TransactionManager from './TransactionManager.js';\r\nimport QueryEngine from './QueryEngine.js';\r\n\r\n/**\r\n * Main IndexedDB wrapper class\r\n */\r\nexport default class IDBWrapper {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    // Validate schema upfront\r\n    SchemaManager.validateSchema(schema);\r\n\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n\r\n    this.connectionManager = new ConnectionManager(dbName, version, schema, migrations);\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>}\r\n   */\r\n  async open() {\r\n    return this.connectionManager.open();\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    this.connectionManager.close();\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.connectionManager.isOpen();\r\n  }\r\n\r\n  /**\r\n   * Gets the database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.connectionManager.getDatabase();\r\n  }\r\n\r\n  /**\r\n   * Creates a new record\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} data - Data to store\r\n   * @returns {Promise} Resolves with the key\r\n   */\r\n  async create(storeName, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.add(data));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a record by key\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves with the record or undefined\r\n   */\r\n  async read(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readonly', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.get(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @param {Object} data - Updated data\r\n   * @returns {Promise} Resolves when updated\r\n   */\r\n  async update(storeName, key, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.put(data, key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves when deleted\r\n   */\r\n  async delete(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.delete(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries records with filters\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  async query(storeName, filters = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.query(db, storeName, filters);\r\n  }\r\n\r\n  /**\r\n   * Performs bulk operations\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async bulk(storeName, operations) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      const promises = operations.map(op => {\r\n        switch (op.type) {\r\n          case 'create':\r\n            return TransactionManager.promisifyRequest(store.add(op.data));\r\n          case 'update':\r\n            return TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n          case 'delete':\r\n            return TransactionManager.promisifyRequest(store.delete(op.id));\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n      });\r\n\r\n      return Promise.all(promises);\r\n    });\r\n  }\r\n}"],"names":["IDBError","Error","constructor","message","originalError","super","this","name","ConnectionError","SchemaError","MigrationError","TransactionError","SchemaManager","validateSchema","schema","stores","storeName","storeConfig","Object","entries","keyPath","indexes","indexName","indexConfig","unique","createSchema","db","objectStoreNames","contains","store","createObjectStore","autoIncrement","createIndex","checkSchemaConsistency","keys","TransactionManager","execute","storeNames","mode","operation","Promise","resolve","reject","transaction","operationResult","onerror","error","onabort","then","result","oncomplete","catch","promisifyRequest","request","onsuccess","MigrationManager","runMigrations","migrations","fromVersion","toVersion","i","migrationIndex","ConnectionManager","dbName","version","oldVersion","open","window","indexedDB","onupgradeneeded","event","target","async","close","isOpen","getDatabase","QueryEngine","query","filters","objectStore","results","length","openCursor","cursor","push","value","continue","records","filter","record","matchesFilters","key","evaluateOperator","fieldValue","operator","op","RegExp","test","connectionManager","create","data","add","read","get","update","put","delete","bulk","operations","promises","map","type","id","all"],"mappings":"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"}