class e extends Error{constructor(e,t=null){super(e),this.name="IDBError",this.originalError=t}}class t extends e{constructor(e,t=null){super(e,t),this.name="ConnectionError"}}class r extends e{constructor(e,t=null){super(e,t),this.name="SchemaError"}}class n extends e{constructor(e,t=null){super(e,t),this.name="MigrationError"}}class s extends e{constructor(e,t=null){super(e,t),this.name="TransactionError"}}class o{static validateSchema(e){if(!e||"object"!=typeof e)throw new r("Schema must be an object");if(!e.stores||"object"!=typeof e.stores)throw new r("Schema must have a stores property");for(const[t,n]of Object.entries(e.stores)){if(!n||"object"!=typeof n)throw new r(`Store ${t} configuration must be an object`);if(!n.keyPath)throw new r(`Store ${t} must have a keyPath`);if(n.indexes){if("object"!=typeof n.indexes)throw new r(`Indexes for store ${t} must be an object`);for(const[e,s]of Object.entries(n.indexes)){if("object"!=typeof s)throw new r(`Index ${e} in store ${t} must be an object`);!s.keyPath&&s.unique}}}}static createSchema(e,t){this.validateSchema(t);for(const[r,n]of Object.entries(t.stores))if(!e.objectStoreNames.contains(r)){const t=e.createObjectStore(r,{keyPath:n.keyPath,autoIncrement:n.autoIncrement||!1});if(n.indexes)for(const[e,r]of Object.entries(n.indexes)){const n=r.keyPath||e;t.createIndex(e,n,{unique:r.unique||!1})}}}static checkSchemaConsistency(e,t){for(const r of Object.keys(t.stores))if(!e.objectStoreNames.contains(r))return!1;return!0}}class a{static async execute(e,t,r,n){return new Promise((o,a)=>{const i=e.transaction(t,r);let c;i.onerror=()=>{a(new s("Transaction failed",i.error))},i.onabort=()=>{a(new s("Transaction aborted"))};try{c=n(i),c&&"function"==typeof c.then?c.then(e=>{i.oncomplete=()=>o(e)}).catch(a):i.oncomplete=()=>o(c)}catch(e){a(new s("Operation failed",e))}})}static promisifyRequest(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>{console.error("IDBRequest failed:",e.error.name,e.error.message),r(new s(`Request failed: ${e.error.name} - ${e.error.message}`,e.error))}})}}class i{static async runMigrations(e,t,r,s){if(t&&!(r>=s))for(let o=r;o<s;o++){const r=o;if(t[r])try{await a.execute(e,[],"readwrite",n=>t[r](e,n))}catch(e){throw new n(`Migration from version ${o} to ${o+1} failed`,e)}}}}class c{constructor(e,t,r,n=[]){this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.db=null,this.oldVersion=0}open(){return new Promise((e,r)=>{const n=globalThis.indexedDB||window?.indexedDB;if(!n)return void r(new t("IndexedDB not supported"));const s=n.open(this.dbName,this.version);s.onerror=()=>{r(new t("Failed to open database",s.error))},s.onupgradeneeded=e=>{this.db=e.target.result,this.oldVersion=e.oldVersion,o.createSchema(this.db,this.schema)},s.onsuccess=async()=>{if(this.db=s.result,this.oldVersion<this.version)try{await i.runMigrations(this.db,this.migrations,this.oldVersion,this.version)}catch(e){return void r(e)}e(this.db)}})}close(){this.db&&(this.db.close(),this.db=null)}isOpen(){return null!==this.db}getDatabase(){return this.db}}class u{static async query(e,t,r={},n={}){return a.execute(e,t,"readonly",async e=>{const s=e.objectStore(t),o=this.analyzeQuery(r,s,n);return o.compoundFilters?this.executeCompoundQuery(s,o.compoundFilters,o):o.canUseIndex?this.executeIndexQuery(s,o):this.executeFullScanQuery(s,r,o)})}static async analyzeQueryPlan(e,t,r={},n={}){return a.execute(e,t,"readonly",async e=>{const s=e.objectStore(t);return this.analyzeQuery(r,s,n)})}static analyzeQuery(e,t,r){const n={canUseIndex:!1,indexName:null,keyRange:null,postFilters:{},compoundFilters:null,sortField:r.sort,limit:r.limit,offset:r.offset||0,estimatedCost:0,optimizationNotes:[]};if(0===Object.keys(e).length)return n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push("Full table scan - no filters provided"),n;if(e.$and||e.$or)return n.compoundFilters=e,n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push("Compound query requires full scan"),n;for(const[r,s]of Object.entries(e)){const e=this.findIndexForField(t,r);e&&this.canUseIndexForFilter(s)?(n.canUseIndex=!0,n.indexName=e,n.keyRange=this.createKeyRange(s),n.estimatedCost=this.estimateIndexQueryCost(t,e,s),n.optimizationNotes.push(`Using index '${e}' for field '${r}'`)):(n.postFilters[r]=s,n.canUseIndex?n.optimizationNotes.push(`Post-filtering required for field '${r}'`):(n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push(`Full scan required for non-indexed field '${r}'`)))}return n}static estimateFullScanCost(e){return 100}static estimateIndexQueryCost(e,t,r){if("object"==typeof r&&null!==r){const e=Object.keys(r)[0];if(["$gt","$gte","$lt","$lte"].includes(e))return 20}return 5}static findIndexForField(e,t){if(e.keyPath===t)return null;for(const r of e.indexNames){if(e.index(r).keyPath===t)return r}return null}static canUseIndexForFilter(e){if("object"==typeof e&&null!==e){const t=Object.keys(e);return 1===t.length&&["$gt","$gte","$lt","$lte","$eq"].includes(t[0])}return!0}static createKeyRange(e){if("object"!=typeof e||null===e)return IDBKeyRange.only(e);{const[t,r]=Object.entries(e)[0];switch(t){case"$gt":return IDBKeyRange.lowerBound(r,!0);case"$gte":return IDBKeyRange.lowerBound(r);case"$lt":return IDBKeyRange.upperBound(r,!0);case"$lte":return IDBKeyRange.upperBound(r);case"$eq":return IDBKeyRange.only(r);default:return null}}}static async executeIndexQuery(e,t){const r=await new Promise((r,n)=>{const s=[];let o=0;const a=e.index(t.indexName).openCursor(t.keyRange);a.onsuccess=e=>{const n=e.target.result;n?((0===Object.keys(t.postFilters).length||this.matchesFilters(n.value,t.postFilters))&&(o<t.offset?o++:s.push(n.value)),n.continue()):r(s)},a.onerror=()=>n(a.error)});return this.applySortingAndPagination(r,t)}static async executeCompoundQuery(e,t,r={}){const n=await new Promise((r,n)=>{const s=[],o=e.openCursor();o.onsuccess=e=>{const n=e.target.result;n?(this.matchesCompoundFilters(n.value,t)&&s.push(n.value),n.continue()):r(s)},o.onerror=()=>n(o.error)});return this.applySortingAndPagination(n,r)}static async executeFullScanQuery(e,t,r={}){const n=await new Promise((r,n)=>{const s=[],o=e.openCursor();o.onsuccess=e=>{const n=e.target.result;n?(this.matchesFilters(n.value,t)&&s.push(n.value),n.continue()):r(s)},o.onerror=()=>n(o.error)});return this.applySortingAndPagination(n,r)}static applySortingAndPagination(e,t){let r=[...e];if(t.sortField){const[e,n]=Object.entries(t.sortField)[0];r.sort((t,r)=>{const s=t[e],o=r[e];return s<o?1===n?-1:1:s>o?1===n?1:-1:0})}return t.offset>0&&(r=r.slice(t.offset)),t.limit>0&&(r=r.slice(0,t.limit)),r}static matchesCompoundFilters(e,t){return t.$and?t.$and.every(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):t.$or?t.$or.some(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):this.matchesFilters(e,t)}static matchesFilters(e,t){for(const[r,n]of Object.entries(t))if("$and"===r||"$or"===r){if(!this.matchesCompoundFilters(e,{[r]:n}))return!1}else if("object"==typeof n&&null!==n){if(!this.evaluateOperator(e[r],n))return!1}else if(e[r]!==n)return!1;return!0}static evaluateOperator(e,t){const[r,n]=Object.entries(t)[0];switch(r){case"$gt":return e>n;case"$gte":return e>=n;case"$lt":return e<n;case"$lte":return e<=n;case"$eq":return e===n;case"$ne":return e!==n;case"$regex":return new RegExp(n).test(e);default:return!1}}}class l{constructor(e,t,r,n=[]){o.validateSchema(r),this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.connectionManager=new c(e,t,r,n)}async open(){return this.connectionManager.open()}close(){this.connectionManager.close()}isOpen(){return this.connectionManager.isOpen()}getDatabase(){return this.connectionManager.getDatabase()}async create(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return a.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return a.promisifyRequest(n.add(t))})}async read(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return a.execute(r,e,"readonly",r=>{const n=r.objectStore(e);return a.promisifyRequest(n.get(t))})}async update(e,t,r){const n=this.getDatabase();if(!n)throw new Error("Database not open");return a.execute(n,e,"readwrite",n=>{const s=n.objectStore(e);return new Promise((e,n)=>{const o=s.get(t);o.onsuccess=()=>{const t=o.result;if(!t)return void n(new Error("Record not found"));const a={...t,...r},i=s.put(a);i.onsuccess=()=>e(),i.onerror=()=>n(new TransactionError("Put failed",i.error))},o.onerror=()=>n(new TransactionError("Get failed",o.error))})})}async delete(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return a.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return a.promisifyRequest(n.delete(t))})}async query(e,t={},r={}){const n=this.getDatabase();if(!n)throw new Error("Database not open");return u.query(n,e,t,r)}async analyzeQuery(e,t={},r={}){const n=this.getDatabase();if(!n)throw new Error("Database not open");return u.analyzeQueryPlan(n,e,t,r)}async bulk(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return a.execute(r,e,"readwrite",r=>{const n=r.objectStore(e),s=t.map(e=>{switch(e.type){case"create":return a.promisifyRequest(n.add(e.data));case"update":return a.promisifyRequest(n.put(e.data,e.id));case"delete":return a.promisifyRequest(n.delete(e.id));default:throw new Error(`Unknown operation type: ${e.type}`)}});return Promise.all(s)})}}export{t as ConnectionError,e as IDBError,l as IDBWrapper,n as MigrationError,r as SchemaError,s as TransactionError};
//# sourceMappingURL=index.mjs.map
