{"version":3,"file":"index.mjs","sources":["../src/ErrorHandler.js","../src/SchemaManager.js","../src/TransactionManager.js","../src/MigrationManager.js","../src/ConnectionManager.js","../src/QueryEngine.js","../src/IDBWrapper.js"],"sourcesContent":["/**\r\n * Base error class for IndexedDB operations\r\n */\r\nexport class IDBError extends Error {\r\n  constructor(message, originalError = null) {\r\n    super(message);\r\n    this.name = 'IDBError';\r\n    this.originalError = originalError;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when database connection fails\r\n */\r\nexport class ConnectionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'ConnectionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when schema validation fails\r\n */\r\nexport class SchemaError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'SchemaError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration fails\r\n */\r\nexport class MigrationError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction fails\r\n */\r\nexport class TransactionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionError';\r\n    this.code = 'ERR_TRANSACTION_FAILED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction becomes inactive\r\n */\r\nexport class TransactionInactiveError extends TransactionError {\r\n  constructor(message = 'Transaction became inactive', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionInactiveError';\r\n    this.code = 'ERR_TRANSACTION_INACTIVE';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction times out\r\n */\r\nexport class TransactionTimeoutError extends TransactionError {\r\n  constructor(timeout, originalError = null) {\r\n    super(`Transaction timeout after ${timeout}ms`, originalError);\r\n    this.name = 'TransactionTimeoutError';\r\n    this.code = 'ERR_TRANSACTION_TIMEOUT';\r\n    this.timeout = timeout;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when storage quota is exceeded\r\n */\r\nexport class QuotaExceededError extends IDBError {\r\n  constructor(message = 'Storage quota exceeded', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'QuotaExceededError';\r\n    this.code = 'ERR_QUOTA_EXCEEDED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration rollback fails\r\n */\r\nexport class MigrationRollbackError extends MigrationError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationRollbackError';\r\n    this.code = 'ERR_MIGRATION_ROLLBACK_FAILED';\r\n  }\r\n}","import { SchemaError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages schema validation and object store creation\r\n */\r\nexport default class SchemaManager {\r\n  /**\r\n   * Validates the schema structure\r\n   * @param {Object} schema - The schema definition\r\n   * @throws {SchemaError} If schema is invalid\r\n   */\r\n  static validateSchema(schema) {\r\n    if (!schema || typeof schema !== 'object') {\r\n      throw new SchemaError('Schema must be an object');\r\n    }\r\n\r\n    if (!schema.stores || typeof schema.stores !== 'object') {\r\n      throw new SchemaError('Schema must have a stores property');\r\n    }\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!storeConfig || typeof storeConfig !== 'object') {\r\n        throw new SchemaError(`Store ${storeName} configuration must be an object`);\r\n      }\r\n\r\n      if (!storeConfig.keyPath) {\r\n        throw new SchemaError(`Store ${storeName} must have a keyPath`);\r\n      }\r\n\r\n      // Validate indexes\r\n      if (storeConfig.indexes) {\r\n        if (typeof storeConfig.indexes !== 'object') {\r\n          throw new SchemaError(`Indexes for store ${storeName} must be an object`);\r\n        }\r\n\r\n        for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n          if (typeof indexConfig !== 'object') {\r\n            throw new SchemaError(`Index ${indexName} in store ${storeName} must be an object`);\r\n          }\r\n\r\n          if (!indexConfig.keyPath && !indexConfig.unique) {\r\n            // Allow minimal config, but warn if no keyPath\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates object stores and indexes in the database\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The schema definition\r\n   */\r\n  static createSchema(db, schema) {\r\n    this.validateSchema(schema);\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        const store = db.createObjectStore(storeName, {\r\n          keyPath: storeConfig.keyPath,\r\n          autoIncrement: storeConfig.autoIncrement || false\r\n        });\r\n\r\n        if (storeConfig.indexes) {\r\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n            const keyPath = indexConfig.keyPath || indexName;\r\n            store.createIndex(indexName, keyPath, {\r\n              unique: indexConfig.unique || false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the existing schema matches the expected schema\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The expected schema\r\n   * @returns {boolean} True if schema matches\r\n   */\r\n  static checkSchemaConsistency(db, schema) {\r\n    // This would be more complex in a real implementation\r\n    // For now, just check if stores exist\r\n    for (const storeName of Object.keys(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}","import { TransactionError, TransactionInactiveError, TransactionTimeoutError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages IndexedDB transactions\r\n */\r\nexport default class TransactionManager {\r\n  /**\r\n   * Executes an operation within a transaction with safety checks\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} operation - Function that receives the transaction and performs operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the operation\r\n   */\r\n  static async execute(db, storeNames, mode, operation, options = {}) {\r\n    const {\r\n      timeout = 5000, // 5 second default timeout\r\n      strictAsync = true // Enforce no external async operations\r\n    } = options;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(storeNames, mode);\r\n      let timeoutId;\r\n      let completed = false;\r\n\r\n      // Set transaction timeout\r\n      if (timeout > 0) {\r\n        timeoutId = setTimeout(() => {\r\n          if (!completed && transaction.readyState === 'active') {\r\n            try {\r\n              transaction.abort();\r\n              reject(new TransactionTimeoutError(timeout));\r\n            } catch (error) {\r\n              // Transaction might already be finished\r\n              reject(new TransactionTimeoutError(timeout));\r\n            }\r\n          }\r\n        }, timeout);\r\n      }\r\n\r\n      transaction.onerror = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        reject(new TransactionError('Transaction failed', transaction.error));\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n\r\n        // Check if this was due to transaction becoming inactive\r\n        if (transaction.error && transaction.error.name === 'InvalidStateError') {\r\n          reject(new TransactionInactiveError('Transaction became inactive during operation'));\r\n        } else {\r\n          reject(new TransactionError('Transaction aborted'));\r\n        }\r\n      };\r\n\r\n      // Track async operations to prevent transaction invalidation\r\n      const activePromises = new Set();\r\n\r\n      const safeOperation = async (txn) => {\r\n        try {\r\n          // Wrap the operation to monitor async behavior\r\n          const result = await this.executeWithSafety(txn, operation, {\r\n            strictAsync,\r\n            activePromises,\r\n            transaction\r\n          });\r\n          return result;\r\n        } catch (error) {\r\n          throw new TransactionError('Operation failed', error);\r\n        }\r\n      };\r\n\r\n      // Execute the operation\r\n      safeOperation(transaction)\r\n        .then((result) => {\r\n          // Wait for transaction completion\r\n          transaction.oncomplete = () => {\r\n            completed = true;\r\n            if (timeoutId) clearTimeout(timeoutId);\r\n            resolve(result);\r\n          };\r\n        })\r\n        .catch((error) => {\r\n          completed = true;\r\n          if (timeoutId) clearTimeout(timeoutId);\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes operation with safety monitoring\r\n   * @param {IDBTransaction} transaction - The transaction\r\n   * @param {Function} operation - The operation to execute\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Promise} Operation result\r\n   */\r\n  static async executeWithSafety(transaction, operation, safety) {\r\n    const { strictAsync, activePromises, transaction: txn } = safety;\r\n\r\n    // Create a proxy to monitor transaction access\r\n    const monitoredTransaction = this.createMonitoredTransaction(transaction, safety);\r\n\r\n    // Execute the operation\r\n    const result = operation(monitoredTransaction);\r\n\r\n    // If result is a promise, monitor it\r\n    if (result && typeof result.then === 'function') {\r\n      activePromises.add(result);\r\n\r\n      try {\r\n        const resolvedResult = await result;\r\n        activePromises.delete(result);\r\n        return resolvedResult;\r\n      } catch (error) {\r\n        activePromises.delete(result);\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored transaction proxy\r\n   * @param {IDBTransaction} transaction - Original transaction\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored transaction\r\n   */\r\n  static createMonitoredTransaction(transaction, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    return new Proxy(transaction, {\r\n      get(target, property) {\r\n        // Monitor transaction state\r\n        if (property === 'objectStore') {\r\n          return (storeName) => {\r\n            // Check if transaction is still active\r\n            if (target.error) {\r\n              throw new TransactionError('Transaction is in error state', target.error);\r\n            }\r\n\r\n            // Check if transaction is still active (not aborted or completed)\r\n            if (target.mode === 'versionchange') {\r\n              // Version change transactions are special\r\n            } else if (target.readyState === 'finished') {\r\n              throw new TransactionInactiveError('Transaction has already finished');\r\n            }\r\n\r\n            try {\r\n              const store = target.objectStore(storeName);\r\n              // Return monitored object store\r\n              return TransactionManager.createMonitoredObjectStore(store, safety);\r\n            } catch (error) {\r\n              if (error.name === 'InvalidStateError') {\r\n                throw new TransactionInactiveError('Cannot access object store - transaction is inactive');\r\n              }\r\n              throw error;\r\n            }\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored object store proxy\r\n   * @param {IDBObjectStore} store - Original object store\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored object store\r\n   */\r\n  static createMonitoredObjectStore(store, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    const monitoredStore = new Proxy(store, {\r\n      get(target, property) {\r\n        if (typeof target[property] === 'function') {\r\n          return (...args) => {\r\n            const result = target[property](...args);\r\n\r\n            // Monitor async operations\r\n            if (result && typeof result.then === 'function') {\r\n              if (strictAsync && activePromises.size > 0) {\r\n                throw new TransactionError(\r\n                  'Cannot start new async operation while another is pending. ' +\r\n                  'Use withTransaction() for complex async operations.'\r\n                );\r\n              }\r\n\r\n              activePromises.add(result);\r\n\r\n              // Add error handling\r\n              result.catch(() => {\r\n                activePromises.delete(result);\r\n              }).finally(() => {\r\n                activePromises.delete(result);\r\n              });\r\n            }\r\n\r\n            return result;\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n\r\n    return monitoredStore;\r\n  }\r\n\r\n  /**\r\n   * Creates a promise-based wrapper for IDBRequest\r\n   * @param {IDBRequest} request - The IndexedDB request\r\n   * @returns {Promise} Resolves with the result\r\n   */\r\n  static promisifyRequest(request) {\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => {\r\n        console.error('IDBRequest failed:', request.error.name, request.error.message);\r\n        reject(new TransactionError(`Request failed: ${request.error.name} - ${request.error.message}`, request.error));\r\n      };\r\n    });\r\n  }\r\n}","import { MigrationError } from './ErrorHandler.js';\r\nimport TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles schema migrations\r\n */\r\nexport default class MigrationManager {\r\n  /**\r\n   * Runs migrations from old version to new version\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Array<Function>} migrations - Array of migration functions\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   */\r\n  static async runMigrations(db, migrations, fromVersion, toVersion) {\r\n    if (!migrations || fromVersion >= toVersion) return;\r\n\r\n    for (let i = fromVersion; i < toVersion; i++) {\r\n      const migrationIndex = i; // migrations[0] is for version 1->2\r\n\r\n      if (migrations[migrationIndex]) {\r\n        try {\r\n          await TransactionManager.execute(db, [], 'readwrite', (transaction) => {\r\n            return migrations[migrationIndex](db, transaction);\r\n          });\r\n        } catch (error) {\r\n          throw new MigrationError(`Migration from version ${i} to ${i + 1} failed`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","import { ConnectionError } from './ErrorHandler.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport MigrationManager from './MigrationManager.js';\r\n\r\n/**\r\n * Manages IndexedDB database connections\r\n */\r\nexport default class ConnectionManager {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.db = null;\r\n    this.oldVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>} The database instance\r\n   */\r\n  open() {\r\n    return new Promise((resolve, reject) => {\r\n      const indexedDB = globalThis.indexedDB || window?.indexedDB;\r\n      if (!indexedDB) {\r\n        reject(new ConnectionError('IndexedDB not supported'));\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => {\r\n        reject(new ConnectionError('Failed to open database', request.error));\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        this.db = event.target.result;\r\n        this.oldVersion = event.oldVersion;\r\n        SchemaManager.createSchema(this.db, this.schema);\r\n      };\r\n\r\n      request.onsuccess = async () => {\r\n        this.db = request.result;\r\n        if (this.oldVersion < this.version) {\r\n          try {\r\n            await MigrationManager.runMigrations(this.db, this.migrations, this.oldVersion, this.version);\r\n          } catch (error) {\r\n            reject(error);\r\n            return;\r\n          }\r\n        }\r\n        resolve(this.db);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is currently open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.db !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.db;\r\n  }\r\n}","import TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles advanced querying with filters and operators\r\n */\r\nexport default class QueryEngine {\r\n  /**\r\n   * Executes a query with filters using optimized index-aware approach\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (sort, limit, offset, etc.)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  static async query(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      // Analyze query and plan execution\r\n      const queryPlan = this.analyzeQuery(filters, store, options);\r\n\r\n      if (queryPlan.compoundFilters) {\r\n        // Handle compound queries ($and, $or)\r\n        return this.executeCompoundQuery(store, queryPlan.compoundFilters, queryPlan);\r\n      } else if (queryPlan.canUseIndex) {\r\n        // Execute using index cursor\r\n        return this.executeIndexQuery(store, queryPlan);\r\n      } else {\r\n        // Fall back to full scan with in-memory filtering\r\n        return this.executeFullScanQuery(store, filters, queryPlan);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query without executing it\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  static async analyzeQueryPlan(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return this.analyzeQuery(filters, store, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes query to determine optimal execution plan\r\n   * @param {Object} filters - Query filters\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} options - Query options\r\n   * @returns {Object} Query execution plan\r\n   */\r\n  static analyzeQuery(filters, store, options) {\r\n    const plan = {\r\n      canUseIndex: false,\r\n      indexName: null,\r\n      keyRange: null,\r\n      postFilters: {},\r\n      compoundFilters: null, // For $and/$or operations\r\n      sortField: options.sort,\r\n      limit: options.limit,\r\n      offset: options.offset || 0,\r\n      estimatedCost: 0,\r\n      optimizationNotes: []\r\n    };\r\n\r\n    // Check if we have any filters\r\n    if (Object.keys(filters).length === 0) {\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Full table scan - no filters provided');\r\n      return plan; // No filters, will use full scan\r\n    }\r\n\r\n    // Check for compound operators\r\n    if (filters.$and || filters.$or) {\r\n      plan.compoundFilters = filters;\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Compound query requires full scan');\r\n      // Compound queries require full scan for now\r\n      // TODO: Optimize compound queries with multiple indexes\r\n      return plan;\r\n    }\r\n\r\n    // Analyze each filter\r\n    for (const [field, value] of Object.entries(filters)) {\r\n      const indexName = this.findIndexForField(store, field);\r\n\r\n      if (indexName && this.canUseIndexForFilter(value)) {\r\n        // We can use an index for this filter\r\n        plan.canUseIndex = true;\r\n        plan.indexName = indexName;\r\n        plan.keyRange = this.createKeyRange(value);\r\n        plan.estimatedCost = this.estimateIndexQueryCost(store, indexName, value);\r\n        plan.optimizationNotes.push(`Using index '${indexName}' for field '${field}'`);\r\n      } else {\r\n        // This filter requires post-processing\r\n        plan.postFilters[field] = value;\r\n        if (!plan.canUseIndex) {\r\n          plan.estimatedCost = this.estimateFullScanCost(store);\r\n          plan.optimizationNotes.push(`Full scan required for non-indexed field '${field}'`);\r\n        } else {\r\n          plan.optimizationNotes.push(`Post-filtering required for field '${field}'`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of a full table scan\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @returns {number} Estimated cost (higher = more expensive)\r\n   */\r\n  static estimateFullScanCost(store) {\r\n    // Simple estimation: assume we need to scan all records\r\n    // In a real implementation, this could use store statistics\r\n    return 100; // Base cost for full scan\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of an index-based query\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} indexName - Index name\r\n   * @param {*} filterValue - Filter value\r\n   * @returns {number} Estimated cost\r\n   */\r\n  static estimateIndexQueryCost(store, indexName, filterValue) {\r\n    // Simple estimation based on filter type\r\n    if (typeof filterValue === 'object' && filterValue !== null) {\r\n      // Range queries are more expensive than exact matches\r\n      const op = Object.keys(filterValue)[0];\r\n      if (['$gt', '$gte', '$lt', '$lte'].includes(op)) {\r\n        return 20; // Range query\r\n      }\r\n    }\r\n    return 5; // Exact match or equality\r\n  }\r\n\r\n  /**\r\n   * Finds an index that can be used for the given field\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} field - Field name\r\n   * @returns {string|null} Index name or null\r\n   */\r\n  static findIndexForField(store, field) {\r\n    // Check if field is the key path\r\n    if (store.keyPath === field) {\r\n      return null; // Primary key doesn't need index\r\n    }\r\n\r\n    // Look for an index on this field\r\n    for (const indexName of store.indexNames) {\r\n      const index = store.index(indexName);\r\n      if (index.keyPath === field) {\r\n        return indexName;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks if a filter value can be optimized with an index\r\n   * @param {*} value - Filter value\r\n   * @returns {boolean}\r\n   */\r\n  static canUseIndexForFilter(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // Check if it's a range operator\r\n      const operators = Object.keys(value);\r\n      return operators.length === 1 && ['$gt', '$gte', '$lt', '$lte', '$eq'].includes(operators[0]);\r\n    }\r\n\r\n    // Equality filter\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates IDBKeyRange from filter value\r\n   * @param {*} value - Filter value\r\n   * @returns {IDBKeyRange|null}\r\n   */\r\n  static createKeyRange(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      const [op, val] = Object.entries(value)[0];\r\n\r\n      switch (op) {\r\n        case '$gt':\r\n          return IDBKeyRange.lowerBound(val, true);\r\n        case '$gte':\r\n          return IDBKeyRange.lowerBound(val);\r\n        case '$lt':\r\n          return IDBKeyRange.upperBound(val, true);\r\n        case '$lte':\r\n          return IDBKeyRange.upperBound(val);\r\n        case '$eq':\r\n          return IDBKeyRange.only(val);\r\n        default:\r\n          return null;\r\n      }\r\n    } else {\r\n      // Equality\r\n      return IDBKeyRange.only(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes query using index cursor\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeIndexQuery(store, plan) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      let skipped = 0;\r\n\r\n      const index = store.index(plan.indexName);\r\n      const request = index.openCursor(plan.keyRange);\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          // Apply post-filters if any\r\n          if (Object.keys(plan.postFilters).length === 0 ||\r\n              this.matchesFilters(cursor.value, plan.postFilters)) {\r\n\r\n            // Handle offset\r\n            if (skipped < plan.offset) {\r\n              skipped++;\r\n            } else {\r\n              tempResults.push(cursor.value);\r\n\r\n              // For index queries, we need to collect all results first for sorting\r\n              // In a more advanced implementation, we could use multiple indexes\r\n            }\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and final limit/offset\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes compound query ($and, $or)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} compoundFilters - Compound filter object\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeCompoundQuery(store, compoundFilters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesCompoundFilters(cursor.value, compoundFilters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes query with full table scan (fallback)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeFullScanQuery(store, filters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesFilters(cursor.value, filters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Applies sorting and pagination to results\r\n   * @param {Array} results - Query results\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Array} Sorted and paginated results\r\n   */\r\n  static applySortingAndPagination(results, plan) {\r\n    let processedResults = [...results];\r\n\r\n    // Apply sorting if specified\r\n    if (plan.sortField) {\r\n      const [field, direction] = Object.entries(plan.sortField)[0];\r\n      processedResults.sort((a, b) => {\r\n        const aVal = a[field];\r\n        const bVal = b[field];\r\n\r\n        if (aVal < bVal) return direction === 1 ? -1 : 1;\r\n        if (aVal > bVal) return direction === 1 ? 1 : -1;\r\n        return 0;\r\n      });\r\n    }\r\n\r\n    // Apply offset and limit\r\n    if (plan.offset > 0) {\r\n      processedResults = processedResults.slice(plan.offset);\r\n    }\r\n\r\n    if (plan.limit > 0) {\r\n      processedResults = processedResults.slice(0, plan.limit);\r\n    }\r\n\r\n    return processedResults;\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches compound filters ($and, $or)\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} compoundFilters - Compound filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesCompoundFilters(record, compoundFilters) {\r\n    if (compoundFilters.$and) {\r\n      // All conditions must be true\r\n      return compoundFilters.$and.every(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    } else if (compoundFilters.$or) {\r\n      // At least one condition must be true\r\n      return compoundFilters.$or.some(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    }\r\n\r\n    // Fallback to regular filters\r\n    return this.matchesFilters(record, compoundFilters);\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches the given filters\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} filters - Filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesFilters(record, filters) {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      if (key === '$and' || key === '$or') {\r\n        // Handle nested compound operators\r\n        if (!this.matchesCompoundFilters(record, { [key]: value })) {\r\n          return false;\r\n        }\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Operator-based filter\r\n        if (!this.evaluateOperator(record[key], value)) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Equality filter\r\n        if (record[key] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Evaluates operator-based conditions\r\n   * @param {*} fieldValue - Value from the record\r\n   * @param {Object} operator - Operator object (e.g., { $gt: 5 })\r\n   * @returns {boolean}\r\n   */\r\n  static evaluateOperator(fieldValue, operator) {\r\n    const [op, value] = Object.entries(operator)[0];\r\n\r\n    switch (op) {\r\n      case '$gt':\r\n        return fieldValue > value;\r\n      case '$gte':\r\n        return fieldValue >= value;\r\n      case '$lt':\r\n        return fieldValue < value;\r\n      case '$lte':\r\n        return fieldValue <= value;\r\n      case '$eq':\r\n        return fieldValue === value;\r\n      case '$ne':\r\n        return fieldValue !== value;\r\n      case '$regex':\r\n        return new RegExp(value).test(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}","import ConnectionManager from './ConnectionManager.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport TransactionManager from './TransactionManager.js';\r\nimport QueryEngine from './QueryEngine.js';\r\n\r\n/**\r\n * Main IndexedDB wrapper class\r\n */\r\nexport default class IDBWrapper {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    // Validate schema upfront\r\n    SchemaManager.validateSchema(schema);\r\n\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n\r\n    this.connectionManager = new ConnectionManager(dbName, version, schema, migrations);\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>}\r\n   */\r\n  async open() {\r\n    return this.connectionManager.open();\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    this.connectionManager.close();\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.connectionManager.isOpen();\r\n  }\r\n\r\n  /**\r\n   * Gets the database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.connectionManager.getDatabase();\r\n  }\r\n\r\n  /**\r\n   * Creates a new record\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} data - Data to store\r\n   * @returns {Promise} Resolves with the key\r\n   */\r\n  async create(storeName, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.add(data));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a record by key\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves with the record or undefined\r\n   */\r\n  async read(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readonly', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.get(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @param {Object} data - Updated data\r\n   * @returns {Promise} Resolves when updated\r\n   */\r\n  async update(storeName, key, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const getRequest = store.get(key);\r\n        getRequest.onsuccess = () => {\r\n          const existing = getRequest.result;\r\n          if (!existing) {\r\n            reject(new Error('Record not found'));\r\n            return;\r\n          }\r\n          const updatedData = { ...existing, ...data };\r\n          const putRequest = store.put(updatedData);\r\n          putRequest.onsuccess = () => resolve();\r\n          putRequest.onerror = () => reject(new TransactionError('Put failed', putRequest.error));\r\n        };\r\n        getRequest.onerror = () => reject(new TransactionError('Get failed', getRequest.error));\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves when deleted\r\n   */\r\n  async delete(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.delete(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries records with filters\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (limit, offset, sort)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  async query(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.query(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query plan without executing it\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  async analyzeQuery(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.analyzeQueryPlan(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Performs bulk operations\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async bulk(storeName, operations) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      const promises = operations.map(op => {\r\n        switch (op.type) {\r\n          case 'create':\r\n            return TransactionManager.promisifyRequest(store.add(op.data));\r\n          case 'update':\r\n            return TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n          case 'delete':\r\n            return TransactionManager.promisifyRequest(store.delete(op.id));\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n      });\r\n\r\n      return Promise.all(promises);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes operations within a safe transaction context\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} callback - Function to execute within transaction\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the callback\r\n   */\r\n  async withTransaction(storeNames, mode, callback, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    const transactionOptions = {\r\n      timeout: options.timeout || 5000,\r\n      strictAsync: options.strictAsync !== false, // Default to strict\r\n      ...options\r\n    };\r\n\r\n    return TransactionManager.execute(db, storeNames, mode, callback, transactionOptions);\r\n  }\r\n\r\n  /**\r\n   * Performs a safe bulk operation with transaction guarantees\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async safeBulk(storeName, operations, options = {}) {\r\n    return this.withTransaction(storeName, 'readwrite', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      const results = [];\r\n\r\n      for (const op of operations) {\r\n        let result;\r\n        switch (op.type) {\r\n          case 'create':\r\n            result = await TransactionManager.promisifyRequest(store.add(op.data));\r\n            break;\r\n          case 'update':\r\n            result = await TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n            break;\r\n          case 'delete':\r\n            result = await TransactionManager.promisifyRequest(store.delete(op.id));\r\n            break;\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n        results.push(result);\r\n      }\r\n\r\n      return results;\r\n    }, options);\r\n  }\r\n}"],"names":["IDBError","Error","constructor","message","originalError","super","this","name","ConnectionError","SchemaError","MigrationError","TransactionError","code","TransactionInactiveError","TransactionTimeoutError","timeout","SchemaManager","validateSchema","schema","stores","storeName","storeConfig","Object","entries","keyPath","indexes","indexName","indexConfig","unique","createSchema","db","objectStoreNames","contains","store","createObjectStore","autoIncrement","createIndex","checkSchemaConsistency","keys","TransactionManager","execute","storeNames","mode","operation","options","strictAsync","Promise","resolve","reject","transaction","timeoutId","completed","setTimeout","readyState","abort","error","onerror","clearTimeout","onabort","activePromises","Set","async","txn","executeWithSafety","safeOperation","then","result","oncomplete","catch","safety","createMonitoredTransaction","add","resolvedResult","delete","Proxy","get","target","property","objectStore","createMonitoredObjectStore","args","size","finally","promisifyRequest","request","onsuccess","console","MigrationManager","runMigrations","migrations","fromVersion","toVersion","i","migrationIndex","ConnectionManager","dbName","version","oldVersion","open","indexedDB","globalThis","window","onupgradeneeded","event","close","isOpen","getDatabase","QueryEngine","query","filters","queryPlan","analyzeQuery","compoundFilters","executeCompoundQuery","canUseIndex","executeIndexQuery","executeFullScanQuery","analyzeQueryPlan","plan","keyRange","postFilters","sortField","sort","limit","offset","estimatedCost","optimizationNotes","length","estimateFullScanCost","push","$and","$or","field","value","findIndexForField","canUseIndexForFilter","createKeyRange","estimateIndexQueryCost","filterValue","op","includes","indexNames","index","operators","IDBKeyRange","only","val","lowerBound","upperBound","results","tempResults","skipped","openCursor","cursor","matchesFilters","continue","applySortingAndPagination","matchesCompoundFilters","processedResults","direction","a","b","aVal","bVal","slice","record","every","condition","values","some","key","evaluateOperator","fieldValue","operator","RegExp","test","IDBWrapper","connectionManager","create","data","read","update","getRequest","existing","updatedData","putRequest","put","bulk","operations","promises","map","type","id","all","withTransaction","callback","transactionOptions","safeBulk"],"mappings":"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"}