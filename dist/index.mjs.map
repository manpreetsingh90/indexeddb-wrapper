{"version":3,"file":"index.mjs","sources":["../src/ErrorHandler.js","../src/SchemaManager.js","../src/TransactionManager.js","../src/MigrationManager.js","../src/ConnectionManager.js","../src/QueryEngine.js","../src/PerformanceUtils.js","../src/IDBWrapper.js"],"sourcesContent":["/**\r\n * Base error class for IndexedDB operations\r\n */\r\nexport class IDBError extends Error {\r\n  constructor(message, originalError = null) {\r\n    super(message);\r\n    this.name = 'IDBError';\r\n    this.originalError = originalError;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when database connection fails\r\n */\r\nexport class ConnectionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'ConnectionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when schema validation fails\r\n */\r\nexport class SchemaError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'SchemaError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration fails\r\n */\r\nexport class MigrationError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction fails\r\n */\r\nexport class TransactionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionError';\r\n    this.code = 'ERR_TRANSACTION_FAILED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction becomes inactive\r\n */\r\nexport class TransactionInactiveError extends TransactionError {\r\n  constructor(message = 'Transaction became inactive', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionInactiveError';\r\n    this.code = 'ERR_TRANSACTION_INACTIVE';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction times out\r\n */\r\nexport class TransactionTimeoutError extends TransactionError {\r\n  constructor(timeout, originalError = null) {\r\n    super(`Transaction timeout after ${timeout}ms`, originalError);\r\n    this.name = 'TransactionTimeoutError';\r\n    this.code = 'ERR_TRANSACTION_TIMEOUT';\r\n    this.timeout = timeout;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when storage quota is exceeded\r\n */\r\nexport class QuotaExceededError extends IDBError {\r\n  constructor(message = 'Storage quota exceeded', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'QuotaExceededError';\r\n    this.code = 'ERR_QUOTA_EXCEEDED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration rollback fails\r\n */\r\nexport class MigrationRollbackError extends MigrationError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationRollbackError';\r\n    this.code = 'ERR_MIGRATION_ROLLBACK_FAILED';\r\n  }\r\n}","import { SchemaError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages schema validation and object store creation\r\n */\r\nexport default class SchemaManager {\r\n  /**\r\n   * Validates the schema structure\r\n   * @param {Object} schema - The schema definition\r\n   * @throws {SchemaError} If schema is invalid\r\n   */\r\n  static validateSchema(schema) {\r\n    if (!schema || typeof schema !== 'object') {\r\n      throw new SchemaError('Schema must be an object');\r\n    }\r\n\r\n    if (!schema.stores || typeof schema.stores !== 'object') {\r\n      throw new SchemaError('Schema must have a stores property');\r\n    }\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!storeConfig || typeof storeConfig !== 'object') {\r\n        throw new SchemaError(`Store ${storeName} configuration must be an object`);\r\n      }\r\n\r\n      if (!storeConfig.keyPath) {\r\n        throw new SchemaError(`Store ${storeName} must have a keyPath`);\r\n      }\r\n\r\n      // Validate indexes\r\n      if (storeConfig.indexes) {\r\n        if (typeof storeConfig.indexes !== 'object') {\r\n          throw new SchemaError(`Indexes for store ${storeName} must be an object`);\r\n        }\r\n\r\n        for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n          if (typeof indexConfig !== 'object') {\r\n            throw new SchemaError(`Index ${indexName} in store ${storeName} must be an object`);\r\n          }\r\n\r\n          if (!indexConfig.keyPath && !indexConfig.unique) {\r\n            // Allow minimal config, but warn if no keyPath\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates object stores and indexes in the database\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The schema definition\r\n   */\r\n  static createSchema(db, schema) {\r\n    this.validateSchema(schema);\r\n\r\n    // Create migration metadata store first\r\n    this.createMigrationStore(db);\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        const store = db.createObjectStore(storeName, {\r\n          keyPath: storeConfig.keyPath,\r\n          autoIncrement: storeConfig.autoIncrement || false\r\n        });\r\n\r\n        if (storeConfig.indexes) {\r\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n            const keyPath = indexConfig.keyPath || indexName;\r\n            store.createIndex(indexName, keyPath, {\r\n              unique: indexConfig.unique || false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates the migration metadata store\r\n   * @param {IDBDatabase} db - The database instance\r\n   */\r\n  static createMigrationStore(db) {\r\n    const MIGRATION_STORE = '_migration_meta';\r\n\r\n    if (!db.objectStoreNames.contains(MIGRATION_STORE)) {\r\n      db.createObjectStore(MIGRATION_STORE, {\r\n        keyPath: 'id'\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the existing schema matches the expected schema\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The expected schema\r\n   * @returns {boolean} True if schema matches\r\n   */\r\n  static checkSchemaConsistency(db, schema) {\r\n    // This would be more complex in a real implementation\r\n    // For now, just check if stores exist\r\n    for (const storeName of Object.keys(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}","import { TransactionError, TransactionInactiveError, TransactionTimeoutError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages IndexedDB transactions\r\n */\r\nexport default class TransactionManager {\r\n  /**\r\n   * Executes an operation within a transaction with safety checks\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} operation - Function that receives the transaction and performs operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the operation\r\n   */\r\n  static async execute(db, storeNames, mode, operation, options = {}) {\r\n    const {\r\n      timeout = 5000, // 5 second default timeout\r\n      strictAsync = true // Enforce no external async operations\r\n    } = options;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(storeNames, mode);\r\n      let timeoutId;\r\n      let completed = false;\r\n\r\n      // Set transaction timeout\r\n      if (timeout > 0) {\r\n        timeoutId = setTimeout(() => {\r\n          if (!completed && transaction.readyState === 'active') {\r\n            try {\r\n              transaction.abort();\r\n              reject(new TransactionTimeoutError(timeout));\r\n            } catch (error) {\r\n              // Transaction might already be finished\r\n              reject(new TransactionTimeoutError(timeout));\r\n            }\r\n          }\r\n        }, timeout);\r\n      }\r\n\r\n      transaction.onerror = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        reject(new TransactionError('Transaction failed', transaction.error));\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n\r\n        // Check if this was due to transaction becoming inactive\r\n        if (transaction.error && transaction.error.name === 'InvalidStateError') {\r\n          reject(new TransactionInactiveError('Transaction became inactive during operation'));\r\n        } else {\r\n          reject(new TransactionError('Transaction aborted'));\r\n        }\r\n      };\r\n\r\n      // Track async operations to prevent transaction invalidation\r\n      const activePromises = new Set();\r\n\r\n      const safeOperation = async (txn) => {\r\n        try {\r\n          // Wrap the operation to monitor async behavior\r\n          const result = await this.executeWithSafety(txn, operation, {\r\n            strictAsync,\r\n            activePromises,\r\n            transaction\r\n          });\r\n          return result;\r\n        } catch (error) {\r\n          throw new TransactionError('Operation failed', error);\r\n        }\r\n      };\r\n\r\n      // Execute the operation\r\n      safeOperation(transaction)\r\n        .then((result) => {\r\n          // Wait for transaction completion\r\n          transaction.oncomplete = () => {\r\n            completed = true;\r\n            if (timeoutId) clearTimeout(timeoutId);\r\n            resolve(result);\r\n          };\r\n        })\r\n        .catch((error) => {\r\n          completed = true;\r\n          if (timeoutId) clearTimeout(timeoutId);\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes operation with safety monitoring\r\n   * @param {IDBTransaction} transaction - The transaction\r\n   * @param {Function} operation - The operation to execute\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Promise} Operation result\r\n   */\r\n  static async executeWithSafety(transaction, operation, safety) {\r\n    const { strictAsync, activePromises, transaction: txn } = safety;\r\n\r\n    // Create a proxy to monitor transaction access\r\n    const monitoredTransaction = this.createMonitoredTransaction(transaction, safety);\r\n\r\n    // Execute the operation\r\n    const result = operation(monitoredTransaction);\r\n\r\n    // If result is a promise, monitor it\r\n    if (result && typeof result.then === 'function') {\r\n      activePromises.add(result);\r\n\r\n      try {\r\n        const resolvedResult = await result;\r\n        activePromises.delete(result);\r\n        return resolvedResult;\r\n      } catch (error) {\r\n        activePromises.delete(result);\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored transaction proxy\r\n   * @param {IDBTransaction} transaction - Original transaction\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored transaction\r\n   */\r\n  static createMonitoredTransaction(transaction, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    return new Proxy(transaction, {\r\n      get(target, property) {\r\n        // Monitor transaction state\r\n        if (property === 'objectStore') {\r\n          return (storeName) => {\r\n            // Check if transaction is still active\r\n            if (target.error) {\r\n              throw new TransactionError('Transaction is in error state', target.error);\r\n            }\r\n\r\n            // Check if transaction is still active (not aborted or completed)\r\n            if (target.mode === 'versionchange') {\r\n              // Version change transactions are special\r\n            } else if (target.readyState === 'finished') {\r\n              throw new TransactionInactiveError('Transaction has already finished');\r\n            }\r\n\r\n            try {\r\n              const store = target.objectStore(storeName);\r\n              // Return monitored object store\r\n              return TransactionManager.createMonitoredObjectStore(store, safety);\r\n            } catch (error) {\r\n              if (error.name === 'InvalidStateError') {\r\n                throw new TransactionInactiveError('Cannot access object store - transaction is inactive');\r\n              }\r\n              throw error;\r\n            }\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored object store proxy\r\n   * @param {IDBObjectStore} store - Original object store\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored object store\r\n   */\r\n  static createMonitoredObjectStore(store, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    const monitoredStore = new Proxy(store, {\r\n      get(target, property) {\r\n        if (typeof target[property] === 'function') {\r\n          return (...args) => {\r\n            const result = target[property](...args);\r\n\r\n            // Monitor async operations\r\n            if (result && typeof result.then === 'function') {\r\n              if (strictAsync && activePromises.size > 0) {\r\n                throw new TransactionError(\r\n                  'Cannot start new async operation while another is pending. ' +\r\n                  'Use withTransaction() for complex async operations.'\r\n                );\r\n              }\r\n\r\n              activePromises.add(result);\r\n\r\n              // Add error handling\r\n              result.catch(() => {\r\n                activePromises.delete(result);\r\n              }).finally(() => {\r\n                activePromises.delete(result);\r\n              });\r\n            }\r\n\r\n            return result;\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n\r\n    return monitoredStore;\r\n  }\r\n\r\n  /**\r\n   * Creates a promise-based wrapper for IDBRequest\r\n   * @param {IDBRequest} request - The IndexedDB request\r\n   * @returns {Promise} Resolves with the result\r\n   */\r\n  static promisifyRequest(request) {\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => {\r\n        console.error('IDBRequest failed:', request.error.name, request.error.message);\r\n        reject(new TransactionError(`Request failed: ${request.error.name} - ${request.error.message}`, request.error));\r\n      };\r\n    });\r\n  }\r\n}","import { MigrationError, MigrationRollbackError } from './ErrorHandler.js';\r\nimport TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles safe schema migrations with rollback capabilities\r\n */\r\nexport default class MigrationManager {\r\n  static MIGRATION_STORE = '_migration_meta';\r\n\r\n  /**\r\n   * Runs migrations from old version to new version with safety features\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Array<Migration>} migrations - Array of migration objects\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async runMigrations(db, migrations, fromVersion, toVersion, storeNames = []) {\r\n    if (!migrations || fromVersion >= toVersion) return;\r\n\r\n    // Ensure migration metadata store exists\r\n    await this.ensureMigrationStore(db);\r\n\r\n    // Check if migrations are already completed\r\n    const completedMigrations = await this.getCompletedMigrations(db);\r\n    const pendingMigrations = this.getPendingMigrations(migrations, fromVersion, toVersion, completedMigrations);\r\n\r\n    if (pendingMigrations.length === 0) {\r\n      console.log('All migrations already completed');\r\n      return;\r\n    }\r\n\r\n    console.log(`Running ${pendingMigrations.length} pending migrations...`);\r\n\r\n    for (const migration of pendingMigrations) {\r\n      await this.runMigrationSafely(db, migration, storeNames);\r\n    }\r\n\r\n    console.log('All migrations completed successfully');\r\n  }\r\n\r\n  /**\r\n   * Ensures the migration metadata store exists\r\n   * @param {IDBDatabase} db - Database instance\r\n   */\r\n  static async ensureMigrationStore(db) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      // This would be called during schema creation\r\n      // For existing databases, we need to handle this during upgrade\r\n      console.warn('Migration metadata store not found. This should be created during schema upgrade.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of completed migrations\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @returns {Promise<Array<string>>} Array of completed migration IDs\r\n   */\r\n  static async getCompletedMigrations(db) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return [];\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.getAll();\r\n        request.onsuccess = () => {\r\n          const completed = request.result\r\n            .filter(meta => meta.status === 'completed')\r\n            .map(meta => meta.id);\r\n          resolve(completed);\r\n        };\r\n        request.onerror = () => resolve([]);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets pending migrations that need to be run\r\n   * @param {Array<Migration>} migrations - All migrations\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   * @param {Array<string>} completed - Already completed migration IDs\r\n   * @returns {Array<Migration>} Pending migrations\r\n   */\r\n  static getPendingMigrations(migrations, fromVersion, toVersion, completed) {\r\n    return migrations\r\n      .filter(migration => {\r\n        const version = migration.version || migration.id;\r\n        return version > fromVersion && version <= toVersion && !completed.includes(migration.id);\r\n      })\r\n      .sort((a, b) => (a.version || a.id) - (b.version || b.id));\r\n  }\r\n\r\n  /**\r\n   * Runs a single migration with safety features\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to run\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async runMigrationSafely(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n    const startTime = Date.now();\r\n\r\n    console.log(`Starting migration: ${migrationId}`);\r\n\r\n    // Check if migration is already in progress\r\n    const status = await this.getMigrationStatus(db, migrationId);\r\n    if (status === 'in_progress') {\r\n      console.log(`Migration ${migrationId} already in progress, attempting resume...`);\r\n      return this.resumeMigration(db, migration, storeNames);\r\n    } else if (status === 'completed') {\r\n      console.log(`Migration ${migrationId} already completed`);\r\n      return;\r\n    }\r\n\r\n    // Mark migration as in progress\r\n    await this.setMigrationStatus(db, migrationId, 'in_progress', { startTime });\r\n\r\n    try {\r\n      // Run the migration with checkpointing\r\n      await this.executeMigrationWithCheckpointing(db, migration, storeNames);\r\n\r\n      // Mark as completed\r\n      const endTime = Date.now();\r\n      await this.setMigrationStatus(db, migrationId, 'completed', {\r\n        startTime,\r\n        endTime,\r\n        duration: endTime - startTime\r\n      });\r\n\r\n      console.log(`Migration ${migrationId} completed successfully in ${endTime - startTime}ms`);\r\n\r\n    } catch (error) {\r\n      console.error(`Migration ${migrationId} failed:`, error);\r\n\r\n      // Mark as failed\r\n      await this.setMigrationStatus(db, migrationId, 'failed', {\r\n        startTime,\r\n        error: error.message,\r\n        stack: error.stack\r\n      });\r\n\r\n      // Attempt rollback if available\r\n      if (migration.rollback) {\r\n        try {\r\n          console.log(`Attempting rollback for migration ${migrationId}...`);\r\n          await this.rollbackMigration(db, migration, storeNames);\r\n          await this.setMigrationStatus(db, migrationId, 'rolled_back', {\r\n            startTime,\r\n            rollbackTime: Date.now(),\r\n            originalError: error.message\r\n          });\r\n          console.log(`Rollback completed for migration ${migrationId}`);\r\n        } catch (rollbackError) {\r\n          console.error(`Rollback failed for migration ${migrationId}:`, rollbackError);\r\n          await this.setMigrationStatus(db, migrationId, 'rollback_failed', {\r\n            startTime,\r\n            originalError: error.message,\r\n            rollbackError: rollbackError.message\r\n          });\r\n          throw new MigrationRollbackError(`Migration ${migrationId} failed and rollback unsuccessful`, rollbackError);\r\n        }\r\n      }\r\n\r\n      throw new MigrationError(`Migration ${migrationId} failed`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes migration with checkpointing for resumability\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to execute\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async executeMigrationWithCheckpointing(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n\r\n    if (migration.checkpointed && typeof migration.up === 'function') {\r\n      // For large migrations, implement checkpointing\r\n      let checkpoint = await this.getMigrationCheckpoint(db, migrationId) || 0;\r\n      const batchSize = migration.batchSize || 1000;\r\n\r\n      while (true) {\r\n        const result = await migration.up(db, checkpoint, batchSize);\r\n\r\n        if (result.completed) {\r\n          break;\r\n        }\r\n\r\n        checkpoint = result.nextCheckpoint;\r\n        await this.setMigrationCheckpoint(db, migrationId, checkpoint);\r\n\r\n        // Allow UI updates and prevent blocking\r\n        await new Promise(resolve => setTimeout(resolve, 0));\r\n      }\r\n    } else {\r\n      // Simple migration without checkpointing\r\n      // Use all available stores for the transaction scope\r\n      const transactionStores = storeNames.length > 0 ? storeNames : [this.MIGRATION_STORE];\r\n      await TransactionManager.execute(db, transactionStores, 'readwrite', (transaction) => {\r\n        return migration.up(db, transaction);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resumes a migration that was previously interrupted\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to resume\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async resumeMigration(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n    const checkpoint = await this.getMigrationCheckpoint(db, migrationId);\r\n\r\n    if (checkpoint !== null && migration.checkpointed) {\r\n      console.log(`Resuming migration ${migrationId} from checkpoint ${checkpoint}`);\r\n      await this.executeMigrationWithCheckpointing(db, migration);\r\n    } else {\r\n      // Cannot resume, mark as failed and retry\r\n      await this.setMigrationStatus(db, migrationId, 'failed', {\r\n        error: 'Migration interrupted and cannot be resumed'\r\n      });\r\n      throw new MigrationError(`Migration ${migrationId} was interrupted and cannot be resumed`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rolls back a failed migration\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to rollback\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async rollbackMigration(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n\r\n    if (migration.rollback) {\r\n      // Use all available stores for the transaction scope\r\n      const transactionStores = storeNames.length > 0 ? storeNames : [this.MIGRATION_STORE];\r\n      await TransactionManager.execute(db, transactionStores, 'readwrite', (transaction) => {\r\n        return migration.rollback(db, transaction);\r\n      });\r\n    } else {\r\n      throw new MigrationRollbackError(`No rollback function provided for migration ${migrationId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets migration status\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @returns {Promise<string|null>} Migration status\r\n   */\r\n  static async getMigrationStatus(db, migrationId) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return null;\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.get(migrationId);\r\n        request.onsuccess = () => {\r\n          resolve(request.result ? request.result.status : null);\r\n        };\r\n        request.onerror = () => resolve(null);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets migration status\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @param {string} status - Migration status\r\n   * @param {Object} metadata - Additional metadata\r\n   */\r\n  static async setMigrationStatus(db, migrationId, status, metadata = {}) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      // Try to create the store if it doesn't exist\r\n      try {\r\n        await this.createMigrationStore(db);\r\n      } catch (error) {\r\n        console.warn('Could not create migration store:', error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    await TransactionManager.execute(db, [this.MIGRATION_STORE], 'readwrite', (transaction) => {\r\n      return new Promise((resolve, reject) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const data = {\r\n          id: migrationId,\r\n          status,\r\n          timestamp: Date.now(),\r\n          ...metadata\r\n        };\r\n\r\n        const request = store.put(data);\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets migration checkpoint\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @returns {Promise<any>} Checkpoint data\r\n   */\r\n  static async getMigrationCheckpoint(db, migrationId) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return null;\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.get(`${migrationId}_checkpoint`);\r\n        request.onsuccess = () => {\r\n          resolve(request.result ? request.result.checkpoint : null);\r\n        };\r\n        request.onerror = () => resolve(null);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets migration checkpoint\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @param {any} checkpoint - Checkpoint data\r\n   */\r\n  static async setMigrationCheckpoint(db, migrationId, checkpoint) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return;\r\n    }\r\n\r\n    await TransactionManager.execute(db, [this.MIGRATION_STORE], 'readwrite', (transaction) => {\r\n      return new Promise((resolve, reject) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const data = {\r\n          id: `${migrationId}_checkpoint`,\r\n          checkpoint,\r\n          timestamp: Date.now()\r\n        };\r\n\r\n        const request = store.put(data);\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates the migration metadata store\r\n   * @param {IDBDatabase} db - Database instance\r\n   */\r\n  static async createMigrationStore(db) {\r\n    // This should be called during database upgrade\r\n    // For now, we'll try to create it if possible\r\n    if (db.version > 1) {\r\n      console.warn('Migration store should be created during schema upgrade');\r\n    }\r\n  }\r\n}","import { ConnectionError } from './ErrorHandler.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport MigrationManager from './MigrationManager.js';\r\n\r\n/**\r\n * Manages IndexedDB database connections\r\n */\r\nexport default class ConnectionManager {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.db = null;\r\n    this.oldVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>} The database instance\r\n   */\r\n  open() {\r\n    return new Promise((resolve, reject) => {\r\n      const indexedDB = globalThis.indexedDB || window?.indexedDB;\r\n      if (!indexedDB) {\r\n        reject(new ConnectionError('IndexedDB not supported'));\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => {\r\n        reject(new ConnectionError('Failed to open database', request.error));\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        this.db = event.target.result;\r\n        this.oldVersion = event.oldVersion;\r\n        SchemaManager.createSchema(this.db, this.schema);\r\n      };\r\n\r\n      request.onsuccess = async () => {\r\n        this.db = request.result;\r\n        if (this.oldVersion < this.version) {\r\n          try {\r\n            // Convert legacy migration format to new format if needed\r\n            const normalizedMigrations = this.normalizeMigrations(this.migrations);\r\n            // Get store names from schema for transaction scopes\r\n            const storeNames = Object.keys(this.schema.stores || {});\r\n            await MigrationManager.runMigrations(this.db, normalizedMigrations, this.oldVersion, this.version, storeNames);\r\n          } catch (error) {\r\n            reject(error);\r\n            return;\r\n          }\r\n        }\r\n        resolve(this.db);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is currently open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.db !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.db;\r\n  }\r\n\r\n  /**\r\n   * Normalizes migrations from legacy format to new format\r\n   * @param {Array} migrations - Migration functions or objects\r\n   * @returns {Array} Normalized migration objects\r\n   */\r\n  normalizeMigrations(migrations) {\r\n    if (!migrations || !Array.isArray(migrations)) {\r\n      return [];\r\n    }\r\n\r\n    return migrations.map((migration, index) => {\r\n      // If it's already a migration object, return as-is\r\n      if (migration && typeof migration === 'object' && migration.id) {\r\n        return migration;\r\n      }\r\n\r\n      // Convert legacy function to migration object\r\n      if (typeof migration === 'function') {\r\n        return {\r\n          id: `migration_${index + 1}`,\r\n          version: index + 1,\r\n          up: migration,\r\n          checkpointed: false\r\n        };\r\n      }\r\n\r\n      // Invalid migration\r\n      console.warn(`Invalid migration at index ${index}:`, migration);\r\n      return null;\r\n    }).filter(Boolean);\r\n  }\r\n}","import TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles advanced querying with filters and operators\r\n */\r\nexport default class QueryEngine {\r\n  /**\r\n   * Executes a query with filters using optimized index-aware approach\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (sort, limit, offset, etc.)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  static async query(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      // Analyze query and plan execution\r\n      const queryPlan = this.analyzeQuery(filters, store, options);\r\n\r\n      if (queryPlan.compoundFilters) {\r\n        // Handle compound queries ($and, $or)\r\n        return this.executeCompoundQuery(store, queryPlan.compoundFilters, queryPlan);\r\n      } else if (queryPlan.canUseIndex) {\r\n        // Execute using index cursor\r\n        return this.executeIndexQuery(store, queryPlan);\r\n      } else {\r\n        // Fall back to full scan with in-memory filtering\r\n        return this.executeFullScanQuery(store, filters, queryPlan);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query without executing it\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  static async analyzeQueryPlan(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return this.analyzeQuery(filters, store, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes query to determine optimal execution plan\r\n   * @param {Object} filters - Query filters\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} options - Query options\r\n   * @returns {Object} Query execution plan\r\n   */\r\n  static analyzeQuery(filters, store, options) {\r\n    const plan = {\r\n      canUseIndex: false,\r\n      indexName: null,\r\n      keyRange: null,\r\n      postFilters: {},\r\n      compoundFilters: null, // For $and/$or operations\r\n      sortField: options.sort,\r\n      limit: options.limit,\r\n      offset: options.offset || 0,\r\n      estimatedCost: 0,\r\n      optimizationNotes: []\r\n    };\r\n\r\n    // Check if we have any filters\r\n    if (Object.keys(filters).length === 0) {\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Full table scan - no filters provided');\r\n      return plan; // No filters, will use full scan\r\n    }\r\n\r\n    // Check for compound operators\r\n    if (filters.$and || filters.$or) {\r\n      plan.compoundFilters = filters;\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Compound query requires full scan');\r\n      // Compound queries require full scan for now\r\n      // TODO: Optimize compound queries with multiple indexes\r\n      return plan;\r\n    }\r\n\r\n    // Analyze each filter\r\n    for (const [field, value] of Object.entries(filters)) {\r\n      const indexName = this.findIndexForField(store, field);\r\n\r\n      if (indexName && this.canUseIndexForFilter(value)) {\r\n        // We can use an index for this filter\r\n        plan.canUseIndex = true;\r\n        plan.indexName = indexName;\r\n        plan.keyRange = this.createKeyRange(value);\r\n        plan.estimatedCost = this.estimateIndexQueryCost(store, indexName, value);\r\n        plan.optimizationNotes.push(`Using index '${indexName}' for field '${field}'`);\r\n      } else {\r\n        // This filter requires post-processing\r\n        plan.postFilters[field] = value;\r\n        if (!plan.canUseIndex) {\r\n          plan.estimatedCost = this.estimateFullScanCost(store);\r\n          plan.optimizationNotes.push(`Full scan required for non-indexed field '${field}'`);\r\n        } else {\r\n          plan.optimizationNotes.push(`Post-filtering required for field '${field}'`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of a full table scan\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @returns {number} Estimated cost (higher = more expensive)\r\n   */\r\n  static estimateFullScanCost(store) {\r\n    // Simple estimation: assume we need to scan all records\r\n    // In a real implementation, this could use store statistics\r\n    return 100; // Base cost for full scan\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of an index-based query\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} indexName - Index name\r\n   * @param {*} filterValue - Filter value\r\n   * @returns {number} Estimated cost\r\n   */\r\n  static estimateIndexQueryCost(store, indexName, filterValue) {\r\n    // Simple estimation based on filter type\r\n    if (typeof filterValue === 'object' && filterValue !== null) {\r\n      // Range queries are more expensive than exact matches\r\n      const op = Object.keys(filterValue)[0];\r\n      if (['$gt', '$gte', '$lt', '$lte'].includes(op)) {\r\n        return 20; // Range query\r\n      }\r\n    }\r\n    return 5; // Exact match or equality\r\n  }\r\n\r\n  /**\r\n   * Finds an index that can be used for the given field\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} field - Field name\r\n   * @returns {string|null} Index name or null\r\n   */\r\n  static findIndexForField(store, field) {\r\n    // Check if field is the key path\r\n    if (store.keyPath === field) {\r\n      return null; // Primary key doesn't need index\r\n    }\r\n\r\n    // Look for an index on this field\r\n    for (const indexName of store.indexNames) {\r\n      const index = store.index(indexName);\r\n      if (index.keyPath === field) {\r\n        return indexName;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks if a filter value can be optimized with an index\r\n   * @param {*} value - Filter value\r\n   * @returns {boolean}\r\n   */\r\n  static canUseIndexForFilter(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // Check if it's a range operator\r\n      const operators = Object.keys(value);\r\n      return operators.length === 1 && ['$gt', '$gte', '$lt', '$lte', '$eq'].includes(operators[0]);\r\n    }\r\n\r\n    // Equality filter\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates IDBKeyRange from filter value\r\n   * @param {*} value - Filter value\r\n   * @returns {IDBKeyRange|null}\r\n   */\r\n  static createKeyRange(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      const [op, val] = Object.entries(value)[0];\r\n\r\n      switch (op) {\r\n        case '$gt':\r\n          return IDBKeyRange.lowerBound(val, true);\r\n        case '$gte':\r\n          return IDBKeyRange.lowerBound(val);\r\n        case '$lt':\r\n          return IDBKeyRange.upperBound(val, true);\r\n        case '$lte':\r\n          return IDBKeyRange.upperBound(val);\r\n        case '$eq':\r\n          return IDBKeyRange.only(val);\r\n        default:\r\n          return null;\r\n      }\r\n    } else {\r\n      // Equality\r\n      return IDBKeyRange.only(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes query using index cursor\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeIndexQuery(store, plan) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      let skipped = 0;\r\n\r\n      const index = store.index(plan.indexName);\r\n      const request = index.openCursor(plan.keyRange);\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          // Apply post-filters if any\r\n          if (Object.keys(plan.postFilters).length === 0 ||\r\n              this.matchesFilters(cursor.value, plan.postFilters)) {\r\n\r\n            // Handle offset\r\n            if (skipped < plan.offset) {\r\n              skipped++;\r\n            } else {\r\n              tempResults.push(cursor.value);\r\n\r\n              // For index queries, we need to collect all results first for sorting\r\n              // In a more advanced implementation, we could use multiple indexes\r\n            }\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and final limit/offset\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes compound query ($and, $or)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} compoundFilters - Compound filter object\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeCompoundQuery(store, compoundFilters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesCompoundFilters(cursor.value, compoundFilters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes query with full table scan (fallback)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeFullScanQuery(store, filters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesFilters(cursor.value, filters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Applies sorting and pagination to results\r\n   * @param {Array} results - Query results\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Array} Sorted and paginated results\r\n   */\r\n  static applySortingAndPagination(results, plan) {\r\n    let processedResults = [...results];\r\n\r\n    // Apply sorting if specified\r\n    if (plan.sortField) {\r\n      const [field, direction] = Object.entries(plan.sortField)[0];\r\n      processedResults.sort((a, b) => {\r\n        const aVal = a[field];\r\n        const bVal = b[field];\r\n\r\n        if (aVal < bVal) return direction === 1 ? -1 : 1;\r\n        if (aVal > bVal) return direction === 1 ? 1 : -1;\r\n        return 0;\r\n      });\r\n    }\r\n\r\n    // Apply offset and limit\r\n    if (plan.offset > 0) {\r\n      processedResults = processedResults.slice(plan.offset);\r\n    }\r\n\r\n    if (plan.limit > 0) {\r\n      processedResults = processedResults.slice(0, plan.limit);\r\n    }\r\n\r\n    return processedResults;\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches compound filters ($and, $or)\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} compoundFilters - Compound filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesCompoundFilters(record, compoundFilters) {\r\n    if (compoundFilters.$and) {\r\n      // All conditions must be true\r\n      return compoundFilters.$and.every(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    } else if (compoundFilters.$or) {\r\n      // At least one condition must be true\r\n      return compoundFilters.$or.some(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    }\r\n\r\n    // Fallback to regular filters\r\n    return this.matchesFilters(record, compoundFilters);\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches the given filters\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} filters - Filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesFilters(record, filters) {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      if (key === '$and' || key === '$or') {\r\n        // Handle nested compound operators\r\n        if (!this.matchesCompoundFilters(record, { [key]: value })) {\r\n          return false;\r\n        }\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Operator-based filter\r\n        if (!this.evaluateOperator(record[key], value)) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Equality filter\r\n        if (record[key] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Evaluates operator-based conditions\r\n   * @param {*} fieldValue - Value from the record\r\n   * @param {Object} operator - Operator object (e.g., { $gt: 5 })\r\n   * @returns {boolean}\r\n   */\r\n  static evaluateOperator(fieldValue, operator) {\r\n    const [op, value] = Object.entries(operator)[0];\r\n\r\n    switch (op) {\r\n      case '$gt':\r\n        return fieldValue > value;\r\n      case '$gte':\r\n        return fieldValue >= value;\r\n      case '$lt':\r\n        return fieldValue < value;\r\n      case '$lte':\r\n        return fieldValue <= value;\r\n      case '$eq':\r\n        return fieldValue === value;\r\n      case '$ne':\r\n        return fieldValue !== value;\r\n      case '$regex':\r\n        return new RegExp(value).test(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}","/**\r\n * Performance utilities for monitoring and optimizing IndexedDB operations\r\n */\r\nexport default class PerformanceUtils {\r\n  /**\r\n   * Calculates the approximate size of an object in bytes\r\n   * @param {any} obj - Object to measure\r\n   * @returns {number} Size in bytes\r\n   */\r\n  static calculateObjectSize(obj) {\r\n    if (obj === null || obj === undefined) return 0;\r\n\r\n    // For primitives, return a minimal size\r\n    if (typeof obj !== 'object') {\r\n      if (typeof obj === 'string') return obj.length * 2; // UTF-16\r\n      if (typeof obj === 'boolean') return 1;\r\n      if (typeof obj === 'number') return 8; // 64-bit\r\n      return 0;\r\n    }\r\n\r\n    // Handle arrays\r\n    if (Array.isArray(obj)) {\r\n      let size = 0;\r\n      for (const item of obj) {\r\n        size += this.calculateObjectSize(item);\r\n      }\r\n      return size + (obj.length * 8); // Array overhead\r\n    }\r\n\r\n    // Handle objects\r\n    let size = 0;\r\n    const visited = new WeakSet();\r\n\r\n    const calculateSize = (o) => {\r\n      if (o === null || o === undefined) return 0;\r\n      if (typeof o !== 'object') return this.calculateObjectSize(o);\r\n\r\n      // Prevent circular references\r\n      if (visited.has(o)) return 0;\r\n      visited.add(o);\r\n\r\n      let objSize = 0;\r\n\r\n      if (Array.isArray(o)) {\r\n        for (const item of o) {\r\n          objSize += calculateSize(item);\r\n        }\r\n        objSize += o.length * 8; // Array overhead\r\n      } else {\r\n        for (const key in o) {\r\n          if (o.hasOwnProperty(key)) {\r\n            objSize += key.length * 2; // Key size (UTF-16)\r\n            objSize += calculateSize(o[key]); // Value size\r\n          }\r\n        }\r\n        objSize += Object.keys(o).length * 16; // Object property overhead\r\n      }\r\n\r\n      return objSize;\r\n    };\r\n\r\n    return calculateSize(obj);\r\n  }\r\n\r\n  /**\r\n   * Measures the time taken for structured cloning\r\n   * @param {any} obj - Object to clone\r\n   * @returns {Object} Clone time and size metrics\r\n   */\r\n  static measureCloningPerformance(obj) {\r\n    const startTime = performance.now();\r\n    const size = this.calculateObjectSize(obj);\r\n\r\n    try {\r\n      // Perform structured cloning\r\n      const cloned = structuredClone(obj);\r\n      const endTime = performance.now();\r\n\r\n      return {\r\n        size,\r\n        cloneTime: endTime - startTime,\r\n        success: true,\r\n        cloned\r\n      };\r\n    } catch (error) {\r\n      const endTime = performance.now();\r\n\r\n      return {\r\n        size,\r\n        cloneTime: endTime - startTime,\r\n        success: false,\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if an object size exceeds performance thresholds\r\n   * @param {number} size - Object size in bytes\r\n   * @returns {Object} Performance assessment\r\n   */\r\n  static assessPerformance(size) {\r\n    const thresholds = {\r\n      small: 1024,      // 1KB\r\n      medium: 1024 * 1024,     // 1MB\r\n      large: 10 * 1024 * 1024, // 10MB\r\n      huge: 50 * 1024 * 1024   // 50MB\r\n    };\r\n\r\n    let level = 'small';\r\n    let warning = null;\r\n    let recommendation = null;\r\n\r\n    if (size >= thresholds.huge) {\r\n      level = 'huge';\r\n      warning = 'Extremely large object may cause performance issues';\r\n      recommendation = 'Consider breaking into smaller chunks or using external storage';\r\n    } else if (size >= thresholds.large) {\r\n      level = 'large';\r\n      warning = 'Large object may impact performance';\r\n      recommendation = 'Consider optimizing data structure or using pagination';\r\n    } else if (size >= thresholds.medium) {\r\n      level = 'medium';\r\n      warning = 'Medium-sized object - monitor performance';\r\n    }\r\n\r\n    return {\r\n      level,\r\n      size,\r\n      sizeKB: Math.round(size / 1024),\r\n      sizeMB: Math.round(size / (1024 * 1024) * 100) / 100,\r\n      warning,\r\n      recommendation,\r\n      thresholds\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Logs performance warnings for large objects\r\n   * @param {string} operation - Operation name\r\n   * @param {any} obj - Object being processed\r\n   * @param {Object} context - Additional context\r\n   */\r\n  static logPerformanceWarning(operation, obj, context = {}) {\r\n    const metrics = this.measureCloningPerformance(obj);\r\n    const assessment = this.assessPerformance(metrics.size);\r\n\r\n    if (assessment.warning) {\r\n      const message = `[Performance Warning] ${operation}: ${assessment.warning}\r\n        Size: ${assessment.sizeMB}MB (${assessment.sizeKB}KB)\r\n        ${assessment.recommendation || ''}\r\n        Context: ${JSON.stringify(context)}`;\r\n\r\n      console.warn(message);\r\n\r\n      // In development, throw error for huge objects\r\n      if (assessment.level === 'huge' && process.env.NODE_ENV === 'development') {\r\n        throw new Error(`Performance violation: ${message}`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      metrics,\r\n      assessment,\r\n      logged: !!assessment.warning\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Monitors transaction performance\r\n   * @param {string} operation - Operation name\r\n   * @param {Function} operationFn - Function to monitor\r\n   * @returns {Promise<Object>} Operation result with performance metrics\r\n   */\r\n  static async monitorTransaction(operation, operationFn) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const result = await operationFn();\r\n      const endTime = performance.now();\r\n\r\n      const metrics = {\r\n        operation,\r\n        duration: endTime - startTime,\r\n        success: true,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      // Log slow transactions\r\n      if (metrics.duration > 100) { // 100ms threshold\r\n        console.warn(`[Slow Transaction] ${operation} took ${metrics.duration.toFixed(2)}ms`);\r\n      }\r\n\r\n      return {\r\n        result,\r\n        metrics\r\n      };\r\n\r\n    } catch (error) {\r\n      const endTime = performance.now();\r\n\r\n      const metrics = {\r\n        operation,\r\n        duration: endTime - startTime,\r\n        success: false,\r\n        error: error.message,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      console.error(`[Transaction Error] ${operation} failed after ${metrics.duration.toFixed(2)}ms:`, error);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a performance-monitored version of a function\r\n   * @param {Function} fn - Original function\r\n   * @param {string} name - Function name for logging\r\n   * @returns {Function} Monitored function\r\n   */\r\n  static createMonitoredFunction(fn, name) {\r\n    return async (...args) => {\r\n      const startTime = performance.now();\r\n\r\n      try {\r\n        // Check object sizes for relevant arguments\r\n        for (let i = 0; i < args.length; i++) {\r\n          const arg = args[i];\r\n          if (arg && typeof arg === 'object') {\r\n            this.logPerformanceWarning(`${name}(arg${i})`, arg, { argIndex: i });\r\n          }\r\n        }\r\n\r\n        const result = await fn.apply(this, args);\r\n        const endTime = performance.now();\r\n\r\n        // Log slow operations\r\n        const duration = endTime - startTime;\r\n        if (duration > 50) { // 50ms threshold\r\n          console.warn(`[Slow Operation] ${name} took ${duration.toFixed(2)}ms`);\r\n        }\r\n\r\n        return result;\r\n\r\n      } catch (error) {\r\n        const endTime = performance.now();\r\n        const duration = endTime - startTime;\r\n\r\n        console.error(`[Operation Error] ${name} failed after ${duration.toFixed(2)}ms:`, error);\r\n        throw error;\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets performance statistics\r\n   * @returns {Object} Performance statistics\r\n   */\r\n  static getPerformanceStats() {\r\n    // This would integrate with a more comprehensive monitoring system\r\n    return {\r\n      timestamp: Date.now(),\r\n      memory: typeof performance.memory !== 'undefined' ? {\r\n        used: performance.memory.usedJSHeapSize,\r\n        total: performance.memory.totalJSHeapSize,\r\n        limit: performance.memory.jsHeapSizeLimit\r\n      } : null,\r\n      timing: performance.timing ? {\r\n        navigationStart: performance.timing.navigationStart,\r\n        loadEventEnd: performance.timing.loadEventEnd,\r\n        domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart\r\n      } : null\r\n    };\r\n  }\r\n}","import ConnectionManager from './ConnectionManager.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport TransactionManager from './TransactionManager.js';\r\nimport QueryEngine from './QueryEngine.js';\r\nimport PerformanceUtils from './PerformanceUtils.js';\r\n\r\n/**\r\n * Main IndexedDB wrapper class\r\n */\r\nexport default class IDBWrapper {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    // Validate schema upfront\r\n    SchemaManager.validateSchema(schema);\r\n\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n\r\n    this.connectionManager = new ConnectionManager(dbName, version, schema, migrations);\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>}\r\n   */\r\n  async open() {\r\n    return this.connectionManager.open();\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    this.connectionManager.close();\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.connectionManager.isOpen();\r\n  }\r\n\r\n  /**\r\n   * Gets the database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.connectionManager.getDatabase();\r\n  }\r\n\r\n  /**\r\n   * Creates a new record\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} data - Data to store\r\n   * @returns {Promise} Resolves with the key\r\n   */\r\n  async create(storeName, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    // Monitor performance for large objects\r\n    PerformanceUtils.logPerformanceWarning('IDBWrapper.create', data, { storeName });\r\n\r\n    return PerformanceUtils.monitorTransaction(`create(${storeName})`, () =>\r\n      TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n        const store = transaction.objectStore(storeName);\r\n        return TransactionManager.promisifyRequest(store.add(data));\r\n      })\r\n    ).then(result => result.result);\r\n  }\r\n\r\n  /**\r\n   * Reads a record by key\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves with the record or undefined\r\n   */\r\n  async read(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readonly', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.get(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @param {Object} data - Updated data\r\n   * @returns {Promise} Resolves when updated\r\n   */\r\n  async update(storeName, key, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    // Monitor performance for large objects\r\n    PerformanceUtils.logPerformanceWarning('IDBWrapper.update', data, { storeName, key });\r\n\r\n    return PerformanceUtils.monitorTransaction(`update(${storeName})`, () =>\r\n      TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n        const store = transaction.objectStore(storeName);\r\n\r\n        return new Promise((resolve, reject) => {\r\n          const getRequest = store.get(key);\r\n          getRequest.onsuccess = () => {\r\n            const existing = getRequest.result;\r\n            if (!existing) {\r\n              reject(new Error('Record not found'));\r\n              return;\r\n            }\r\n            const updatedData = { ...existing, ...data };\r\n            const putRequest = store.put(updatedData);\r\n            putRequest.onsuccess = () => resolve();\r\n            putRequest.onerror = () => reject(new TransactionError('Put failed', putRequest.error));\r\n          };\r\n          getRequest.onerror = () => reject(new TransactionError('Get failed', getRequest.error));\r\n        });\r\n      })\r\n    ).then(result => result.result);\r\n  }\r\n\r\n  /**\r\n   * Deletes a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves when deleted\r\n   */\r\n  async delete(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.delete(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries records with filters\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (limit, offset, sort)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  async query(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return PerformanceUtils.monitorTransaction(`query(${storeName})`, () =>\r\n      QueryEngine.query(db, storeName, filters, options)\r\n    ).then(result => result.result);\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query plan without executing it\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  async analyzeQuery(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.analyzeQueryPlan(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Performs bulk operations\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async bulk(storeName, operations) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    // Monitor performance for bulk operations\r\n    const totalSize = operations.reduce((size, op) => {\r\n      return size + PerformanceUtils.calculateObjectSize(op.data || {});\r\n    }, 0);\r\n\r\n    PerformanceUtils.logPerformanceWarning('IDBWrapper.bulk', { operations, totalSize }, {\r\n      storeName,\r\n      operationCount: operations.length\r\n    });\r\n\r\n    return PerformanceUtils.monitorTransaction(`bulk(${storeName}, ${operations.length} ops)`, () =>\r\n      TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n        const store = transaction.objectStore(storeName);\r\n\r\n        const promises = operations.map(op => {\r\n          switch (op.type) {\r\n            case 'create':\r\n              return TransactionManager.promisifyRequest(store.add(op.data));\r\n            case 'update':\r\n              return TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n            case 'delete':\r\n              return TransactionManager.promisifyRequest(store.delete(op.id));\r\n            default:\r\n              throw new Error(`Unknown operation type: ${op.type}`);\r\n          }\r\n        });\r\n\r\n        return Promise.all(promises);\r\n      })\r\n    ).then(result => result.result);\r\n  }\r\n\r\n  /**\r\n   * Executes operations within a safe transaction context\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} callback - Function to execute within transaction\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the callback\r\n   */\r\n  async withTransaction(storeNames, mode, callback, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    const transactionOptions = {\r\n      timeout: options.timeout || 5000,\r\n      strictAsync: options.strictAsync !== false, // Default to strict\r\n      ...options\r\n    };\r\n\r\n    return TransactionManager.execute(db, storeNames, mode, callback, transactionOptions);\r\n  }\r\n\r\n  /**\r\n   * Performs a safe bulk operation with transaction guarantees\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async safeBulk(storeName, operations, options = {}) {\r\n    return this.withTransaction(storeName, 'readwrite', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      const results = [];\r\n\r\n      for (const op of operations) {\r\n        let result;\r\n        switch (op.type) {\r\n          case 'create':\r\n            result = await TransactionManager.promisifyRequest(store.add(op.data));\r\n            break;\r\n          case 'update':\r\n            result = await TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n            break;\r\n          case 'delete':\r\n            result = await TransactionManager.promisifyRequest(store.delete(op.id));\r\n            break;\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n        results.push(result);\r\n      }\r\n\r\n      return results;\r\n    }, options);\r\n  }\r\n}"],"names":["IDBError","Error","constructor","message","originalError","super","this","name","ConnectionError","SchemaError","MigrationError","TransactionError","code","TransactionInactiveError","TransactionTimeoutError","timeout","MigrationRollbackError","SchemaManager","validateSchema","schema","stores","storeName","storeConfig","Object","entries","keyPath","indexes","indexName","indexConfig","unique","createSchema","db","createMigrationStore","objectStoreNames","contains","store","createObjectStore","autoIncrement","createIndex","MIGRATION_STORE","checkSchemaConsistency","keys","TransactionManager","execute","storeNames","mode","operation","options","strictAsync","Promise","resolve","reject","transaction","timeoutId","completed","setTimeout","readyState","abort","error","onerror","clearTimeout","onabort","activePromises","Set","async","txn","executeWithSafety","safeOperation","then","result","oncomplete","catch","safety","createMonitoredTransaction","add","resolvedResult","delete","Proxy","get","target","property","objectStore","createMonitoredObjectStore","args","size","finally","promisifyRequest","request","onsuccess","console","MigrationManager","static","runMigrations","migrations","fromVersion","toVersion","ensureMigrationStore","completedMigrations","getCompletedMigrations","pendingMigrations","getPendingMigrations","length","log","migration","runMigrationSafely","warn","getAll","filter","meta","status","map","id","version","includes","sort","a","b","migrationId","startTime","Date","now","getMigrationStatus","resumeMigration","setMigrationStatus","executeMigrationWithCheckpointing","endTime","duration","stack","rollback","rollbackMigration","rollbackTime","rollbackError","checkpointed","up","checkpoint","getMigrationCheckpoint","batchSize","nextCheckpoint","setMigrationCheckpoint","transactionStores","metadata","data","timestamp","put","ConnectionManager","dbName","oldVersion","open","indexedDB","globalThis","window","onupgradeneeded","event","normalizedMigrations","normalizeMigrations","close","isOpen","getDatabase","Array","isArray","index","Boolean","QueryEngine","query","filters","queryPlan","analyzeQuery","compoundFilters","executeCompoundQuery","canUseIndex","executeIndexQuery","executeFullScanQuery","analyzeQueryPlan","plan","keyRange","postFilters","sortField","limit","offset","estimatedCost","optimizationNotes","estimateFullScanCost","push","$and","$or","field","value","findIndexForField","canUseIndexForFilter","createKeyRange","estimateIndexQueryCost","filterValue","op","indexNames","operators","IDBKeyRange","only","val","lowerBound","upperBound","results","tempResults","skipped","openCursor","cursor","matchesFilters","continue","applySortingAndPagination","matchesCompoundFilters","processedResults","direction","aVal","bVal","slice","record","every","condition","values","some","key","evaluateOperator","fieldValue","operator","RegExp","test","PerformanceUtils","calculateObjectSize","obj","item","visited","WeakSet","calculateSize","o","has","objSize","hasOwnProperty","measureCloningPerformance","performance","cloned","structuredClone","cloneTime","success","assessPerformance","thresholds","small","medium","large","huge","level","warning","recommendation","sizeKB","Math","round","sizeMB","logPerformanceWarning","context","metrics","assessment","JSON","stringify","process","env","NODE_ENV","logged","monitorTransaction","operationFn","toFixed","createMonitoredFunction","fn","i","arg","argIndex","apply","getPerformanceStats","memory","used","usedJSHeapSize","total","totalJSHeapSize","jsHeapSizeLimit","timing","navigationStart","loadEventEnd","domContentLoaded","domContentLoadedEventEnd","IDBWrapper","connectionManager","create","read","update","getRequest","existing","updatedData","putRequest","bulk","operations","totalSize","reduce","operationCount","promises","type","all","withTransaction","callback","transactionOptions","safeBulk"],"mappings":"AAGO,MAAMA,UAAiBC,MAC5B,WAAAC,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,GACNG,KAAKC,KAAO,WACZD,KAAKF,cAAgBA,CACtB,EAMI,MAAMI,UAAwBR,EACnC,WAAAE,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,EAASC,GACfE,KAAKC,KAAO,iBACb,EAMI,MAAME,UAAoBT,EAC/B,WAAAE,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,EAASC,GACfE,KAAKC,KAAO,aACb,EAMI,MAAMG,UAAuBV,EAClC,WAAAE,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,EAASC,GACfE,KAAKC,KAAO,gBACb,EAMI,MAAMI,UAAyBX,EACpC,WAAAE,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,EAASC,GACfE,KAAKC,KAAO,mBACZD,KAAKM,KAAO,wBACb,EAMI,MAAMC,UAAiCF,EAC5C,WAAAT,CAAYC,EAAU,8BAA+BC,EAAgB,MACnEC,MAAMF,EAASC,GACfE,KAAKC,KAAO,2BACZD,KAAKM,KAAO,0BACb,EAMI,MAAME,UAAgCH,EAC3C,WAAAT,CAAYa,EAASX,EAAgB,MACnCC,MAAM,6BAA6BU,MAAaX,GAChDE,KAAKC,KAAO,0BACZD,KAAKM,KAAO,0BACZN,KAAKS,QAAUA,CAChB,EAiBI,MAAMC,UAA+BN,EAC1C,WAAAR,CAAYC,EAASC,EAAgB,MACnCC,MAAMF,EAASC,GACfE,KAAKC,KAAO,yBACZD,KAAKM,KAAO,+BACb,ECzFY,MAAMK,EAMnB,qBAAOC,CAAeC,GACpB,IAAKA,GAA4B,iBAAXA,EACpB,MAAM,IAAIV,EAAY,4BAGxB,IAAKU,EAAOC,QAAmC,iBAAlBD,EAAOC,OAClC,MAAM,IAAIX,EAAY,sCAGxB,IAAK,MAAOY,EAAWC,KAAgBC,OAAOC,QAAQL,EAAOC,QAAS,CACpE,IAAKE,GAAsC,iBAAhBA,EACzB,MAAM,IAAIb,EAAY,SAASY,qCAGjC,IAAKC,EAAYG,QACf,MAAM,IAAIhB,EAAY,SAASY,yBAIjC,GAAIC,EAAYI,QAAS,CACvB,GAAmC,iBAAxBJ,EAAYI,QACrB,MAAM,IAAIjB,EAAY,qBAAqBY,uBAG7C,IAAK,MAAOM,EAAWC,KAAgBL,OAAOC,QAAQF,EAAYI,SAAU,CAC1E,GAA2B,iBAAhBE,EACT,MAAM,IAAInB,EAAY,SAASkB,cAAsBN,wBAGlDO,EAAYH,SAAYG,EAAYC,MAG1C,CACF,CACF,CACF,CAOD,mBAAOC,CAAaC,EAAIZ,GACtBb,KAAKY,eAAeC,GAGpBb,KAAK0B,qBAAqBD,GAE1B,IAAK,MAAOV,EAAWC,KAAgBC,OAAOC,QAAQL,EAAOC,QAC3D,IAAKW,EAAGE,iBAAiBC,SAASb,GAAY,CAC5C,MAAMc,EAAQJ,EAAGK,kBAAkBf,EAAW,CAC5CI,QAASH,EAAYG,QACrBY,cAAef,EAAYe,gBAAiB,IAG9C,GAAIf,EAAYI,QACd,IAAK,MAAOC,EAAWC,KAAgBL,OAAOC,QAAQF,EAAYI,SAAU,CAC1E,MAAMD,EAAUG,EAAYH,SAAWE,EACvCQ,EAAMG,YAAYX,EAAWF,EAAS,CACpCI,OAAQD,EAAYC,SAAU,GAEjC,CAEJ,CAEJ,CAMD,2BAAOG,CAAqBD,GAC1B,MAAMQ,EAAkB,kBAEnBR,EAAGE,iBAAiBC,SAASK,IAChCR,EAAGK,kBAAkBG,EAAiB,CACpCd,QAAS,MAGd,CAQD,6BAAOe,CAAuBT,EAAIZ,GAGhC,IAAK,MAAME,KAAaE,OAAOkB,KAAKtB,EAAOC,QACzC,IAAKW,EAAGE,iBAAiBC,SAASb,GAChC,OAAO,EAGX,OAAO,CACR,ECtGY,MAAMqB,EAUnB,oBAAaC,CAAQZ,EAAIa,EAAYC,EAAMC,EAAWC,EAAU,IAC9D,MAAMhC,QACJA,EAAU,IAAIiC,YACdA,GAAc,GACZD,EAEJ,OAAO,IAAIE,QAAQ,CAACC,EAASC,KAC3B,MAAMC,EAAcrB,EAAGqB,YAAYR,EAAYC,GAC/C,IAAIQ,EACAC,GAAY,EAGZvC,EAAU,IACZsC,EAAYE,WAAW,KACrB,IAAKD,GAAwC,WAA3BF,EAAYI,WAC5B,IACEJ,EAAYK,QACZN,EAAO,IAAIrC,EAAwBC,GACpC,CAAC,MAAO2C,GAEPP,EAAO,IAAIrC,EAAwBC,GACpC,GAEFA,IAGLqC,EAAYO,QAAU,KACpBL,GAAY,EACRD,GAAWO,aAAaP,GAC5BF,EAAO,IAAIxC,EAAiB,qBAAsByC,EAAYM,SAGhEN,EAAYS,QAAU,KACpBP,GAAY,EACRD,GAAWO,aAAaP,GAGxBD,EAAYM,OAAoC,sBAA3BN,EAAYM,MAAMnD,KACzC4C,EAAO,IAAItC,EAAyB,iDAEpCsC,EAAO,IAAIxC,EAAiB,yBAKhC,MAAMmD,EAAiB,IAAIC,IAELC,OAAOC,IAC3B,IAOE,aALqB3D,KAAK4D,kBAAkBD,EAAKnB,EAAW,CAC1DE,cACAc,iBACAV,eAGH,CAAC,MAAOM,GACP,MAAM,IAAI/C,EAAiB,mBAAoB+C,EAChD,GAIHS,CAAcf,GACXgB,KAAMC,IAELjB,EAAYkB,WAAa,KACvBhB,GAAY,EACRD,GAAWO,aAAaP,GAC5BH,EAAQmB,MAGXE,MAAOb,IACNJ,GAAY,EACRD,GAAWO,aAAaP,GAC5BF,EAAOO,MAGd,CASD,8BAAaQ,CAAkBd,EAAaN,EAAW0B,GACrD,MAAMxB,YAAEA,EAAWc,eAAEA,EAAgBV,YAAaa,GAAQO,EAMpDH,EAASvB,EAHcxC,KAAKmE,2BAA2BrB,EAAaoB,IAM1E,GAAIH,GAAiC,mBAAhBA,EAAOD,KAAqB,CAC/CN,EAAeY,IAAIL,GAEnB,IACE,MAAMM,QAAuBN,EAE7B,OADAP,EAAec,OAAOP,GACfM,CACR,CAAC,MAAOjB,GAEP,MADAI,EAAec,OAAOP,GAChBX,CACP,CACF,CAED,OAAOW,CACR,CAQD,iCAAOI,CAA2BrB,EAAaoB,GAG7C,OAAO,IAAIK,MAAMzB,EAAa,CAC5B0B,IAAG,CAACC,EAAQC,IAEO,gBAAbA,EACM3D,IAEN,GAAI0D,EAAOrB,MACT,MAAM,IAAI/C,EAAiB,gCAAiCoE,EAAOrB,OAIrE,GAAoB,kBAAhBqB,EAAOlC,WAEJ,GAA0B,aAAtBkC,EAAOvB,WAChB,MAAM,IAAI3C,EAAyB,oCAGrC,IACE,MAAMsB,EAAQ4C,EAAOE,YAAY5D,GAEjC,OAAOqB,EAAmBwC,2BAA2B/C,EAAOqC,EAC7D,CAAC,MAAOd,GACP,GAAmB,sBAAfA,EAAMnD,KACR,MAAM,IAAIM,EAAyB,wDAErC,MAAM6C,CACP,GAIEqB,EAAOC,IAGnB,CAQD,iCAAOE,CAA2B/C,EAAOqC,GACvC,MAAMxB,YAAEA,EAAWc,eAAEA,GAAmBU,EAmCxC,OAjCuB,IAAIK,MAAM1C,EAAO,CACtC2C,IAAG,CAACC,EAAQC,IACsB,mBAArBD,EAAOC,GACT,IAAIG,KACT,MAAMd,EAASU,EAAOC,MAAaG,GAGnC,GAAId,GAAiC,mBAAhBA,EAAOD,KAAqB,CAC/C,GAAIpB,GAAec,EAAesB,KAAO,EACvC,MAAM,IAAIzE,EACR,kHAKJmD,EAAeY,IAAIL,GAGnBA,EAAOE,MAAM,KACXT,EAAec,OAAOP,KACrBgB,QAAQ,KACTvB,EAAec,OAAOP,IAEzB,CAED,OAAOA,GAIJU,EAAOC,IAKnB,CAOD,uBAAOM,CAAiBC,GACtB,OAAO,IAAItC,QAAQ,CAACC,EAASC,KAC3BoC,EAAQC,UAAY,IAAMtC,EAAQqC,EAAQlB,QAC1CkB,EAAQ5B,QAAU,KAChB8B,QAAQ/B,MAAM,qBAAsB6B,EAAQ7B,MAAMnD,KAAMgF,EAAQ7B,MAAMvD,SACtEgD,EAAO,IAAIxC,EAAiB,mBAAmB4E,EAAQ7B,MAAMnD,UAAUgF,EAAQ7B,MAAMvD,UAAWoF,EAAQ7B,UAG7G,EC/NY,MAAMgC,EACnBC,uBAAyB,kBAUzB,0BAAaC,CAAc7D,EAAI8D,EAAYC,EAAaC,EAAWnD,EAAa,IAC9E,IAAKiD,GAAcC,GAAeC,EAAW,aAGvCzF,KAAK0F,qBAAqBjE,GAGhC,MAAMkE,QAA4B3F,KAAK4F,uBAAuBnE,GACxDoE,EAAoB7F,KAAK8F,qBAAqBP,EAAYC,EAAaC,EAAWE,GAExF,GAAiC,IAA7BE,EAAkBE,OAAtB,CAKAZ,QAAQa,IAAI,WAAWH,EAAkBE,gCAEzC,IAAK,MAAME,KAAaJ,QAChB7F,KAAKkG,mBAAmBzE,EAAIwE,EAAW3D,GAG/C6C,QAAQa,IAAI,wCARX,MAFCb,QAAQa,IAAI,mCAWf,CAMD,iCAAaN,CAAqBjE,GAC3BA,EAAGE,iBAAiBC,SAAS5B,KAAKiC,kBAGrCkD,QAAQgB,KAAK,oFAEhB,CAOD,mCAAaP,CAAuBnE,GAClC,OAAKA,EAAGE,iBAAiBC,SAAS5B,KAAKiC,iBAIhCG,EAAmBC,QAAQZ,EAAI,CAACzB,KAAKiC,iBAAkB,WAAaa,GAClE,IAAIH,QAASC,IAClB,MACMqC,EADQnC,EAAY6B,YAAY3E,KAAKiC,iBACrBmE,SACtBnB,EAAQC,UAAY,KAClB,MAAMlC,EAAYiC,EAAQlB,OACvBsC,OAAOC,GAAwB,cAAhBA,EAAKC,QACpBC,IAAIF,GAAQA,EAAKG,IACpB7D,EAAQI,IAEViC,EAAQ5B,QAAU,IAAMT,EAAQ,OAb3B,EAgBV,CAUD,2BAAOkD,CAAqBP,EAAYC,EAAaC,EAAWzC,GAC9D,OAAOuC,EACJc,OAAOJ,IACN,MAAMS,EAAUT,EAAUS,SAAWT,EAAUQ,GAC/C,OAAOC,EAAUlB,GAAekB,GAAWjB,IAAczC,EAAU2D,SAASV,EAAUQ,MAEvFG,KAAK,CAACC,EAAGC,KAAOD,EAAEH,SAAWG,EAAEJ,KAAOK,EAAEJ,SAAWI,EAAEL,IACzD,CAQD,+BAAaP,CAAmBzE,EAAIwE,EAAW3D,EAAa,IAC1D,MAAMyE,EAAcd,EAAUQ,GACxBO,EAAYC,KAAKC,MAEvB/B,QAAQa,IAAI,uBAAuBe,KAGnC,MAAMR,QAAevG,KAAKmH,mBAAmB1F,EAAIsF,GACjD,GAAe,gBAAXR,EAEF,OADApB,QAAQa,IAAI,aAAae,+CAClB/G,KAAKoH,gBAAgB3F,EAAIwE,EAAW3D,GACtC,GAAe,cAAXiE,EAAJ,OAMDvG,KAAKqH,mBAAmB5F,EAAIsF,EAAa,cAAe,CAAEC,cAEhE,UAEQhH,KAAKsH,kCAAkC7F,EAAIwE,EAAW3D,GAG5D,MAAMiF,EAAUN,KAAKC,YACflH,KAAKqH,mBAAmB5F,EAAIsF,EAAa,YAAa,CAC1DC,YACAO,UACAC,SAAUD,EAAUP,IAGtB7B,QAAQa,IAAI,aAAae,+BAAyCQ,EAAUP,MAE7E,CAAC,MAAO5D,GAWP,GAVA+B,QAAQ/B,MAAM,aAAa2D,YAAuB3D,SAG5CpD,KAAKqH,mBAAmB5F,EAAIsF,EAAa,SAAU,CACvDC,YACA5D,MAAOA,EAAMvD,QACb4H,MAAOrE,EAAMqE,QAIXxB,EAAUyB,SACZ,IACEvC,QAAQa,IAAI,qCAAqCe,cAC3C/G,KAAK2H,kBAAkBlG,EAAIwE,EAAW3D,SACtCtC,KAAKqH,mBAAmB5F,EAAIsF,EAAa,cAAe,CAC5DC,YACAY,aAAcX,KAAKC,MACnBpH,cAAesD,EAAMvD,UAEvBsF,QAAQa,IAAI,oCAAoCe,IACjD,CAAC,MAAOc,GAOP,MANA1C,QAAQ/B,MAAM,iCAAiC2D,KAAgBc,SACzD7H,KAAKqH,mBAAmB5F,EAAIsF,EAAa,kBAAmB,CAChEC,YACAlH,cAAesD,EAAMvD,QACrBgI,cAAeA,EAAchI,UAEzB,IAAIa,EAAuB,aAAaqG,qCAAgDc,EAC/F,CAGH,MAAM,IAAIzH,EAAe,aAAa2G,WAAsB3D,EAC7D,CApDA,MAFC+B,QAAQa,IAAI,aAAae,sBAuD5B,CAQD,8CAAaO,CAAkC7F,EAAIwE,EAAW3D,EAAa,IACzE,MAAMyE,EAAcd,EAAUQ,GAE9B,GAAIR,EAAU6B,cAAwC,mBAAjB7B,EAAU8B,GAAmB,CAEhE,IAAIC,QAAmBhI,KAAKiI,uBAAuBxG,EAAIsF,IAAgB,EACvE,MAAMmB,EAAYjC,EAAUiC,WAAa,IAEzC,OAAa,CACX,MAAMnE,QAAekC,EAAU8B,GAAGtG,EAAIuG,EAAYE,GAElD,GAAInE,EAAOf,UACT,MAGFgF,EAAajE,EAAOoE,qBACdnI,KAAKoI,uBAAuB3G,EAAIsF,EAAaiB,SAG7C,IAAIrF,QAAQC,GAAWK,WAAWL,EAAS,GAClD,CACP,KAAW,CAGL,MAAMyF,EAAoB/F,EAAWyD,OAAS,EAAIzD,EAAa,CAACtC,KAAKiC,uBAC/DG,EAAmBC,QAAQZ,EAAI4G,EAAmB,YAAcvF,GAC7DmD,EAAU8B,GAAGtG,EAAIqB,GAE3B,CACF,CAQD,4BAAasE,CAAgB3F,EAAIwE,EAAW3D,EAAa,IACvD,MAAMyE,EAAcd,EAAUQ,GACxBuB,QAAmBhI,KAAKiI,uBAAuBxG,EAAIsF,GAEzD,GAAmB,OAAfiB,IAAuB/B,EAAU6B,aAQnC,YAHM9H,KAAKqH,mBAAmB5F,EAAIsF,EAAa,SAAU,CACvD3D,MAAO,gDAEH,IAAIhD,EAAe,aAAa2G,2CAPtC5B,QAAQa,IAAI,sBAAsBe,qBAA+BiB,WAC3DhI,KAAKsH,kCAAkC7F,EAAIwE,EAQpD,CAQD,8BAAa0B,CAAkBlG,EAAIwE,EAAW3D,EAAa,IACzD,MAAMyE,EAAcd,EAAUQ,GAE9B,IAAIR,EAAUyB,SAOZ,MAAM,IAAIhH,EAAuB,+CAA+CqG,KAP1D,CAEtB,MAAMsB,EAAoB/F,EAAWyD,OAAS,EAAIzD,EAAa,CAACtC,KAAKiC,uBAC/DG,EAAmBC,QAAQZ,EAAI4G,EAAmB,YAAcvF,GAC7DmD,EAAUyB,SAASjG,EAAIqB,GAEtC,CAGG,CAQD,+BAAaqE,CAAmB1F,EAAIsF,GAClC,OAAKtF,EAAGE,iBAAiBC,SAAS5B,KAAKiC,iBAIhCG,EAAmBC,QAAQZ,EAAI,CAACzB,KAAKiC,iBAAkB,WAAaa,GAClE,IAAIH,QAASC,IAClB,MACMqC,EADQnC,EAAY6B,YAAY3E,KAAKiC,iBACrBuC,IAAIuC,GAC1B9B,EAAQC,UAAY,KAClBtC,EAAQqC,EAAQlB,OAASkB,EAAQlB,OAAOwC,OAAS,OAEnDtB,EAAQ5B,QAAU,IAAMT,EAAQ,SAV3B,IAaV,CASD,+BAAayE,CAAmB5F,EAAIsF,EAAaR,EAAQ+B,EAAW,CAAA,GAClE,IAAK7G,EAAGE,iBAAiBC,SAAS5B,KAAKiC,iBAErC,UACQjC,KAAK0B,qBAAqBD,EACjC,CAAC,MAAO2B,GAEP,YADA+B,QAAQgB,KAAK,oCAAqC/C,EAEnD,OAGGhB,EAAmBC,QAAQZ,EAAI,CAACzB,KAAKiC,iBAAkB,YAAca,GAClE,IAAIH,QAAQ,CAACC,EAASC,KAC3B,MAAMhB,EAAQiB,EAAY6B,YAAY3E,KAAKiC,iBACrCsG,EAAO,CACX9B,GAAIM,EACJR,SACAiC,UAAWvB,KAAKC,SACboB,GAGCrD,EAAUpD,EAAM4G,IAAIF,GAC1BtD,EAAQC,UAAY,IAAMtC,IAC1BqC,EAAQ5B,QAAU,IAAMR,EAAOoC,EAAQ7B,SAG5C,CAQD,mCAAa6E,CAAuBxG,EAAIsF,GACtC,OAAKtF,EAAGE,iBAAiBC,SAAS5B,KAAKiC,iBAIhCG,EAAmBC,QAAQZ,EAAI,CAACzB,KAAKiC,iBAAkB,WAAaa,GAClE,IAAIH,QAASC,IAClB,MACMqC,EADQnC,EAAY6B,YAAY3E,KAAKiC,iBACrBuC,IAAI,GAAGuC,gBAC7B9B,EAAQC,UAAY,KAClBtC,EAAQqC,EAAQlB,OAASkB,EAAQlB,OAAOiE,WAAa,OAEvD/C,EAAQ5B,QAAU,IAAMT,EAAQ,SAV3B,IAaV,CAQD,mCAAawF,CAAuB3G,EAAIsF,EAAaiB,GAC9CvG,EAAGE,iBAAiBC,SAAS5B,KAAKiC,wBAIjCG,EAAmBC,QAAQZ,EAAI,CAACzB,KAAKiC,iBAAkB,YAAca,GAClE,IAAIH,QAAQ,CAACC,EAASC,KAC3B,MAAMhB,EAAQiB,EAAY6B,YAAY3E,KAAKiC,iBACrCsG,EAAO,CACX9B,GAAI,GAAGM,eACPiB,aACAQ,UAAWvB,KAAKC,OAGZjC,EAAUpD,EAAM4G,IAAIF,GAC1BtD,EAAQC,UAAY,IAAMtC,IAC1BqC,EAAQ5B,QAAU,IAAMR,EAAOoC,EAAQ7B,SAG5C,CAMD,iCAAa1B,CAAqBD,GAG5BA,EAAGiF,QAAU,GACfvB,QAAQgB,KAAK,0DAEhB,ECxWY,MAAMuC,EACnB,WAAA9I,CAAY+I,EAAQjC,EAAS7F,EAAQ0E,EAAa,IAChDvF,KAAK2I,OAASA,EACd3I,KAAK0G,QAAUA,EACf1G,KAAKa,OAASA,EACdb,KAAKuF,WAAaA,EAClBvF,KAAKyB,GAAK,KACVzB,KAAK4I,WAAa,CACnB,CAMD,IAAAC,GACE,OAAO,IAAIlG,QAAQ,CAACC,EAASC,KAC3B,MAAMiG,EAAYC,WAAWD,WAAaE,QAAQF,UAClD,IAAKA,EAEH,YADAjG,EAAO,IAAI3C,EAAgB,4BAI7B,MAAM+E,EAAU6D,EAAUD,KAAK7I,KAAK2I,OAAQ3I,KAAK0G,SAEjDzB,EAAQ5B,QAAU,KAChBR,EAAO,IAAI3C,EAAgB,0BAA2B+E,EAAQ7B,SAGhE6B,EAAQgE,gBAAmBC,IACzBlJ,KAAKyB,GAAKyH,EAAMzE,OAAOV,OACvB/D,KAAK4I,WAAaM,EAAMN,WACxBjI,EAAca,aAAaxB,KAAKyB,GAAIzB,KAAKa,SAG3CoE,EAAQC,UAAYxB,UAElB,GADA1D,KAAKyB,GAAKwD,EAAQlB,OACd/D,KAAK4I,WAAa5I,KAAK0G,QACzB,IAEE,MAAMyC,EAAuBnJ,KAAKoJ,oBAAoBpJ,KAAKuF,YAErDjD,EAAarB,OAAOkB,KAAKnC,KAAKa,OAAOC,QAAU,CAAA,SAC/CsE,EAAiBE,cAActF,KAAKyB,GAAI0H,EAAsBnJ,KAAK4I,WAAY5I,KAAK0G,QAASpE,EACpG,CAAC,MAAOc,GAEP,YADAP,EAAOO,EAER,CAEHR,EAAQ5C,KAAKyB,MAGlB,CAKD,KAAA4H,GACMrJ,KAAKyB,KACPzB,KAAKyB,GAAG4H,QACRrJ,KAAKyB,GAAK,KAEb,CAMD,MAAA6H,GACE,OAAmB,OAAZtJ,KAAKyB,EACb,CAMD,WAAA8H,GACE,OAAOvJ,KAAKyB,EACb,CAOD,mBAAA2H,CAAoB7D,GAClB,OAAKA,GAAeiE,MAAMC,QAAQlE,GAI3BA,EAAWiB,IAAI,CAACP,EAAWyD,IAE5BzD,GAAkC,iBAAdA,GAA0BA,EAAUQ,GACnDR,EAIgB,mBAAdA,EACF,CACLQ,GAAI,aAAaiD,EAAQ,IACzBhD,QAASgD,EAAQ,EACjB3B,GAAI9B,EACJ6B,cAAc,IAKlB3C,QAAQgB,KAAK,8BAA8BuD,KAAUzD,GAC9C,OACNI,OAAOsD,SAtBD,EAuBV,EC/GY,MAAMC,EASnB,kBAAaC,CAAMpI,EAAIV,EAAW+I,EAAU,CAAE,EAAErH,EAAU,IACxD,OAAOL,EAAmBC,QAAQZ,EAAIV,EAAW,WAAY2C,MAAOZ,IAClE,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GAGhCgJ,EAAY/J,KAAKgK,aAAaF,EAASjI,EAAOY,GAEpD,OAAIsH,EAAUE,gBAELjK,KAAKkK,qBAAqBrI,EAAOkI,EAAUE,gBAAiBF,GAC1DA,EAAUI,YAEZnK,KAAKoK,kBAAkBvI,EAAOkI,GAG9B/J,KAAKqK,qBAAqBxI,EAAOiI,EAASC,IAGtD,CAUD,6BAAaO,CAAiB7I,EAAIV,EAAW+I,EAAU,CAAE,EAAErH,EAAU,IACnE,OAAOL,EAAmBC,QAAQZ,EAAIV,EAAW,WAAY2C,MAAOZ,IAClE,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GACtC,OAAOf,KAAKgK,aAAaF,EAASjI,EAAOY,IAE5C,CASD,mBAAOuH,CAAaF,EAASjI,EAAOY,GAClC,MAAM8H,EAAO,CACXJ,aAAa,EACb9I,UAAW,KACXmJ,SAAU,KACVC,YAAa,CAAE,EACfR,gBAAiB,KACjBS,UAAWjI,EAAQmE,KACnB+D,MAAOlI,EAAQkI,MACfC,OAAQnI,EAAQmI,QAAU,EAC1BC,cAAe,EACfC,kBAAmB,IAIrB,GAAoC,IAAhC7J,OAAOkB,KAAK2H,GAAS/D,OAGvB,OAFAwE,EAAKM,cAAgB7K,KAAK+K,qBAAqBlJ,GAC/C0I,EAAKO,kBAAkBE,KAAK,yCACrBT,EAIT,GAAIT,EAAQmB,MAAQnB,EAAQoB,IAM1B,OALAX,EAAKN,gBAAkBH,EACvBS,EAAKM,cAAgB7K,KAAK+K,qBAAqBlJ,GAC/C0I,EAAKO,kBAAkBE,KAAK,qCAGrBT,EAIT,IAAK,MAAOY,EAAOC,KAAUnK,OAAOC,QAAQ4I,GAAU,CACpD,MAAMzI,EAAYrB,KAAKqL,kBAAkBxJ,EAAOsJ,GAE5C9J,GAAarB,KAAKsL,qBAAqBF,IAEzCb,EAAKJ,aAAc,EACnBI,EAAKlJ,UAAYA,EACjBkJ,EAAKC,SAAWxK,KAAKuL,eAAeH,GACpCb,EAAKM,cAAgB7K,KAAKwL,uBAAuB3J,EAAOR,EAAW+J,GACnEb,EAAKO,kBAAkBE,KAAK,gBAAgB3J,iBAAyB8J,QAGrEZ,EAAKE,YAAYU,GAASC,EACrBb,EAAKJ,YAIRI,EAAKO,kBAAkBE,KAAK,sCAAsCG,OAHlEZ,EAAKM,cAAgB7K,KAAK+K,qBAAqBlJ,GAC/C0I,EAAKO,kBAAkBE,KAAK,6CAA6CG,OAK9E,CAED,OAAOZ,CACR,CAOD,2BAAOQ,CAAqBlJ,GAG1B,OAAO,GACR,CASD,6BAAO2J,CAAuB3J,EAAOR,EAAWoK,GAE9C,GAA2B,iBAAhBA,GAA4C,OAAhBA,EAAsB,CAE3D,MAAMC,EAAKzK,OAAOkB,KAAKsJ,GAAa,GACpC,GAAI,CAAC,MAAO,OAAQ,MAAO,QAAQ9E,SAAS+E,GAC1C,OAAO,EAEV,CACD,OAAO,CACR,CAQD,wBAAOL,CAAkBxJ,EAAOsJ,GAE9B,GAAItJ,EAAMV,UAAYgK,EACpB,OAAO,KAIT,IAAK,MAAM9J,KAAaQ,EAAM8J,WAAY,CAExC,GADc9J,EAAM6H,MAAMrI,GAChBF,UAAYgK,EACpB,OAAO9J,CAEV,CAED,OAAO,IACR,CAOD,2BAAOiK,CAAqBF,GAC1B,GAAqB,iBAAVA,GAAgC,OAAVA,EAAgB,CAE/C,MAAMQ,EAAY3K,OAAOkB,KAAKiJ,GAC9B,OAA4B,IAArBQ,EAAU7F,QAAgB,CAAC,MAAO,OAAQ,MAAO,OAAQ,OAAOY,SAASiF,EAAU,GAC3F,CAGD,OAAO,CACR,CAOD,qBAAOL,CAAeH,GACpB,GAAqB,iBAAVA,GAAgC,OAAVA,EAmB/B,OAAOS,YAAYC,KAAKV,GAnBuB,CAC/C,MAAOM,EAAIK,GAAO9K,OAAOC,QAAQkK,GAAO,GAExC,OAAQM,GACN,IAAK,MACH,OAAOG,YAAYG,WAAWD,GAAK,GACrC,IAAK,OACH,OAAOF,YAAYG,WAAWD,GAChC,IAAK,MACH,OAAOF,YAAYI,WAAWF,GAAK,GACrC,IAAK,OACH,OAAOF,YAAYI,WAAWF,GAChC,IAAK,MACH,OAAOF,YAAYC,KAAKC,GAC1B,QACE,OAAO,KAEjB,CAIG,CAQD,8BAAa3B,CAAkBvI,EAAO0I,GACpC,MAAM2B,QAAgB,IAAIvJ,QAAQ,CAACC,EAASC,KAC1C,MAAMsJ,EAAc,GACpB,IAAIC,EAAU,EAEd,MACMnH,EADQpD,EAAM6H,MAAMa,EAAKlJ,WACTgL,WAAW9B,EAAKC,UAEtCvF,EAAQC,UAAagE,IACnB,MAAMoD,EAASpD,EAAMzE,OAAOV,OAExBuI,IAE2C,IAAzCrL,OAAOkB,KAAKoI,EAAKE,aAAa1E,QAC9B/F,KAAKuM,eAAeD,EAAOlB,MAAOb,EAAKE,gBAGrC2B,EAAU7B,EAAKK,OACjBwB,IAEAD,EAAYnB,KAAKsB,EAAOlB,QAO5BkB,EAAOE,YAEP5J,EAAQuJ,IAIZlH,EAAQ5B,QAAU,IAAMR,EAAOoC,EAAQ7B,SAIzC,OAAOpD,KAAKyM,0BAA0BP,EAAS3B,EAChD,CASD,iCAAaL,CAAqBrI,EAAOoI,EAAiBM,EAAO,CAAA,GAC/D,MAAM2B,QAAgB,IAAIvJ,QAAQ,CAACC,EAASC,KAC1C,MAAMsJ,EAAc,GACdlH,EAAUpD,EAAMwK,aAEtBpH,EAAQC,UAAagE,IACnB,MAAMoD,EAASpD,EAAMzE,OAAOV,OAExBuI,GACEtM,KAAK0M,uBAAuBJ,EAAOlB,MAAOnB,IAC5CkC,EAAYnB,KAAKsB,EAAOlB,OAE1BkB,EAAOE,YAEP5J,EAAQuJ,IAIZlH,EAAQ5B,QAAU,IAAMR,EAAOoC,EAAQ7B,SAIzC,OAAOpD,KAAKyM,0BAA0BP,EAAS3B,EAChD,CASD,iCAAaF,CAAqBxI,EAAOiI,EAASS,EAAO,CAAA,GACvD,MAAM2B,QAAgB,IAAIvJ,QAAQ,CAACC,EAASC,KAC1C,MAAMsJ,EAAc,GACdlH,EAAUpD,EAAMwK,aAEtBpH,EAAQC,UAAagE,IACnB,MAAMoD,EAASpD,EAAMzE,OAAOV,OAExBuI,GACEtM,KAAKuM,eAAeD,EAAOlB,MAAOtB,IACpCqC,EAAYnB,KAAKsB,EAAOlB,OAE1BkB,EAAOE,YAEP5J,EAAQuJ,IAIZlH,EAAQ5B,QAAU,IAAMR,EAAOoC,EAAQ7B,SAIzC,OAAOpD,KAAKyM,0BAA0BP,EAAS3B,EAChD,CAQD,gCAAOkC,CAA0BP,EAAS3B,GACxC,IAAIoC,EAAmB,IAAIT,GAG3B,GAAI3B,EAAKG,UAAW,CAClB,MAAOS,EAAOyB,GAAa3L,OAAOC,QAAQqJ,EAAKG,WAAW,GAC1DiC,EAAiB/F,KAAK,CAACC,EAAGC,KACxB,MAAM+F,EAAOhG,EAAEsE,GACT2B,EAAOhG,EAAEqE,GAEf,OAAI0B,EAAOC,EAA2B,IAAdF,GAAmB,EAAI,EAC3CC,EAAOC,EAA2B,IAAdF,EAAkB,GAAK,EACxC,GAEV,CAWD,OARIrC,EAAKK,OAAS,IAChB+B,EAAmBA,EAAiBI,MAAMxC,EAAKK,SAG7CL,EAAKI,MAAQ,IACfgC,EAAmBA,EAAiBI,MAAM,EAAGxC,EAAKI,QAG7CgC,CACR,CAQD,6BAAOD,CAAuBM,EAAQ/C,GACpC,OAAIA,EAAgBgB,KAEXhB,EAAgBgB,KAAKgC,MAAMC,GAChClN,KAAKuM,eAAeS,EAAQ,CAAE,CAAC/L,OAAOkB,KAAK+K,GAAW,IAAKjM,OAAOkM,OAAOD,GAAW,MAE7EjD,EAAgBiB,IAElBjB,EAAgBiB,IAAIkC,KAAKF,GAC9BlN,KAAKuM,eAAeS,EAAQ,CAAE,CAAC/L,OAAOkB,KAAK+K,GAAW,IAAKjM,OAAOkM,OAAOD,GAAW,MAKjFlN,KAAKuM,eAAeS,EAAQ/C,EACpC,CAQD,qBAAOsC,CAAeS,EAAQlD,GAC5B,IAAK,MAAOuD,EAAKjC,KAAUnK,OAAOC,QAAQ4I,GACxC,GAAY,SAARuD,GAA0B,QAARA,GAEpB,IAAKrN,KAAK0M,uBAAuBM,EAAQ,CAAEK,CAACA,GAAMjC,IAChD,OAAO,OAEJ,GAAqB,iBAAVA,GAAgC,OAAVA,GAEtC,IAAKpL,KAAKsN,iBAAiBN,EAAOK,GAAMjC,GACtC,OAAO,OAIT,GAAI4B,EAAOK,KAASjC,EAClB,OAAO,EAIb,OAAO,CACR,CAQD,uBAAOkC,CAAiBC,EAAYC,GAClC,MAAO9B,EAAIN,GAASnK,OAAOC,QAAQsM,GAAU,GAE7C,OAAQ9B,GACN,IAAK,MACH,OAAO6B,EAAanC,EACtB,IAAK,OACH,OAAOmC,GAAcnC,EACvB,IAAK,MACH,OAAOmC,EAAanC,EACtB,IAAK,OACH,OAAOmC,GAAcnC,EACvB,IAAK,MACH,OAAOmC,IAAenC,EACxB,IAAK,MACH,OAAOmC,IAAenC,EACxB,IAAK,SACH,OAAO,IAAIqC,OAAOrC,GAAOsC,KAAKH,GAChC,QACE,OAAO,EAEZ,EC9aY,MAAMI,EAMnB,0BAAOC,CAAoBC,GACzB,GAAIA,QAAmC,OAAO,EAG9C,GAAmB,iBAARA,EACT,MAAmB,iBAARA,EAAsC,EAAbA,EAAI9H,OACrB,kBAAR8H,EAA0B,EAClB,iBAARA,EAAyB,EAC7B,EAIT,GAAIrE,MAAMC,QAAQoE,GAAM,CACtB,IAAI/I,EAAO,EACX,IAAK,MAAMgJ,KAAQD,EACjB/I,GAAQ9E,KAAK4N,oBAAoBE,GAEnC,OAAOhJ,EAAqB,EAAb+I,EAAI9H,MACpB,CAID,MAAMgI,EAAU,IAAIC,QAEdC,EAAiBC,IACrB,GAAIA,QAA+B,OAAO,EAC1C,GAAiB,iBAANA,EAAgB,OAAOlO,KAAK4N,oBAAoBM,GAG3D,GAAIH,EAAQI,IAAID,GAAI,OAAO,EAC3BH,EAAQ3J,IAAI8J,GAEZ,IAAIE,EAAU,EAEd,GAAI5E,MAAMC,QAAQyE,GAAI,CACpB,IAAK,MAAMJ,KAAQI,EACjBE,GAAWH,EAAcH,GAE3BM,GAAsB,EAAXF,EAAEnI,MACrB,KAAa,CACL,IAAK,MAAMsH,KAAOa,EACZA,EAAEG,eAAehB,KACnBe,GAAwB,EAAbf,EAAItH,OACfqI,GAAWH,EAAcC,EAAEb,KAG/Be,GAAmC,GAAxBnN,OAAOkB,KAAK+L,GAAGnI,MAC3B,CAED,OAAOqI,GAGT,OAAOH,EAAcJ,EACtB,CAOD,gCAAOS,CAA0BT,GAC/B,MAAM7G,EAAYuH,YAAYrH,MACxBpC,EAAO9E,KAAK4N,oBAAoBC,GAEtC,IAEE,MAAMW,EAASC,gBAAgBZ,GAG/B,MAAO,CACL/I,OACA4J,UAJcH,YAAYrH,MAILF,EACrB2H,SAAS,EACTH,SAEH,CAAC,MAAOpL,GAGP,MAAO,CACL0B,OACA4J,UAJcH,YAAYrH,MAILF,EACrB2H,SAAS,EACTvL,MAAOA,EAAMvD,QAEhB,CACF,CAOD,wBAAO+O,CAAkB9J,GACvB,MAAM+J,EAAa,CACjBC,MAAO,KACPC,OAAQ,QACRC,MAAO,SACPC,KAAM,UAGR,IAAIC,EAAQ,QACRC,EAAU,KACVC,EAAiB,KAerB,OAbItK,GAAQ+J,EAAWI,MACrBC,EAAQ,OACRC,EAAU,sDACVC,EAAiB,mEACRtK,GAAQ+J,EAAWG,OAC5BE,EAAQ,QACRC,EAAU,sCACVC,EAAiB,0DACRtK,GAAQ+J,EAAWE,SAC5BG,EAAQ,SACRC,EAAU,6CAGL,CACLD,QACApK,OACAuK,OAAQC,KAAKC,MAAMzK,EAAO,MAC1B0K,OAAQF,KAAKC,MAAMzK,EAAI,QAAmB,KAAO,IACjDqK,UACAC,iBACAP,aAEH,CAQD,4BAAOY,CAAsBjN,EAAWqL,EAAK6B,EAAU,CAAA,GACrD,MAAMC,EAAU3P,KAAKsO,0BAA0BT,GACzC+B,EAAa5P,KAAK4O,kBAAkBe,EAAQ7K,MAElD,GAAI8K,EAAWT,QAAS,CACtB,MAAMtP,EAAU,yBAAyB2C,MAAcoN,EAAWT,0BACxDS,EAAWJ,aAAaI,EAAWP,sBACzCO,EAAWR,gBAAkB,wBACpBS,KAAKC,UAAUJ,KAK5B,GAHAvK,QAAQgB,KAAKtG,GAGY,SAArB+P,EAAWV,OAA6C,gBAAzBa,QAAQC,IAAIC,SAC7C,MAAM,IAAItQ,MAAM,0BAA0BE,IAE7C,CAED,MAAO,CACL8P,UACAC,aACAM,SAAUN,EAAWT,QAExB,CAQD,+BAAagB,CAAmB3N,EAAW4N,GACzC,MAAMpJ,EAAYuH,YAAYrH,MAE9B,IACE,MAAMnD,QAAeqM,IAGfT,EAAU,CACdnN,YACAgF,SAJc+G,YAAYrH,MAINF,EACpB2H,SAAS,EACTnG,UAAWvB,KAAKC,OAQlB,OAJIyI,EAAQnI,SAAW,KACrBrC,QAAQgB,KAAK,sBAAsB3D,UAAkBmN,EAAQnI,SAAS6I,QAAQ,QAGzE,CACLtM,SACA4L,UAGH,CAAC,MAAOvM,GACP,MAEMuM,EAAU,CACdnN,YACAgF,SAJc+G,YAAYrH,MAINF,EACpB2H,SAAS,EACTvL,MAAOA,EAAMvD,QACb2I,UAAWvB,KAAKC,OAKlB,MAFA/B,QAAQ/B,MAAM,uBAAuBZ,kBAA0BmN,EAAQnI,SAAS6I,QAAQ,QAASjN,GAE3FA,CACP,CACF,CAQD,8BAAOkN,CAAwBC,EAAItQ,GACjC,OAAOyD,SAAUmB,KACf,MAAMmC,EAAYuH,YAAYrH,MAE9B,IAEE,IAAK,IAAIsJ,EAAI,EAAGA,EAAI3L,EAAKkB,OAAQyK,IAAK,CACpC,MAAMC,EAAM5L,EAAK2L,GACbC,GAAsB,iBAARA,GAChBzQ,KAAKyP,sBAAsB,GAAGxP,QAAWuQ,KAAMC,EAAK,CAAEC,SAAUF,GAEnE,CAED,MAAMzM,QAAewM,EAAGI,MAAM3Q,KAAM6E,GAI9B2C,EAHU+G,YAAYrH,MAGDF,EAK3B,OAJIQ,EAAW,IACbrC,QAAQgB,KAAK,oBAAoBlG,UAAauH,EAAS6I,QAAQ,QAG1DtM,CAER,CAAC,MAAOX,GACP,MACMoE,EADU+G,YAAYrH,MACDF,EAG3B,MADA7B,QAAQ/B,MAAM,qBAAqBnD,kBAAqBuH,EAAS6I,QAAQ,QAASjN,GAC5EA,CACP,EAEJ,CAMD,0BAAOwN,GAEL,MAAO,CACLpI,UAAWvB,KAAKC,MAChB2J,YAAsC,IAAvBtC,YAAYsC,OAAyB,CAClDC,KAAMvC,YAAYsC,OAAOE,eACzBC,MAAOzC,YAAYsC,OAAOI,gBAC1BtG,MAAO4D,YAAYsC,OAAOK,iBACxB,KACJC,OAAQ5C,YAAY4C,OAAS,CAC3BC,gBAAiB7C,YAAY4C,OAAOC,gBACpCC,aAAc9C,YAAY4C,OAAOE,aACjCC,iBAAkB/C,YAAY4C,OAAOI,yBAA2BhD,YAAY4C,OAAOC,iBACjF,KAEP,ECzQY,MAAMI,EACnB,WAAA5R,CAAY+I,EAAQjC,EAAS7F,EAAQ0E,EAAa,IAEhD5E,EAAcC,eAAeC,GAE7Bb,KAAK2I,OAASA,EACd3I,KAAK0G,QAAUA,EACf1G,KAAKa,OAASA,EACdb,KAAKuF,WAAaA,EAElBvF,KAAKyR,kBAAoB,IAAI/I,EAAkBC,EAAQjC,EAAS7F,EAAQ0E,EACzE,CAMD,UAAMsD,GACJ,OAAO7I,KAAKyR,kBAAkB5I,MAC/B,CAKD,KAAAQ,GACErJ,KAAKyR,kBAAkBpI,OACxB,CAMD,MAAAC,GACE,OAAOtJ,KAAKyR,kBAAkBnI,QAC/B,CAMD,WAAAC,GACE,OAAOvJ,KAAKyR,kBAAkBlI,aAC/B,CAQD,YAAMmI,CAAO3Q,EAAWwH,GACtB,MAAM9G,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAKzB,OAFAgO,EAAiB8B,sBAAsB,oBAAqBlH,EAAM,CAAExH,cAE7D4M,EAAiBwC,mBAAmB,UAAUpP,KAAc,IACjEqB,EAAmBC,QAAQZ,EAAIV,EAAW,YAAc+B,IACtD,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GACtC,OAAOqB,EAAmB4C,iBAAiBnD,EAAMuC,IAAImE,OAEvDzE,KAAKC,GAAUA,EAAOA,OACzB,CAQD,UAAM4N,CAAK5Q,EAAWsM,GACpB,MAAM5L,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAEzB,OAAOyC,EAAmBC,QAAQZ,EAAIV,EAAW,WAAa+B,IAC5D,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GACtC,OAAOqB,EAAmB4C,iBAAiBnD,EAAM2C,IAAI6I,KAExD,CASD,YAAMuE,CAAO7Q,EAAWsM,EAAK9E,GAC3B,MAAM9G,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAKzB,OAFAgO,EAAiB8B,sBAAsB,oBAAqBlH,EAAM,CAAExH,YAAWsM,QAExEM,EAAiBwC,mBAAmB,UAAUpP,KAAc,IACjEqB,EAAmBC,QAAQZ,EAAIV,EAAW,YAAc+B,IACtD,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GAEtC,OAAO,IAAI4B,QAAQ,CAACC,EAASC,KAC3B,MAAMgP,EAAahQ,EAAM2C,IAAI6I,GAC7BwE,EAAW3M,UAAY,KACrB,MAAM4M,EAAWD,EAAW9N,OAC5B,IAAK+N,EAEH,YADAjP,EAAO,IAAIlD,MAAM,qBAGnB,MAAMoS,EAAc,IAAKD,KAAavJ,GAChCyJ,EAAanQ,EAAM4G,IAAIsJ,GAC7BC,EAAW9M,UAAY,IAAMtC,IAC7BoP,EAAW3O,QAAU,IAAMR,EAAO,IAAIxC,iBAAiB,aAAc2R,EAAW5O,SAElFyO,EAAWxO,QAAU,IAAMR,EAAO,IAAIxC,iBAAiB,aAAcwR,EAAWzO,aAGpFU,KAAKC,GAAUA,EAAOA,OACzB,CAQD,YAAM,CAAOhD,EAAWsM,GACtB,MAAM5L,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAEzB,OAAOyC,EAAmBC,QAAQZ,EAAIV,EAAW,YAAc+B,IAC7D,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GACtC,OAAOqB,EAAmB4C,iBAAiBnD,EAAMyC,OAAO+I,KAE3D,CASD,WAAMxD,CAAM9I,EAAW+I,EAAU,CAAA,EAAIrH,EAAU,CAAA,GAC7C,MAAMhB,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAEzB,OAAOgO,EAAiBwC,mBAAmB,SAASpP,KAAc,IAChE6I,EAAYC,MAAMpI,EAAIV,EAAW+I,EAASrH,IAC1CqB,KAAKC,GAAUA,EAAOA,OACzB,CASD,kBAAMiG,CAAajJ,EAAW+I,EAAU,CAAA,EAAIrH,EAAU,CAAA,GACpD,MAAMhB,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAEzB,OAAOiK,EAAYU,iBAAiB7I,EAAIV,EAAW+I,EAASrH,EAC7D,CAQD,UAAMwP,CAAKlR,EAAWmR,GACpB,MAAMzQ,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAGzB,MAAMwS,EAAYD,EAAWE,OAAO,CAACtN,EAAM4G,IAClC5G,EAAO6I,EAAiBC,oBAAoBlC,EAAGnD,MAAQ,CAAA,GAC7D,GAOH,OALAoF,EAAiB8B,sBAAsB,kBAAmB,CAAEyC,aAAYC,aAAa,CACnFpR,YACAsR,eAAgBH,EAAWnM,SAGtB4H,EAAiBwC,mBAAmB,QAAQpP,MAAcmR,EAAWnM,cAAe,IACzF3D,EAAmBC,QAAQZ,EAAIV,EAAW,YAAc+B,IACtD,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GAEhCuR,EAAWJ,EAAW1L,IAAIkF,IAC9B,OAAQA,EAAG6G,MACT,IAAK,SACH,OAAOnQ,EAAmB4C,iBAAiBnD,EAAMuC,IAAIsH,EAAGnD,OAC1D,IAAK,SACH,OAAOnG,EAAmB4C,iBAAiBnD,EAAM4G,IAAIiD,EAAGnD,KAAMmD,EAAGjF,KACnE,IAAK,SACH,OAAOrE,EAAmB4C,iBAAiBnD,EAAMyC,OAAOoH,EAAGjF,KAC7D,QACE,MAAM,IAAI9G,MAAM,2BAA2B+L,EAAG6G,WAIpD,OAAO5P,QAAQ6P,IAAIF,MAErBxO,KAAKC,GAAUA,EAAOA,OACzB,CAUD,qBAAM0O,CAAgBnQ,EAAYC,EAAMmQ,EAAUjQ,EAAU,CAAA,GAC1D,MAAMhB,EAAKzB,KAAKuJ,cAChB,IAAK9H,EAAI,MAAM,IAAI9B,MAAM,qBAEzB,MAAMgT,EAAqB,CACzBlS,QAASgC,EAAQhC,SAAW,IAC5BiC,aAAqC,IAAxBD,EAAQC,eAClBD,GAGL,OAAOL,EAAmBC,QAAQZ,EAAIa,EAAYC,EAAMmQ,EAAUC,EACnE,CASD,cAAMC,CAAS7R,EAAWmR,EAAYzP,EAAU,CAAA,GAC9C,OAAOzC,KAAKyS,gBAAgB1R,EAAW,YAAa2C,MAAOZ,IACzD,MAAMjB,EAAQiB,EAAY6B,YAAY5D,GAChCmL,EAAU,GAEhB,IAAK,MAAMR,KAAMwG,EAAY,CAC3B,IAAInO,EACJ,OAAQ2H,EAAG6G,MACT,IAAK,SACHxO,QAAe3B,EAAmB4C,iBAAiBnD,EAAMuC,IAAIsH,EAAGnD,OAChE,MACF,IAAK,SACHxE,QAAe3B,EAAmB4C,iBAAiBnD,EAAM4G,IAAIiD,EAAGnD,KAAMmD,EAAGjF,KACzE,MACF,IAAK,SACH1C,QAAe3B,EAAmB4C,iBAAiBnD,EAAMyC,OAAOoH,EAAGjF,KACnE,MACF,QACE,MAAM,IAAI9G,MAAM,2BAA2B+L,EAAG6G,QAElDrG,EAAQlB,KAAKjH,EACd,CAED,OAAOmI,GACNzJ,EACJ"}