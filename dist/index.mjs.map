{"version":3,"file":"index.mjs","sources":["../src/ErrorHandler.js","../src/SchemaManager.js","../src/TransactionManager.js","../src/MigrationManager.js","../src/ConnectionManager.js","../src/QueryEngine.js","../src/PerformanceUtils.js","../src/TabCoordinator.js","../src/IDBWrapper.js"],"sourcesContent":["/**\r\n * Base error class for IndexedDB operations\r\n */\r\nexport class IDBError extends Error {\r\n  constructor(message, originalError = null) {\r\n    super(message);\r\n    this.name = 'IDBError';\r\n    this.originalError = originalError;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when database connection fails\r\n */\r\nexport class ConnectionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'ConnectionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when schema validation fails\r\n */\r\nexport class SchemaError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'SchemaError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration fails\r\n */\r\nexport class MigrationError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction fails\r\n */\r\nexport class TransactionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionError';\r\n    this.code = 'ERR_TRANSACTION_FAILED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction becomes inactive\r\n */\r\nexport class TransactionInactiveError extends TransactionError {\r\n  constructor(message = 'Transaction became inactive', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionInactiveError';\r\n    this.code = 'ERR_TRANSACTION_INACTIVE';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction times out\r\n */\r\nexport class TransactionTimeoutError extends TransactionError {\r\n  constructor(timeout, originalError = null) {\r\n    super(`Transaction timeout after ${timeout}ms`, originalError);\r\n    this.name = 'TransactionTimeoutError';\r\n    this.code = 'ERR_TRANSACTION_TIMEOUT';\r\n    this.timeout = timeout;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when storage quota is exceeded\r\n */\r\nexport class QuotaExceededError extends IDBError {\r\n  constructor(message = 'Storage quota exceeded', originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'QuotaExceededError';\r\n    this.code = 'ERR_QUOTA_EXCEEDED';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration rollback fails\r\n */\r\nexport class MigrationRollbackError extends MigrationError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationRollbackError';\r\n    this.code = 'ERR_MIGRATION_ROLLBACK_FAILED';\r\n  }\r\n}","import { SchemaError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages schema validation and object store creation\r\n */\r\nexport default class SchemaManager {\r\n  /**\r\n   * Validates the schema structure\r\n   * @param {Object} schema - The schema definition\r\n   * @throws {SchemaError} If schema is invalid\r\n   */\r\n  static validateSchema(schema) {\r\n    if (!schema || typeof schema !== 'object') {\r\n      throw new SchemaError('Schema must be an object');\r\n    }\r\n\r\n    if (!schema.stores || typeof schema.stores !== 'object') {\r\n      throw new SchemaError('Schema must have a stores property');\r\n    }\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!storeConfig || typeof storeConfig !== 'object') {\r\n        throw new SchemaError(`Store ${storeName} configuration must be an object`);\r\n      }\r\n\r\n      if (!storeConfig.keyPath) {\r\n        throw new SchemaError(`Store ${storeName} must have a keyPath`);\r\n      }\r\n\r\n      // Validate indexes\r\n      if (storeConfig.indexes) {\r\n        if (typeof storeConfig.indexes !== 'object') {\r\n          throw new SchemaError(`Indexes for store ${storeName} must be an object`);\r\n        }\r\n\r\n        for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n          if (typeof indexConfig !== 'object') {\r\n            throw new SchemaError(`Index ${indexName} in store ${storeName} must be an object`);\r\n          }\r\n\r\n          if (!indexConfig.keyPath && !indexConfig.unique) {\r\n            // Allow minimal config, but warn if no keyPath\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates object stores and indexes in the database\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The schema definition\r\n   */\r\n  static createSchema(db, schema) {\r\n    this.validateSchema(schema);\r\n\r\n    // Create migration metadata store first\r\n    this.createMigrationStore(db);\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        const store = db.createObjectStore(storeName, {\r\n          keyPath: storeConfig.keyPath,\r\n          autoIncrement: storeConfig.autoIncrement || false\r\n        });\r\n\r\n        if (storeConfig.indexes) {\r\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n            const keyPath = indexConfig.keyPath || indexName;\r\n            store.createIndex(indexName, keyPath, {\r\n              unique: indexConfig.unique || false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates the migration metadata store\r\n   * @param {IDBDatabase} db - The database instance\r\n   */\r\n  static createMigrationStore(db) {\r\n    const MIGRATION_STORE = '_migration_meta';\r\n\r\n    if (!db.objectStoreNames.contains(MIGRATION_STORE)) {\r\n      db.createObjectStore(MIGRATION_STORE, {\r\n        keyPath: 'id'\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the existing schema matches the expected schema\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The expected schema\r\n   * @returns {boolean} True if schema matches\r\n   */\r\n  static checkSchemaConsistency(db, schema) {\r\n    // This would be more complex in a real implementation\r\n    // For now, just check if stores exist\r\n    for (const storeName of Object.keys(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}","import { TransactionError, TransactionInactiveError, TransactionTimeoutError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages IndexedDB transactions\r\n */\r\nexport default class TransactionManager {\r\n  /**\r\n   * Executes an operation within a transaction with safety checks\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} operation - Function that receives the transaction and performs operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the operation\r\n   */\r\n  static async execute(db, storeNames, mode, operation, options = {}) {\r\n    const {\r\n      timeout = 5000, // 5 second default timeout\r\n      strictAsync = true // Enforce no external async operations\r\n    } = options;\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(storeNames, mode);\r\n      let timeoutId;\r\n      let completed = false;\r\n\r\n      // Set transaction timeout\r\n      if (timeout > 0) {\r\n        timeoutId = setTimeout(() => {\r\n          if (!completed && transaction.readyState === 'active') {\r\n            try {\r\n              transaction.abort();\r\n              reject(new TransactionTimeoutError(timeout));\r\n            } catch (error) {\r\n              // Transaction might already be finished\r\n              reject(new TransactionTimeoutError(timeout));\r\n            }\r\n          }\r\n        }, timeout);\r\n      }\r\n\r\n      transaction.onerror = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        reject(new TransactionError('Transaction failed', transaction.error));\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        completed = true;\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n\r\n        // Check if this was due to transaction becoming inactive\r\n        if (transaction.error && transaction.error.name === 'InvalidStateError') {\r\n          reject(new TransactionInactiveError('Transaction became inactive during operation'));\r\n        } else {\r\n          reject(new TransactionError('Transaction aborted'));\r\n        }\r\n      };\r\n\r\n      // Track async operations to prevent transaction invalidation\r\n      const activePromises = new Set();\r\n\r\n      const safeOperation = async (txn) => {\r\n        try {\r\n          // Wrap the operation to monitor async behavior\r\n          const result = await this.executeWithSafety(txn, operation, {\r\n            strictAsync,\r\n            activePromises,\r\n            transaction\r\n          });\r\n          return result;\r\n        } catch (error) {\r\n          throw new TransactionError('Operation failed', error);\r\n        }\r\n      };\r\n\r\n      // Execute the operation\r\n      safeOperation(transaction)\r\n        .then((result) => {\r\n          // Wait for transaction completion\r\n          transaction.oncomplete = () => {\r\n            completed = true;\r\n            if (timeoutId) clearTimeout(timeoutId);\r\n            resolve(result);\r\n          };\r\n        })\r\n        .catch((error) => {\r\n          completed = true;\r\n          if (timeoutId) clearTimeout(timeoutId);\r\n          reject(error);\r\n        });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes operation with safety monitoring\r\n   * @param {IDBTransaction} transaction - The transaction\r\n   * @param {Function} operation - The operation to execute\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Promise} Operation result\r\n   */\r\n  static async executeWithSafety(transaction, operation, safety) {\r\n    const { strictAsync, activePromises, transaction: txn } = safety;\r\n\r\n    // Create a proxy to monitor transaction access\r\n    const monitoredTransaction = this.createMonitoredTransaction(transaction, safety);\r\n\r\n    // Execute the operation\r\n    const result = operation(monitoredTransaction);\r\n\r\n    // If result is a promise, monitor it\r\n    if (result && typeof result.then === 'function') {\r\n      activePromises.add(result);\r\n\r\n      try {\r\n        const resolvedResult = await result;\r\n        activePromises.delete(result);\r\n        return resolvedResult;\r\n      } catch (error) {\r\n        activePromises.delete(result);\r\n        throw error;\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored transaction proxy\r\n   * @param {IDBTransaction} transaction - Original transaction\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored transaction\r\n   */\r\n  static createMonitoredTransaction(transaction, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    return new Proxy(transaction, {\r\n      get(target, property) {\r\n        // Monitor transaction state\r\n        if (property === 'objectStore') {\r\n          return (storeName) => {\r\n            // Check if transaction is still active\r\n            if (target.error) {\r\n              throw new TransactionError('Transaction is in error state', target.error);\r\n            }\r\n\r\n            // Check if transaction is still active (not aborted or completed)\r\n            if (target.mode === 'versionchange') {\r\n              // Version change transactions are special\r\n            } else if (target.readyState === 'finished') {\r\n              throw new TransactionInactiveError('Transaction has already finished');\r\n            }\r\n\r\n            try {\r\n              const store = target.objectStore(storeName);\r\n              // Return monitored object store\r\n              return TransactionManager.createMonitoredObjectStore(store, safety);\r\n            } catch (error) {\r\n              if (error.name === 'InvalidStateError') {\r\n                throw new TransactionInactiveError('Cannot access object store - transaction is inactive');\r\n              }\r\n              throw error;\r\n            }\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a monitored object store proxy\r\n   * @param {IDBObjectStore} store - Original object store\r\n   * @param {Object} safety - Safety monitoring options\r\n   * @returns {Proxy} Monitored object store\r\n   */\r\n  static createMonitoredObjectStore(store, safety) {\r\n    const { strictAsync, activePromises } = safety;\r\n\r\n    const monitoredStore = new Proxy(store, {\r\n      get(target, property) {\r\n        if (typeof target[property] === 'function') {\r\n          return (...args) => {\r\n            const result = target[property](...args);\r\n\r\n            // Monitor async operations\r\n            if (result && typeof result.then === 'function') {\r\n              if (strictAsync && activePromises.size > 0) {\r\n                throw new TransactionError(\r\n                  'Cannot start new async operation while another is pending. ' +\r\n                  'Use withTransaction() for complex async operations.'\r\n                );\r\n              }\r\n\r\n              activePromises.add(result);\r\n\r\n              // Add error handling\r\n              result.catch(() => {\r\n                activePromises.delete(result);\r\n              }).finally(() => {\r\n                activePromises.delete(result);\r\n              });\r\n            }\r\n\r\n            return result;\r\n          };\r\n        }\r\n\r\n        return target[property];\r\n      }\r\n    });\r\n\r\n    return monitoredStore;\r\n  }\r\n\r\n  /**\r\n   * Creates a promise-based wrapper for IDBRequest\r\n   * @param {IDBRequest} request - The IndexedDB request\r\n   * @returns {Promise} Resolves with the result\r\n   */\r\n  static promisifyRequest(request) {\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => {\r\n        console.error('IDBRequest failed:', request.error.name, request.error.message);\r\n        reject(new TransactionError(`Request failed: ${request.error.name} - ${request.error.message}`, request.error));\r\n      };\r\n    });\r\n  }\r\n}","import { MigrationError, MigrationRollbackError } from './ErrorHandler.js';\r\nimport TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles safe schema migrations with rollback capabilities\r\n */\r\nexport default class MigrationManager {\r\n  static MIGRATION_STORE = '_migration_meta';\r\n\r\n  /**\r\n   * Runs migrations from old version to new version with safety features\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Array<Migration>} migrations - Array of migration objects\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async runMigrations(db, migrations, fromVersion, toVersion, storeNames = []) {\r\n    if (!migrations || fromVersion >= toVersion) return;\r\n\r\n    // Ensure migration metadata store exists\r\n    await this.ensureMigrationStore(db);\r\n\r\n    // Check if migrations are already completed\r\n    const completedMigrations = await this.getCompletedMigrations(db);\r\n    const pendingMigrations = this.getPendingMigrations(migrations, fromVersion, toVersion, completedMigrations);\r\n\r\n    if (pendingMigrations.length === 0) {\r\n      console.log('All migrations already completed');\r\n      return;\r\n    }\r\n\r\n    console.log(`Running ${pendingMigrations.length} pending migrations...`);\r\n\r\n    for (const migration of pendingMigrations) {\r\n      await this.runMigrationSafely(db, migration, storeNames);\r\n    }\r\n\r\n    console.log('All migrations completed successfully');\r\n  }\r\n\r\n  /**\r\n   * Ensures the migration metadata store exists\r\n   * @param {IDBDatabase} db - Database instance\r\n   */\r\n  static async ensureMigrationStore(db) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      // This would be called during schema creation\r\n      // For existing databases, we need to handle this during upgrade\r\n      console.warn('Migration metadata store not found. This should be created during schema upgrade.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets list of completed migrations\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @returns {Promise<Array<string>>} Array of completed migration IDs\r\n   */\r\n  static async getCompletedMigrations(db) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return [];\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.getAll();\r\n        request.onsuccess = () => {\r\n          const completed = request.result\r\n            .filter(meta => meta.status === 'completed')\r\n            .map(meta => meta.id);\r\n          resolve(completed);\r\n        };\r\n        request.onerror = () => resolve([]);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets pending migrations that need to be run\r\n   * @param {Array<Migration>} migrations - All migrations\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   * @param {Array<string>} completed - Already completed migration IDs\r\n   * @returns {Array<Migration>} Pending migrations\r\n   */\r\n  static getPendingMigrations(migrations, fromVersion, toVersion, completed) {\r\n    return migrations\r\n      .filter(migration => {\r\n        const version = migration.version || migration.id;\r\n        return version > fromVersion && version <= toVersion && !completed.includes(migration.id);\r\n      })\r\n      .sort((a, b) => (a.version || a.id) - (b.version || b.id));\r\n  }\r\n\r\n  /**\r\n   * Runs a single migration with safety features\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to run\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async runMigrationSafely(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n    const startTime = Date.now();\r\n\r\n    console.log(`Starting migration: ${migrationId}`);\r\n\r\n    // Check if migration is already in progress\r\n    const status = await this.getMigrationStatus(db, migrationId);\r\n    if (status === 'in_progress') {\r\n      console.log(`Migration ${migrationId} already in progress, attempting resume...`);\r\n      return this.resumeMigration(db, migration, storeNames);\r\n    } else if (status === 'completed') {\r\n      console.log(`Migration ${migrationId} already completed`);\r\n      return;\r\n    }\r\n\r\n    // Mark migration as in progress\r\n    await this.setMigrationStatus(db, migrationId, 'in_progress', { startTime });\r\n\r\n    try {\r\n      // Run the migration with checkpointing\r\n      await this.executeMigrationWithCheckpointing(db, migration, storeNames);\r\n\r\n      // Mark as completed\r\n      const endTime = Date.now();\r\n      await this.setMigrationStatus(db, migrationId, 'completed', {\r\n        startTime,\r\n        endTime,\r\n        duration: endTime - startTime\r\n      });\r\n\r\n      console.log(`Migration ${migrationId} completed successfully in ${endTime - startTime}ms`);\r\n\r\n    } catch (error) {\r\n      console.error(`Migration ${migrationId} failed:`, error);\r\n\r\n      // Mark as failed\r\n      await this.setMigrationStatus(db, migrationId, 'failed', {\r\n        startTime,\r\n        error: error.message,\r\n        stack: error.stack\r\n      });\r\n\r\n      // Attempt rollback if available\r\n      if (migration.rollback) {\r\n        try {\r\n          console.log(`Attempting rollback for migration ${migrationId}...`);\r\n          await this.rollbackMigration(db, migration, storeNames);\r\n          await this.setMigrationStatus(db, migrationId, 'rolled_back', {\r\n            startTime,\r\n            rollbackTime: Date.now(),\r\n            originalError: error.message\r\n          });\r\n          console.log(`Rollback completed for migration ${migrationId}`);\r\n        } catch (rollbackError) {\r\n          console.error(`Rollback failed for migration ${migrationId}:`, rollbackError);\r\n          await this.setMigrationStatus(db, migrationId, 'rollback_failed', {\r\n            startTime,\r\n            originalError: error.message,\r\n            rollbackError: rollbackError.message\r\n          });\r\n          throw new MigrationRollbackError(`Migration ${migrationId} failed and rollback unsuccessful`, rollbackError);\r\n        }\r\n      }\r\n\r\n      throw new MigrationError(`Migration ${migrationId} failed`, error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes migration with checkpointing for resumability\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to execute\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async executeMigrationWithCheckpointing(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n\r\n    if (migration.checkpointed && typeof migration.up === 'function') {\r\n      // For large migrations, implement checkpointing\r\n      let checkpoint = await this.getMigrationCheckpoint(db, migrationId) || 0;\r\n      const batchSize = migration.batchSize || 1000;\r\n\r\n      while (true) {\r\n        const result = await migration.up(db, checkpoint, batchSize);\r\n\r\n        if (result.completed) {\r\n          break;\r\n        }\r\n\r\n        checkpoint = result.nextCheckpoint;\r\n        await this.setMigrationCheckpoint(db, migrationId, checkpoint);\r\n\r\n        // Allow UI updates and prevent blocking\r\n        await new Promise(resolve => setTimeout(resolve, 0));\r\n      }\r\n    } else {\r\n      // Simple migration without checkpointing\r\n      // Use all available stores for the transaction scope\r\n      const transactionStores = storeNames.length > 0 ? storeNames : [this.MIGRATION_STORE];\r\n      await TransactionManager.execute(db, transactionStores, 'readwrite', (transaction) => {\r\n        return migration.up(db, transaction);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Resumes a migration that was previously interrupted\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to resume\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async resumeMigration(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n    const checkpoint = await this.getMigrationCheckpoint(db, migrationId);\r\n\r\n    if (checkpoint !== null && migration.checkpointed) {\r\n      console.log(`Resuming migration ${migrationId} from checkpoint ${checkpoint}`);\r\n      await this.executeMigrationWithCheckpointing(db, migration);\r\n    } else {\r\n      // Cannot resume, mark as failed and retry\r\n      await this.setMigrationStatus(db, migrationId, 'failed', {\r\n        error: 'Migration interrupted and cannot be resumed'\r\n      });\r\n      throw new MigrationError(`Migration ${migrationId} was interrupted and cannot be resumed`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Rolls back a failed migration\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Migration} migration - Migration to rollback\r\n   * @param {string[]} storeNames - Available store names for transactions\r\n   */\r\n  static async rollbackMigration(db, migration, storeNames = []) {\r\n    const migrationId = migration.id;\r\n\r\n    if (migration.rollback) {\r\n      // Use all available stores for the transaction scope\r\n      const transactionStores = storeNames.length > 0 ? storeNames : [this.MIGRATION_STORE];\r\n      await TransactionManager.execute(db, transactionStores, 'readwrite', (transaction) => {\r\n        return migration.rollback(db, transaction);\r\n      });\r\n    } else {\r\n      throw new MigrationRollbackError(`No rollback function provided for migration ${migrationId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets migration status\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @returns {Promise<string|null>} Migration status\r\n   */\r\n  static async getMigrationStatus(db, migrationId) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return null;\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.get(migrationId);\r\n        request.onsuccess = () => {\r\n          resolve(request.result ? request.result.status : null);\r\n        };\r\n        request.onerror = () => resolve(null);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets migration status\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @param {string} status - Migration status\r\n   * @param {Object} metadata - Additional metadata\r\n   */\r\n  static async setMigrationStatus(db, migrationId, status, metadata = {}) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      // Try to create the store if it doesn't exist\r\n      try {\r\n        await this.createMigrationStore(db);\r\n      } catch (error) {\r\n        console.warn('Could not create migration store:', error);\r\n        return;\r\n      }\r\n    }\r\n\r\n    await TransactionManager.execute(db, [this.MIGRATION_STORE], 'readwrite', (transaction) => {\r\n      return new Promise((resolve, reject) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const data = {\r\n          id: migrationId,\r\n          status,\r\n          timestamp: Date.now(),\r\n          ...metadata\r\n        };\r\n\r\n        const request = store.put(data);\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Gets migration checkpoint\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @returns {Promise<any>} Checkpoint data\r\n   */\r\n  static async getMigrationCheckpoint(db, migrationId) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return null;\r\n    }\r\n\r\n    return TransactionManager.execute(db, [this.MIGRATION_STORE], 'readonly', (transaction) => {\r\n      return new Promise((resolve) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const request = store.get(`${migrationId}_checkpoint`);\r\n        request.onsuccess = () => {\r\n          resolve(request.result ? request.result.checkpoint : null);\r\n        };\r\n        request.onerror = () => resolve(null);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Sets migration checkpoint\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} migrationId - Migration ID\r\n   * @param {any} checkpoint - Checkpoint data\r\n   */\r\n  static async setMigrationCheckpoint(db, migrationId, checkpoint) {\r\n    if (!db.objectStoreNames.contains(this.MIGRATION_STORE)) {\r\n      return;\r\n    }\r\n\r\n    await TransactionManager.execute(db, [this.MIGRATION_STORE], 'readwrite', (transaction) => {\r\n      return new Promise((resolve, reject) => {\r\n        const store = transaction.objectStore(this.MIGRATION_STORE);\r\n        const data = {\r\n          id: `${migrationId}_checkpoint`,\r\n          checkpoint,\r\n          timestamp: Date.now()\r\n        };\r\n\r\n        const request = store.put(data);\r\n        request.onsuccess = () => resolve();\r\n        request.onerror = () => reject(request.error);\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates the migration metadata store\r\n   * @param {IDBDatabase} db - Database instance\r\n   */\r\n  static async createMigrationStore(db) {\r\n    // This should be called during database upgrade\r\n    // For now, we'll try to create it if possible\r\n    if (db.version > 1) {\r\n      console.warn('Migration store should be created during schema upgrade');\r\n    }\r\n  }\r\n}","import { ConnectionError } from './ErrorHandler.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport MigrationManager from './MigrationManager.js';\r\n\r\n/**\r\n * Manages IndexedDB database connections\r\n */\r\nexport default class ConnectionManager {\r\n  constructor(dbName, version, schema, migrations = [], tabCoordinator = null) {\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.tabCoordinator = tabCoordinator;\r\n    this.db = null;\r\n    this.oldVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>} The database instance\r\n   */\r\n  open() {\r\n    return new Promise((resolve, reject) => {\r\n      const indexedDB = globalThis.indexedDB || window?.indexedDB;\r\n      if (!indexedDB) {\r\n        reject(new ConnectionError('IndexedDB not supported'));\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => {\r\n        reject(new ConnectionError('Failed to open database', request.error));\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        this.db = event.target.result;\r\n        this.oldVersion = event.oldVersion;\r\n\r\n        // Announce migration start if coordinator available\r\n        if (this.tabCoordinator && this.oldVersion < this.version) {\r\n          this.tabCoordinator.announceMigrationStart(`upgrade-${this.oldVersion}-${this.version}`, this.version);\r\n        }\r\n\r\n        SchemaManager.createSchema(this.db, this.schema);\r\n      };\r\n\r\n      request.onsuccess = async () => {\r\n        this.db = request.result;\r\n        if (this.oldVersion < this.version) {\r\n          try {\r\n            // Convert legacy migration format to new format if needed\r\n            const normalizedMigrations = this.normalizeMigrations(this.migrations);\r\n            // Get store names from schema for transaction scopes\r\n            const storeNames = Object.keys(this.schema.stores || {});\r\n            await MigrationManager.runMigrations(this.db, normalizedMigrations, this.oldVersion, this.version, storeNames);\r\n\r\n            // Announce migration completion\r\n            if (this.tabCoordinator) {\r\n              this.tabCoordinator.announceMigrationComplete(`upgrade-${this.oldVersion}-${this.version}`, this.version);\r\n            }\r\n          } catch (error) {\r\n            reject(error);\r\n            return;\r\n          }\r\n        }\r\n        resolve(this.db);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is currently open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.db !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.db;\r\n  }\r\n\r\n  /**\r\n   * Normalizes migrations from legacy format to new format\r\n   * @param {Array} migrations - Migration functions or objects\r\n   * @returns {Array} Normalized migration objects\r\n   */\r\n  normalizeMigrations(migrations) {\r\n    if (!migrations || !Array.isArray(migrations)) {\r\n      return [];\r\n    }\r\n\r\n    return migrations.map((migration, index) => {\r\n      // If it's already a migration object, return as-is\r\n      if (migration && typeof migration === 'object' && migration.id) {\r\n        return migration;\r\n      }\r\n\r\n      // Convert legacy function to migration object\r\n      if (typeof migration === 'function') {\r\n        return {\r\n          id: `migration_${index + 1}`,\r\n          version: index + 1,\r\n          up: migration,\r\n          checkpointed: false\r\n        };\r\n      }\r\n\r\n      // Invalid migration\r\n      console.warn(`Invalid migration at index ${index}:`, migration);\r\n      return null;\r\n    }).filter(Boolean);\r\n  }\r\n}","import TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles advanced querying with filters and operators\r\n */\r\nexport default class QueryEngine {\r\n  /**\r\n   * Executes a query with filters using optimized index-aware approach\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (sort, limit, offset, etc.)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  static async query(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      // Analyze query and plan execution\r\n      const queryPlan = this.analyzeQuery(filters, store, options);\r\n\r\n      if (queryPlan.compoundFilters) {\r\n        // Handle compound queries ($and, $or)\r\n        return this.executeCompoundQuery(store, queryPlan.compoundFilters, queryPlan);\r\n      } else if (queryPlan.canUseIndex) {\r\n        // Execute using index cursor\r\n        return this.executeIndexQuery(store, queryPlan);\r\n      } else {\r\n        // Fall back to full scan with in-memory filtering\r\n        return this.executeFullScanQuery(store, filters, queryPlan);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query without executing it\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  static async analyzeQueryPlan(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return this.analyzeQuery(filters, store, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes query to determine optimal execution plan\r\n   * @param {Object} filters - Query filters\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} options - Query options\r\n   * @returns {Object} Query execution plan\r\n   */\r\n  static analyzeQuery(filters, store, options) {\r\n    const plan = {\r\n      canUseIndex: false,\r\n      indexName: null,\r\n      keyRange: null,\r\n      postFilters: {},\r\n      compoundFilters: null, // For $and/$or operations\r\n      sortField: options.sort,\r\n      limit: options.limit,\r\n      offset: options.offset || 0,\r\n      estimatedCost: 0,\r\n      optimizationNotes: []\r\n    };\r\n\r\n    // Check if we have any filters\r\n    if (Object.keys(filters).length === 0) {\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Full table scan - no filters provided');\r\n      return plan; // No filters, will use full scan\r\n    }\r\n\r\n    // Check for compound operators\r\n    if (filters.$and || filters.$or) {\r\n      plan.compoundFilters = filters;\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Compound query requires full scan');\r\n      // Compound queries require full scan for now\r\n      // TODO: Optimize compound queries with multiple indexes\r\n      return plan;\r\n    }\r\n\r\n    // Analyze each filter\r\n    for (const [field, value] of Object.entries(filters)) {\r\n      const indexName = this.findIndexForField(store, field);\r\n\r\n      if (indexName && this.canUseIndexForFilter(value)) {\r\n        // We can use an index for this filter\r\n        plan.canUseIndex = true;\r\n        plan.indexName = indexName;\r\n        plan.keyRange = this.createKeyRange(value);\r\n        plan.estimatedCost = this.estimateIndexQueryCost(store, indexName, value);\r\n        plan.optimizationNotes.push(`Using index '${indexName}' for field '${field}'`);\r\n      } else {\r\n        // This filter requires post-processing\r\n        plan.postFilters[field] = value;\r\n        if (!plan.canUseIndex) {\r\n          plan.estimatedCost = this.estimateFullScanCost(store);\r\n          plan.optimizationNotes.push(`Full scan required for non-indexed field '${field}'`);\r\n        } else {\r\n          plan.optimizationNotes.push(`Post-filtering required for field '${field}'`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of a full table scan\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @returns {number} Estimated cost (higher = more expensive)\r\n   */\r\n  static estimateFullScanCost(store) {\r\n    // Simple estimation: assume we need to scan all records\r\n    // In a real implementation, this could use store statistics\r\n    return 100; // Base cost for full scan\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of an index-based query\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} indexName - Index name\r\n   * @param {*} filterValue - Filter value\r\n   * @returns {number} Estimated cost\r\n   */\r\n  static estimateIndexQueryCost(store, indexName, filterValue) {\r\n    // Simple estimation based on filter type\r\n    if (typeof filterValue === 'object' && filterValue !== null) {\r\n      // Range queries are more expensive than exact matches\r\n      const op = Object.keys(filterValue)[0];\r\n      if (['$gt', '$gte', '$lt', '$lte'].includes(op)) {\r\n        return 20; // Range query\r\n      }\r\n    }\r\n    return 5; // Exact match or equality\r\n  }\r\n\r\n  /**\r\n   * Finds an index that can be used for the given field\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} field - Field name\r\n   * @returns {string|null} Index name or null\r\n   */\r\n  static findIndexForField(store, field) {\r\n    // Check if field is the key path\r\n    if (store.keyPath === field) {\r\n      return null; // Primary key doesn't need index\r\n    }\r\n\r\n    // Look for an index on this field\r\n    for (const indexName of store.indexNames) {\r\n      const index = store.index(indexName);\r\n      if (index.keyPath === field) {\r\n        return indexName;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks if a filter value can be optimized with an index\r\n   * @param {*} value - Filter value\r\n   * @returns {boolean}\r\n   */\r\n  static canUseIndexForFilter(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // Check if it's a range operator\r\n      const operators = Object.keys(value);\r\n      return operators.length === 1 && ['$gt', '$gte', '$lt', '$lte', '$eq'].includes(operators[0]);\r\n    }\r\n\r\n    // Equality filter\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates IDBKeyRange from filter value\r\n   * @param {*} value - Filter value\r\n   * @returns {IDBKeyRange|null}\r\n   */\r\n  static createKeyRange(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      const [op, val] = Object.entries(value)[0];\r\n\r\n      switch (op) {\r\n        case '$gt':\r\n          return IDBKeyRange.lowerBound(val, true);\r\n        case '$gte':\r\n          return IDBKeyRange.lowerBound(val);\r\n        case '$lt':\r\n          return IDBKeyRange.upperBound(val, true);\r\n        case '$lte':\r\n          return IDBKeyRange.upperBound(val);\r\n        case '$eq':\r\n          return IDBKeyRange.only(val);\r\n        default:\r\n          return null;\r\n      }\r\n    } else {\r\n      // Equality\r\n      return IDBKeyRange.only(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes query using index cursor\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeIndexQuery(store, plan) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      let skipped = 0;\r\n\r\n      const index = store.index(plan.indexName);\r\n      const request = index.openCursor(plan.keyRange);\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          // Apply post-filters if any\r\n          if (Object.keys(plan.postFilters).length === 0 ||\r\n              this.matchesFilters(cursor.value, plan.postFilters)) {\r\n\r\n            // Handle offset\r\n            if (skipped < plan.offset) {\r\n              skipped++;\r\n            } else {\r\n              tempResults.push(cursor.value);\r\n\r\n              // For index queries, we need to collect all results first for sorting\r\n              // In a more advanced implementation, we could use multiple indexes\r\n            }\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and final limit/offset\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes compound query ($and, $or)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} compoundFilters - Compound filter object\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeCompoundQuery(store, compoundFilters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesCompoundFilters(cursor.value, compoundFilters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes query with full table scan (fallback)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeFullScanQuery(store, filters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesFilters(cursor.value, filters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Applies sorting and pagination to results\r\n   * @param {Array} results - Query results\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Array} Sorted and paginated results\r\n   */\r\n  static applySortingAndPagination(results, plan) {\r\n    let processedResults = [...results];\r\n\r\n    // Apply sorting if specified\r\n    if (plan.sortField) {\r\n      const [field, direction] = Object.entries(plan.sortField)[0];\r\n      processedResults.sort((a, b) => {\r\n        const aVal = a[field];\r\n        const bVal = b[field];\r\n\r\n        if (aVal < bVal) return direction === 1 ? -1 : 1;\r\n        if (aVal > bVal) return direction === 1 ? 1 : -1;\r\n        return 0;\r\n      });\r\n    }\r\n\r\n    // Apply offset and limit\r\n    if (plan.offset > 0) {\r\n      processedResults = processedResults.slice(plan.offset);\r\n    }\r\n\r\n    if (plan.limit > 0) {\r\n      processedResults = processedResults.slice(0, plan.limit);\r\n    }\r\n\r\n    return processedResults;\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches compound filters ($and, $or)\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} compoundFilters - Compound filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesCompoundFilters(record, compoundFilters) {\r\n    if (compoundFilters.$and) {\r\n      // All conditions must be true\r\n      return compoundFilters.$and.every(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    } else if (compoundFilters.$or) {\r\n      // At least one condition must be true\r\n      return compoundFilters.$or.some(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    }\r\n\r\n    // Fallback to regular filters\r\n    return this.matchesFilters(record, compoundFilters);\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches the given filters\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} filters - Filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesFilters(record, filters) {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      if (key === '$and' || key === '$or') {\r\n        // Handle nested compound operators\r\n        if (!this.matchesCompoundFilters(record, { [key]: value })) {\r\n          return false;\r\n        }\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Operator-based filter\r\n        if (!this.evaluateOperator(record[key], value)) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Equality filter\r\n        if (record[key] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Evaluates operator-based conditions\r\n   * @param {*} fieldValue - Value from the record\r\n   * @param {Object} operator - Operator object (e.g., { $gt: 5 })\r\n   * @returns {boolean}\r\n   */\r\n  static evaluateOperator(fieldValue, operator) {\r\n    const [op, value] = Object.entries(operator)[0];\r\n\r\n    switch (op) {\r\n      case '$gt':\r\n        return fieldValue > value;\r\n      case '$gte':\r\n        return fieldValue >= value;\r\n      case '$lt':\r\n        return fieldValue < value;\r\n      case '$lte':\r\n        return fieldValue <= value;\r\n      case '$eq':\r\n        return fieldValue === value;\r\n      case '$ne':\r\n        return fieldValue !== value;\r\n      case '$regex':\r\n        return new RegExp(value).test(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}","/**\r\n * Performance utilities for monitoring and optimizing IndexedDB operations\r\n */\r\nexport default class PerformanceUtils {\r\n  /**\r\n   * Calculates the approximate size of an object in bytes\r\n   * @param {any} obj - Object to measure\r\n   * @returns {number} Size in bytes\r\n   */\r\n  static calculateObjectSize(obj) {\r\n    if (obj === null || obj === undefined) return 0;\r\n\r\n    // For primitives, return a minimal size\r\n    if (typeof obj !== 'object') {\r\n      if (typeof obj === 'string') return obj.length * 2; // UTF-16\r\n      if (typeof obj === 'boolean') return 1;\r\n      if (typeof obj === 'number') return 8; // 64-bit\r\n      return 0;\r\n    }\r\n\r\n    // Handle arrays\r\n    if (Array.isArray(obj)) {\r\n      let size = 0;\r\n      for (const item of obj) {\r\n        size += this.calculateObjectSize(item);\r\n      }\r\n      return size + (obj.length * 8); // Array overhead\r\n    }\r\n\r\n    // Handle objects\r\n    let size = 0;\r\n    const visited = new WeakSet();\r\n\r\n    const calculateSize = (o) => {\r\n      if (o === null || o === undefined) return 0;\r\n      if (typeof o !== 'object') return this.calculateObjectSize(o);\r\n\r\n      // Prevent circular references\r\n      if (visited.has(o)) return 0;\r\n      visited.add(o);\r\n\r\n      let objSize = 0;\r\n\r\n      if (Array.isArray(o)) {\r\n        for (const item of o) {\r\n          objSize += calculateSize(item);\r\n        }\r\n        objSize += o.length * 8; // Array overhead\r\n      } else {\r\n        for (const key in o) {\r\n          if (o.hasOwnProperty(key)) {\r\n            objSize += key.length * 2; // Key size (UTF-16)\r\n            objSize += calculateSize(o[key]); // Value size\r\n          }\r\n        }\r\n        objSize += Object.keys(o).length * 16; // Object property overhead\r\n      }\r\n\r\n      return objSize;\r\n    };\r\n\r\n    return calculateSize(obj);\r\n  }\r\n\r\n  /**\r\n   * Measures the time taken for structured cloning\r\n   * @param {any} obj - Object to clone\r\n   * @returns {Object} Clone time and size metrics\r\n   */\r\n  static measureCloningPerformance(obj) {\r\n    const startTime = performance.now();\r\n    const size = this.calculateObjectSize(obj);\r\n\r\n    try {\r\n      // Perform structured cloning\r\n      const cloned = structuredClone(obj);\r\n      const endTime = performance.now();\r\n\r\n      return {\r\n        size,\r\n        cloneTime: endTime - startTime,\r\n        success: true,\r\n        cloned\r\n      };\r\n    } catch (error) {\r\n      const endTime = performance.now();\r\n\r\n      return {\r\n        size,\r\n        cloneTime: endTime - startTime,\r\n        success: false,\r\n        error: error.message\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if an object size exceeds performance thresholds\r\n   * @param {number} size - Object size in bytes\r\n   * @returns {Object} Performance assessment\r\n   */\r\n  static assessPerformance(size) {\r\n    const thresholds = {\r\n      small: 1024,      // 1KB\r\n      medium: 1024 * 1024,     // 1MB\r\n      large: 10 * 1024 * 1024, // 10MB\r\n      huge: 50 * 1024 * 1024   // 50MB\r\n    };\r\n\r\n    let level = 'small';\r\n    let warning = null;\r\n    let recommendation = null;\r\n\r\n    if (size >= thresholds.huge) {\r\n      level = 'huge';\r\n      warning = 'Extremely large object may cause performance issues';\r\n      recommendation = 'Consider breaking into smaller chunks or using external storage';\r\n    } else if (size >= thresholds.large) {\r\n      level = 'large';\r\n      warning = 'Large object may impact performance';\r\n      recommendation = 'Consider optimizing data structure or using pagination';\r\n    } else if (size >= thresholds.medium) {\r\n      level = 'medium';\r\n      warning = 'Medium-sized object - monitor performance';\r\n    }\r\n\r\n    return {\r\n      level,\r\n      size,\r\n      sizeKB: Math.round(size / 1024),\r\n      sizeMB: Math.round(size / (1024 * 1024) * 100) / 100,\r\n      warning,\r\n      recommendation,\r\n      thresholds\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Logs performance warnings for large objects\r\n   * @param {string} operation - Operation name\r\n   * @param {any} obj - Object being processed\r\n   * @param {Object} context - Additional context\r\n   */\r\n  static logPerformanceWarning(operation, obj, context = {}) {\r\n    const metrics = this.measureCloningPerformance(obj);\r\n    const assessment = this.assessPerformance(metrics.size);\r\n\r\n    if (assessment.warning) {\r\n      const message = `[Performance Warning] ${operation}: ${assessment.warning}\r\n        Size: ${assessment.sizeMB}MB (${assessment.sizeKB}KB)\r\n        ${assessment.recommendation || ''}\r\n        Context: ${JSON.stringify(context)}`;\r\n\r\n      console.warn(message);\r\n\r\n      // In development, throw error for huge objects\r\n      if (assessment.level === 'huge' && process.env.NODE_ENV === 'development') {\r\n        throw new Error(`Performance violation: ${message}`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      metrics,\r\n      assessment,\r\n      logged: !!assessment.warning\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Monitors transaction performance\r\n   * @param {string} operation - Operation name\r\n   * @param {Function} operationFn - Function to monitor\r\n   * @returns {Promise<Object>} Operation result with performance metrics\r\n   */\r\n  static async monitorTransaction(operation, operationFn) {\r\n    const startTime = performance.now();\r\n\r\n    try {\r\n      const result = await operationFn();\r\n      const endTime = performance.now();\r\n\r\n      const metrics = {\r\n        operation,\r\n        duration: endTime - startTime,\r\n        success: true,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      // Log slow transactions\r\n      if (metrics.duration > 100) { // 100ms threshold\r\n        console.warn(`[Slow Transaction] ${operation} took ${metrics.duration.toFixed(2)}ms`);\r\n      }\r\n\r\n      return {\r\n        result,\r\n        metrics\r\n      };\r\n\r\n    } catch (error) {\r\n      const endTime = performance.now();\r\n\r\n      const metrics = {\r\n        operation,\r\n        duration: endTime - startTime,\r\n        success: false,\r\n        error: error.message,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      console.error(`[Transaction Error] ${operation} failed after ${metrics.duration.toFixed(2)}ms:`, error);\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a performance-monitored version of a function\r\n   * @param {Function} fn - Original function\r\n   * @param {string} name - Function name for logging\r\n   * @returns {Function} Monitored function\r\n   */\r\n  static createMonitoredFunction(fn, name) {\r\n    return async (...args) => {\r\n      const startTime = performance.now();\r\n\r\n      try {\r\n        // Check object sizes for relevant arguments\r\n        for (let i = 0; i < args.length; i++) {\r\n          const arg = args[i];\r\n          if (arg && typeof arg === 'object') {\r\n            this.logPerformanceWarning(`${name}(arg${i})`, arg, { argIndex: i });\r\n          }\r\n        }\r\n\r\n        const result = await fn.apply(this, args);\r\n        const endTime = performance.now();\r\n\r\n        // Log slow operations\r\n        const duration = endTime - startTime;\r\n        if (duration > 50) { // 50ms threshold\r\n          console.warn(`[Slow Operation] ${name} took ${duration.toFixed(2)}ms`);\r\n        }\r\n\r\n        return result;\r\n\r\n      } catch (error) {\r\n        const endTime = performance.now();\r\n        const duration = endTime - startTime;\r\n\r\n        console.error(`[Operation Error] ${name} failed after ${duration.toFixed(2)}ms:`, error);\r\n        throw error;\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets performance statistics\r\n   * @returns {Object} Performance statistics\r\n   */\r\n  static getPerformanceStats() {\r\n    // This would integrate with a more comprehensive monitoring system\r\n    return {\r\n      timestamp: Date.now(),\r\n      memory: typeof performance.memory !== 'undefined' ? {\r\n        used: performance.memory.usedJSHeapSize,\r\n        total: performance.memory.totalJSHeapSize,\r\n        limit: performance.memory.jsHeapSizeLimit\r\n      } : null,\r\n      timing: performance.timing ? {\r\n        navigationStart: performance.timing.navigationStart,\r\n        loadEventEnd: performance.timing.loadEventEnd,\r\n        domContentLoaded: performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart\r\n      } : null\r\n    };\r\n  }\r\n}","/**\r\n * Multi-tab coordination for IndexedDB operations\r\n * Uses BroadcastChannel to coordinate database access across multiple tabs/windows\r\n */\r\nexport default class TabCoordinator {\r\n  constructor(dbName, options = {}) {\r\n    this.dbName = dbName;\r\n    this.options = {\r\n      channelName: `idb-${dbName}`,\r\n      heartbeatInterval: 5000, // 5 seconds\r\n      lockTimeout: 30000, // 30 seconds\r\n      maxRetries: 3,\r\n      retryDelay: 1000, // 1 second\r\n      ...options\r\n    };\r\n\r\n    this.channel = null;\r\n    this.isLeader = false;\r\n    this.tabId = this.generateTabId();\r\n    this.heartbeatTimer = null;\r\n    this.lockQueue = new Map();\r\n    this.activeLocks = new Set();\r\n    this.lastHeartbeat = Date.now();\r\n\r\n    this.init();\r\n  }\r\n\r\n  /**\r\n   * Initialize the coordinator\r\n   */\r\n  init() {\r\n    try {\r\n      this.channel = new BroadcastChannel(this.options.channelName);\r\n      this.setupChannelListeners();\r\n      this.startHeartbeat();\r\n      this.announcePresence();\r\n\r\n      console.log(`[TabCoordinator] Initialized for database '${this.dbName}' with tab ID ${this.tabId}`);\r\n    } catch (error) {\r\n      console.warn('[TabCoordinator] BroadcastChannel not supported, running in single-tab mode');\r\n      this.fallbackMode = true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a unique tab identifier\r\n   */\r\n  generateTabId() {\r\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  /**\r\n   * Set up BroadcastChannel event listeners\r\n   */\r\n  setupChannelListeners() {\r\n    if (!this.channel) return;\r\n\r\n    this.channel.onmessage = (event) => {\r\n      this.handleMessage(event.data);\r\n    };\r\n\r\n    // Handle tab close/unload\r\n    window.addEventListener('beforeunload', () => {\r\n      this.announceDeparture();\r\n    });\r\n\r\n    // Handle visibility change (tab becomes active/inactive)\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (document.hidden) {\r\n        this.announceInactive();\r\n      } else {\r\n        this.announceActive();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle incoming messages from other tabs\r\n   */\r\n  handleMessage(message) {\r\n    const { type, tabId, data, timestamp } = message;\r\n\r\n    // Ignore our own messages\r\n    if (tabId === this.tabId) return;\r\n\r\n    switch (type) {\r\n      case 'presence':\r\n        this.handlePresence(tabId, data);\r\n        break;\r\n      case 'departure':\r\n        this.handleDeparture(tabId);\r\n        break;\r\n      case 'heartbeat':\r\n        this.handleHeartbeat(tabId, timestamp);\r\n        break;\r\n      case 'lock_request':\r\n        this.handleLockRequest(tabId, data);\r\n        break;\r\n      case 'lock_release':\r\n        this.handleLockRelease(tabId, data);\r\n        break;\r\n      case 'lock_granted':\r\n        this.handleLockGranted(data);\r\n        break;\r\n      case 'lock_denied':\r\n        this.handleLockDenied(data);\r\n        break;\r\n      case 'migration_start':\r\n        this.handleMigrationStart(tabId, data);\r\n        break;\r\n      case 'migration_complete':\r\n        this.handleMigrationComplete(tabId, data);\r\n        break;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Start heartbeat timer\r\n   */\r\n  startHeartbeat() {\r\n    this.heartbeatTimer = setInterval(() => {\r\n      this.sendHeartbeat();\r\n      this.checkForDeadTabs();\r\n    }, this.options.heartbeatInterval);\r\n  }\r\n\r\n  /**\r\n   * Send heartbeat to other tabs\r\n   */\r\n  sendHeartbeat() {\r\n    this.broadcast({\r\n      type: 'heartbeat',\r\n      tabId: this.tabId,\r\n      timestamp: Date.now()\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Check for dead tabs and clean up their locks\r\n   */\r\n  checkForDeadTabs() {\r\n    const now = Date.now();\r\n    const timeout = this.options.heartbeatInterval * 3; // 3x heartbeat interval\r\n\r\n    // Clean up dead tab locks\r\n    for (const [lockId, lockInfo] of this.lockQueue) {\r\n      if (now - lockInfo.lastSeen > timeout) {\r\n        console.warn(`[TabCoordinator] Cleaning up dead tab lock: ${lockId}`);\r\n        this.lockQueue.delete(lockId);\r\n        this.activeLocks.delete(lockId);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announce presence to other tabs\r\n   */\r\n  announcePresence() {\r\n    this.broadcast({\r\n      type: 'presence',\r\n      tabId: this.tabId,\r\n      data: {\r\n        userAgent: navigator.userAgent,\r\n        url: window.location.href,\r\n        timestamp: Date.now()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Announce departure\r\n   */\r\n  announceDeparture() {\r\n    this.broadcast({\r\n      type: 'departure',\r\n      tabId: this.tabId,\r\n      timestamp: Date.now()\r\n    });\r\n\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer);\r\n    }\r\n\r\n    if (this.channel) {\r\n      this.channel.close();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announce tab becoming active\r\n   */\r\n  announceActive() {\r\n    this.broadcast({\r\n      type: 'presence',\r\n      tabId: this.tabId,\r\n      data: {\r\n        active: true,\r\n        timestamp: Date.now()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Announce tab becoming inactive\r\n   */\r\n  announceInactive() {\r\n    this.broadcast({\r\n      type: 'presence',\r\n      tabId: this.tabId,\r\n      data: {\r\n        active: false,\r\n        timestamp: Date.now()\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Broadcast message to all tabs\r\n   */\r\n  broadcast(message) {\r\n    if (this.channel && !this.fallbackMode) {\r\n      this.channel.postMessage(message);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle presence announcement from another tab\r\n   */\r\n  handlePresence(tabId, data) {\r\n    // Update last seen time\r\n    this.updateTabLastSeen(tabId);\r\n\r\n    // If this is the first time seeing this tab, acknowledge\r\n    if (!this.lockQueue.has(tabId)) {\r\n      console.log(`[TabCoordinator] Tab ${tabId} joined`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle tab departure\r\n   */\r\n  handleDeparture(tabId) {\r\n    console.log(`[TabCoordinator] Tab ${tabId} departed`);\r\n\r\n    // Clean up any locks held by this tab\r\n    this.cleanupTabLocks(tabId);\r\n  }\r\n\r\n  /**\r\n   * Handle heartbeat from another tab\r\n   */\r\n  handleHeartbeat(tabId, timestamp) {\r\n    this.updateTabLastSeen(tabId);\r\n  }\r\n\r\n  /**\r\n   * Update last seen time for a tab\r\n   */\r\n  updateTabLastSeen(tabId) {\r\n    // Update any lock queue entries for this tab\r\n    for (const [lockId, lockInfo] of this.lockQueue) {\r\n      if (lockInfo.tabId === tabId) {\r\n        lockInfo.lastSeen = Date.now();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clean up locks held by a departed tab\r\n   */\r\n  cleanupTabLocks(tabId) {\r\n    const locksToRemove = [];\r\n\r\n    for (const [lockId, lockInfo] of this.lockQueue) {\r\n      if (lockInfo.tabId === tabId) {\r\n        locksToRemove.push(lockId);\r\n      }\r\n    }\r\n\r\n    for (const lockId of locksToRemove) {\r\n      this.lockQueue.delete(lockId);\r\n      this.activeLocks.delete(lockId);\r\n      console.log(`[TabCoordinator] Released lock ${lockId} from departed tab ${tabId}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Request a database lock\r\n   */\r\n  async requestLock(lockId, options = {}) {\r\n    if (this.fallbackMode) {\r\n      // In fallback mode, just grant the lock immediately\r\n      return Promise.resolve();\r\n    }\r\n\r\n    return new Promise((resolve, reject) => {\r\n      const lockRequest = {\r\n        id: lockId,\r\n        tabId: this.tabId,\r\n        timestamp: Date.now(),\r\n        timeout: options.timeout || this.options.lockTimeout,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      // Check if we already hold this lock\r\n      if (this.activeLocks.has(lockId)) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      // Add to queue\r\n      this.lockQueue.set(lockId, lockRequest);\r\n\r\n      // Broadcast lock request\r\n      this.broadcast({\r\n        type: 'lock_request',\r\n        tabId: this.tabId,\r\n        data: {\r\n          lockId,\r\n          timeout: lockRequest.timeout\r\n        }\r\n      });\r\n\r\n      // Set timeout\r\n      setTimeout(() => {\r\n        if (this.lockQueue.has(lockId)) {\r\n          this.lockQueue.delete(lockId);\r\n          reject(new Error(`Lock request timeout: ${lockId}`));\r\n        }\r\n      }, lockRequest.timeout);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Release a database lock\r\n   */\r\n  releaseLock(lockId) {\r\n    if (this.fallbackMode) return;\r\n\r\n    this.activeLocks.delete(lockId);\r\n    this.lockQueue.delete(lockId);\r\n\r\n    // Notify other tabs\r\n    this.broadcast({\r\n      type: 'lock_release',\r\n      tabId: this.tabId,\r\n      data: { lockId }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle lock request from another tab\r\n   */\r\n  handleLockRequest(fromTabId, data) {\r\n    const { lockId } = data;\r\n\r\n    // If we hold this lock, deny the request\r\n    if (this.activeLocks.has(lockId)) {\r\n      this.broadcast({\r\n        type: 'lock_denied',\r\n        tabId: this.tabId,\r\n        data: { lockId, requestingTab: fromTabId }\r\n      });\r\n      return;\r\n    }\r\n\r\n    // Otherwise, grant the lock\r\n    this.broadcast({\r\n      type: 'lock_granted',\r\n      tabId: this.tabId,\r\n      data: { lockId, requestingTab: fromTabId }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle lock release from another tab\r\n   */\r\n  handleLockRelease(fromTabId, data) {\r\n    const { lockId } = data;\r\n\r\n    // If someone else had this lock, we can now request it\r\n    // This is handled by the requestLock promise resolution\r\n  }\r\n\r\n  /**\r\n   * Handle lock granted message\r\n   */\r\n  handleLockGranted(data) {\r\n    const { lockId } = data;\r\n\r\n    const lockRequest = this.lockQueue.get(lockId);\r\n    if (lockRequest && lockRequest.tabId === this.tabId) {\r\n      this.activeLocks.add(lockId);\r\n      lockRequest.resolve();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle lock denied message\r\n   */\r\n  handleLockDenied(data) {\r\n    const { lockId } = data;\r\n\r\n    const lockRequest = this.lockQueue.get(lockId);\r\n    if (lockRequest && lockRequest.tabId === this.tabId) {\r\n      // Retry with exponential backoff\r\n      this.retryLockRequest(lockRequest);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retry a lock request with backoff\r\n   */\r\n  retryLockRequest(lockRequest) {\r\n    const { id, retryCount = 0 } = lockRequest;\r\n\r\n    if (retryCount >= this.options.maxRetries) {\r\n      lockRequest.reject(new Error(`Lock request failed after ${this.options.maxRetries} retries: ${id}`));\r\n      this.lockQueue.delete(id);\r\n      return;\r\n    }\r\n\r\n    lockRequest.retryCount = retryCount + 1;\r\n    const delay = this.options.retryDelay * Math.pow(2, retryCount);\r\n\r\n    setTimeout(() => {\r\n      // Re-broadcast the lock request\r\n      this.broadcast({\r\n        type: 'lock_request',\r\n        tabId: this.tabId,\r\n        data: {\r\n          lockId: id,\r\n          timeout: lockRequest.timeout\r\n        }\r\n      });\r\n    }, delay);\r\n  }\r\n\r\n  /**\r\n   * Announce migration start\r\n   */\r\n  announceMigrationStart(migrationId, version) {\r\n    this.broadcast({\r\n      type: 'migration_start',\r\n      tabId: this.tabId,\r\n      data: { migrationId, version, timestamp: Date.now() }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Announce migration completion\r\n   */\r\n  announceMigrationComplete(migrationId, version) {\r\n    this.broadcast({\r\n      type: 'migration_complete',\r\n      tabId: this.tabId,\r\n      data: { migrationId, version, timestamp: Date.now() }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Handle migration start from another tab\r\n   */\r\n  handleMigrationStart(fromTabId, data) {\r\n    console.log(`[TabCoordinator] Migration started in tab ${fromTabId}: ${data.migrationId} -> v${data.version}`);\r\n    // Other tabs should wait or coordinate\r\n  }\r\n\r\n  /**\r\n   * Handle migration completion from another tab\r\n   */\r\n  handleMigrationComplete(fromTabId, data) {\r\n    console.log(`[TabCoordinator] Migration completed in tab ${fromTabId}: ${data.migrationId} -> v${data.version}`);\r\n    // Other tabs can now proceed\r\n  }\r\n\r\n  /**\r\n   * Get coordination status\r\n   */\r\n  getStatus() {\r\n    return {\r\n      tabId: this.tabId,\r\n      isLeader: this.isLeader,\r\n      activeLocks: Array.from(this.activeLocks),\r\n      queuedLocks: Array.from(this.lockQueue.keys()),\r\n      fallbackMode: this.fallbackMode,\r\n      channelSupported: !!this.channel\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Clean up resources\r\n   */\r\n  destroy() {\r\n    this.announceDeparture();\r\n\r\n    if (this.heartbeatTimer) {\r\n      clearInterval(this.heartbeatTimer);\r\n    }\r\n\r\n    if (this.channel) {\r\n      this.channel.close();\r\n    }\r\n  }\r\n}","import ConnectionManager from './ConnectionManager.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport TransactionManager from './TransactionManager.js';\r\nimport QueryEngine from './QueryEngine.js';\r\nimport PerformanceUtils from './PerformanceUtils.js';\r\nimport TabCoordinator from './TabCoordinator.js';\r\n\r\n/**\r\n * Main IndexedDB wrapper class\r\n */\r\nexport default class IDBWrapper {\r\n  constructor(dbName, version, schema, migrations = [], options = {}) {\r\n    // Validate schema upfront\r\n    SchemaManager.validateSchema(schema);\r\n\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.options = {\r\n      enableTabCoordination: true,\r\n      ...options\r\n    };\r\n\r\n    this.connectionManager = new ConnectionManager(dbName, version, schema, migrations, this.tabCoordinator);\r\n\r\n    // Initialize tab coordination if enabled\r\n    if (this.options.enableTabCoordination && typeof BroadcastChannel !== 'undefined') {\r\n      this.tabCoordinator = new TabCoordinator(dbName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>}\r\n   */\r\n  async open() {\r\n    return this.connectionManager.open();\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    this.connectionManager.close();\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.connectionManager.isOpen();\r\n  }\r\n\r\n  /**\r\n   * Gets the database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.connectionManager.getDatabase();\r\n  }\r\n\r\n  /**\r\n   * Execute an operation with tab coordination\r\n   * @param {string} lockId - Lock identifier\r\n   * @param {Function} operation - Operation to execute\r\n   * @returns {Promise} Operation result\r\n   */\r\n  async withCoordination(lockId, operation) {\r\n    if (this.tabCoordinator) {\r\n      await this.tabCoordinator.requestLock(lockId);\r\n      try {\r\n        return await operation();\r\n      } finally {\r\n        this.tabCoordinator.releaseLock(lockId);\r\n      }\r\n    } else {\r\n      // No coordination available, execute directly\r\n      return operation();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get tab coordination status\r\n   * @returns {Object} Coordination status\r\n   */\r\n  getCoordinationStatus() {\r\n    if (this.tabCoordinator) {\r\n      return this.tabCoordinator.getStatus();\r\n    }\r\n    return { enabled: false, reason: 'BroadcastChannel not supported or disabled' };\r\n  }\r\n\r\n  /**\r\n   * Creates a new record\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} data - Data to store\r\n   * @returns {Promise} Resolves with the key\r\n   */\r\n  async create(storeName, data) {\r\n    return this.withCoordination(`write-${storeName}`, async () => {\r\n      const db = this.getDatabase();\r\n      if (!db) throw new Error('Database not open');\r\n\r\n      // Monitor performance for large objects\r\n      PerformanceUtils.logPerformanceWarning('IDBWrapper.create', data, { storeName });\r\n\r\n      return PerformanceUtils.monitorTransaction(`create(${storeName})`, () =>\r\n        TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n          const store = transaction.objectStore(storeName);\r\n          return TransactionManager.promisifyRequest(store.add(data));\r\n        })\r\n      ).then(result => result.result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a record by key\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves with the record or undefined\r\n   */\r\n  async read(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readonly', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.get(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @param {Object} data - Updated data\r\n   * @returns {Promise} Resolves when updated\r\n   */\r\n  async update(storeName, key, data) {\r\n    return this.withCoordination(`write-${storeName}`, async () => {\r\n      const db = this.getDatabase();\r\n      if (!db) throw new Error('Database not open');\r\n\r\n      // Monitor performance for large objects\r\n      PerformanceUtils.logPerformanceWarning('IDBWrapper.update', data, { storeName, key });\r\n\r\n      return PerformanceUtils.monitorTransaction(`update(${storeName})`, () =>\r\n        TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n          const store = transaction.objectStore(storeName);\r\n\r\n          return new Promise((resolve, reject) => {\r\n            const getRequest = store.get(key);\r\n            getRequest.onsuccess = () => {\r\n              const existing = getRequest.result;\r\n              if (!existing) {\r\n                reject(new Error('Record not found'));\r\n                return;\r\n              }\r\n              const updatedData = { ...existing, ...data };\r\n              const putRequest = store.put(updatedData);\r\n              putRequest.onsuccess = () => resolve();\r\n              putRequest.onerror = () => reject(new TransactionError('Put failed', putRequest.error));\r\n            };\r\n            getRequest.onerror = () => reject(new TransactionError('Get failed', getRequest.error));\r\n          });\r\n        })\r\n      ).then(result => result.result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves when deleted\r\n   */\r\n  async delete(storeName, key) {\r\n    return this.withCoordination(`write-${storeName}`, async () => {\r\n      const db = this.getDatabase();\r\n      if (!db) throw new Error('Database not open');\r\n\r\n      return PerformanceUtils.monitorTransaction(`delete(${storeName})`, () =>\r\n        TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n          const store = transaction.objectStore(storeName);\r\n          return TransactionManager.promisifyRequest(store.delete(key));\r\n        })\r\n      ).then(result => result.result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries records with filters\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (limit, offset, sort)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  async query(storeName, filters = {}, options = {}) {\r\n    return this.withCoordination(`read-${storeName}`, async () => {\r\n      const db = this.getDatabase();\r\n      if (!db) throw new Error('Database not open');\r\n\r\n      return PerformanceUtils.monitorTransaction(`query(${storeName})`, () =>\r\n        QueryEngine.query(db, storeName, filters, options)\r\n      ).then(result => result.result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query plan without executing it\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  async analyzeQuery(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.analyzeQueryPlan(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Performs bulk operations\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async bulk(storeName, operations) {\r\n    return this.withCoordination(`bulk-${storeName}`, async () => {\r\n      const db = this.getDatabase();\r\n      if (!db) throw new Error('Database not open');\r\n\r\n      // Monitor performance for bulk operations\r\n      const totalSize = operations.reduce((size, op) => {\r\n        return size + PerformanceUtils.calculateObjectSize(op.data || {});\r\n      }, 0);\r\n\r\n      PerformanceUtils.logPerformanceWarning('IDBWrapper.bulk', { operations, totalSize }, {\r\n        storeName,\r\n        operationCount: operations.length\r\n      });\r\n\r\n      return PerformanceUtils.monitorTransaction(`bulk(${storeName}, ${operations.length} ops)`, () =>\r\n        TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n          const store = transaction.objectStore(storeName);\r\n\r\n          const promises = operations.map(op => {\r\n            switch (op.type) {\r\n              case 'create':\r\n                return TransactionManager.promisifyRequest(store.add(op.data));\r\n              case 'update':\r\n                return TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n              case 'delete':\r\n                return TransactionManager.promisifyRequest(store.delete(op.id));\r\n              default:\r\n                throw new Error(`Unknown operation type: ${op.type}`);\r\n            }\r\n          });\r\n\r\n          return Promise.all(promises);\r\n        })\r\n      ).then(result => result.result);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Executes operations within a safe transaction context\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} callback - Function to execute within transaction\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise} Result of the callback\r\n   */\r\n  async withTransaction(storeNames, mode, callback, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    const transactionOptions = {\r\n      timeout: options.timeout || 5000,\r\n      strictAsync: options.strictAsync !== false, // Default to strict\r\n      ...options\r\n    };\r\n\r\n    return TransactionManager.execute(db, storeNames, mode, callback, transactionOptions);\r\n  }\r\n\r\n  /**\r\n   * Performs a safe bulk operation with transaction guarantees\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @param {Object} options - Transaction options\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async safeBulk(storeName, operations, options = {}) {\r\n    return this.withTransaction(storeName, 'readwrite', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      const results = [];\r\n\r\n      for (const op of operations) {\r\n        let result;\r\n        switch (op.type) {\r\n          case 'create':\r\n            result = await TransactionManager.promisifyRequest(store.add(op.data));\r\n            break;\r\n          case 'update':\r\n            result = await TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n            break;\r\n          case 'delete':\r\n            result = await TransactionManager.promisifyRequest(store.delete(op.id));\r\n            break;\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n        results.push(result);\r\n      }\r\n\r\n      return results;\r\n    }, options);\r\n  }\r\n}"],"names":["IDBError","Error","constructor","message","originalError","super","this","name","ConnectionError","SchemaError","MigrationError","TransactionError","code","TransactionInactiveError","TransactionTimeoutError","timeout","MigrationRollbackError","SchemaManager","validateSchema","schema","stores","storeName","storeConfig","Object","entries","keyPath","indexes","indexName","indexConfig","unique","createSchema","db","createMigrationStore","objectStoreNames","contains","store","createObjectStore","autoIncrement","createIndex","MIGRATION_STORE","checkSchemaConsistency","keys","TransactionManager","execute","storeNames","mode","operation","options","strictAsync","Promise","resolve","reject","transaction","timeoutId","completed","setTimeout","readyState","abort","error","onerror","clearTimeout","onabort","activePromises","Set","async","txn","executeWithSafety","safeOperation","then","result","oncomplete","catch","safety","createMonitoredTransaction","add","resolvedResult","delete","Proxy","get","target","property","objectStore","createMonitoredObjectStore","args","size","finally","promisifyRequest","request","onsuccess","console","MigrationManager","static","runMigrations","migrations","fromVersion","toVersion","ensureMigrationStore","completedMigrations","getCompletedMigrations","pendingMigrations","getPendingMigrations","length","log","migration","runMigrationSafely","warn","getAll","filter","meta","status","map","id","version","includes","sort","a","b","migrationId","startTime","Date","now","getMigrationStatus","resumeMigration","setMigrationStatus","executeMigrationWithCheckpointing","endTime","duration","stack","rollback","rollbackMigration","rollbackTime","rollbackError","checkpointed","up","checkpoint","getMigrationCheckpoint","batchSize","nextCheckpoint","setMigrationCheckpoint","transactionStores","metadata","data","timestamp","put","ConnectionManager","dbName","tabCoordinator","oldVersion","open","indexedDB","globalThis","window","onupgradeneeded","event","announceMigrationStart","normalizedMigrations","normalizeMigrations","announceMigrationComplete","close","isOpen","getDatabase","Array","isArray","index","Boolean","QueryEngine","query","filters","queryPlan","analyzeQuery","compoundFilters","executeCompoundQuery","canUseIndex","executeIndexQuery","executeFullScanQuery","analyzeQueryPlan","plan","keyRange","postFilters","sortField","limit","offset","estimatedCost","optimizationNotes","estimateFullScanCost","push","$and","$or","field","value","findIndexForField","canUseIndexForFilter","createKeyRange","estimateIndexQueryCost","filterValue","op","indexNames","operators","IDBKeyRange","only","val","lowerBound","upperBound","results","tempResults","skipped","openCursor","cursor","matchesFilters","continue","applySortingAndPagination","matchesCompoundFilters","processedResults","direction","aVal","bVal","slice","record","every","condition","values","some","key","evaluateOperator","fieldValue","operator","RegExp","test","PerformanceUtils","calculateObjectSize","obj","item","visited","WeakSet","calculateSize","o","has","objSize","hasOwnProperty","measureCloningPerformance","performance","cloned","structuredClone","cloneTime","success","assessPerformance","thresholds","small","medium","large","huge","level","warning","recommendation","sizeKB","Math","round","sizeMB","logPerformanceWarning","context","metrics","assessment","JSON","stringify","process","env","NODE_ENV","logged","monitorTransaction","operationFn","toFixed","createMonitoredFunction","fn","i","arg","argIndex","apply","getPerformanceStats","memory","used","usedJSHeapSize","total","totalJSHeapSize","jsHeapSizeLimit","timing","navigationStart","loadEventEnd","domContentLoaded","domContentLoadedEventEnd","TabCoordinator","channelName","heartbeatInterval","lockTimeout","maxRetries","retryDelay","channel","isLeader","tabId","generateTabId","heartbeatTimer","lockQueue","Map","activeLocks","lastHeartbeat","init","BroadcastChannel","setupChannelListeners","startHeartbeat","announcePresence","fallbackMode","random","toString","substr","onmessage","handleMessage","addEventListener","announceDeparture","document","hidden","announceInactive","announceActive","type","handlePresence","handleDeparture","handleHeartbeat","handleLockRequest","handleLockRelease","handleLockGranted","handleLockDenied","handleMigrationStart","handleMigrationComplete","setInterval","sendHeartbeat","checkForDeadTabs","broadcast","lockId","lockInfo","lastSeen","userAgent","navigator","url","location","href","clearInterval","active","postMessage","updateTabLastSeen","cleanupTabLocks","locksToRemove","requestLock","lockRequest","set","releaseLock","fromTabId","requestingTab","retryLockRequest","retryCount","delay","pow","getStatus","from","queuedLocks","channelSupported","destroy","IDBWrapper","enableTabCoordination","connectionManager","withCoordination","getCoordinationStatus","enabled","reason","create","read","update","getRequest","existing","updatedData","putRequest","bulk","operations","totalSize","reduce","operationCount","promises","all","withTransaction","callback","transactionOptions","safeBulk"],"mappings":"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"}