{"version":3,"file":"index.mjs","sources":["../src/ErrorHandler.js","../src/SchemaManager.js","../src/TransactionManager.js","../src/MigrationManager.js","../src/ConnectionManager.js","../src/QueryEngine.js","../src/IDBWrapper.js"],"sourcesContent":["/**\r\n * Base error class for IndexedDB operations\r\n */\r\nexport class IDBError extends Error {\r\n  constructor(message, originalError = null) {\r\n    super(message);\r\n    this.name = 'IDBError';\r\n    this.originalError = originalError;\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when database connection fails\r\n */\r\nexport class ConnectionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'ConnectionError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when schema validation fails\r\n */\r\nexport class SchemaError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'SchemaError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when migration fails\r\n */\r\nexport class MigrationError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'MigrationError';\r\n  }\r\n}\r\n\r\n/**\r\n * Error thrown when transaction fails\r\n */\r\nexport class TransactionError extends IDBError {\r\n  constructor(message, originalError = null) {\r\n    super(message, originalError);\r\n    this.name = 'TransactionError';\r\n  }\r\n}","import { SchemaError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages schema validation and object store creation\r\n */\r\nexport default class SchemaManager {\r\n  /**\r\n   * Validates the schema structure\r\n   * @param {Object} schema - The schema definition\r\n   * @throws {SchemaError} If schema is invalid\r\n   */\r\n  static validateSchema(schema) {\r\n    if (!schema || typeof schema !== 'object') {\r\n      throw new SchemaError('Schema must be an object');\r\n    }\r\n\r\n    if (!schema.stores || typeof schema.stores !== 'object') {\r\n      throw new SchemaError('Schema must have a stores property');\r\n    }\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!storeConfig || typeof storeConfig !== 'object') {\r\n        throw new SchemaError(`Store ${storeName} configuration must be an object`);\r\n      }\r\n\r\n      if (!storeConfig.keyPath) {\r\n        throw new SchemaError(`Store ${storeName} must have a keyPath`);\r\n      }\r\n\r\n      // Validate indexes\r\n      if (storeConfig.indexes) {\r\n        if (typeof storeConfig.indexes !== 'object') {\r\n          throw new SchemaError(`Indexes for store ${storeName} must be an object`);\r\n        }\r\n\r\n        for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n          if (typeof indexConfig !== 'object') {\r\n            throw new SchemaError(`Index ${indexName} in store ${storeName} must be an object`);\r\n          }\r\n\r\n          if (!indexConfig.keyPath && !indexConfig.unique) {\r\n            // Allow minimal config, but warn if no keyPath\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates object stores and indexes in the database\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The schema definition\r\n   */\r\n  static createSchema(db, schema) {\r\n    this.validateSchema(schema);\r\n\r\n    for (const [storeName, storeConfig] of Object.entries(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        const store = db.createObjectStore(storeName, {\r\n          keyPath: storeConfig.keyPath,\r\n          autoIncrement: storeConfig.autoIncrement || false\r\n        });\r\n\r\n        if (storeConfig.indexes) {\r\n          for (const [indexName, indexConfig] of Object.entries(storeConfig.indexes)) {\r\n            const keyPath = indexConfig.keyPath || indexName;\r\n            store.createIndex(indexName, keyPath, {\r\n              unique: indexConfig.unique || false\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the existing schema matches the expected schema\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {Object} schema - The expected schema\r\n   * @returns {boolean} True if schema matches\r\n   */\r\n  static checkSchemaConsistency(db, schema) {\r\n    // This would be more complex in a real implementation\r\n    // For now, just check if stores exist\r\n    for (const storeName of Object.keys(schema.stores)) {\r\n      if (!db.objectStoreNames.contains(storeName)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}","import { TransactionError } from './ErrorHandler.js';\r\n\r\n/**\r\n * Manages IndexedDB transactions\r\n */\r\nexport default class TransactionManager {\r\n  /**\r\n   * Executes an operation within a transaction\r\n   * @param {IDBDatabase} db - The database instance\r\n   * @param {string|string[]} storeNames - Store name(s) for the transaction\r\n   * @param {string} mode - Transaction mode ('readonly' or 'readwrite')\r\n   * @param {Function} operation - Function that receives the transaction and performs operations\r\n   * @returns {Promise} Result of the operation\r\n   */\r\n  static async execute(db, storeNames, mode, operation) {\r\n    return new Promise((resolve, reject) => {\r\n      const transaction = db.transaction(storeNames, mode);\r\n\r\n      transaction.onerror = () => {\r\n        reject(new TransactionError('Transaction failed', transaction.error));\r\n      };\r\n\r\n      transaction.onabort = () => {\r\n        reject(new TransactionError('Transaction aborted'));\r\n      };\r\n\r\n      let operationResult;\r\n\r\n      try {\r\n        operationResult = operation(transaction);\r\n\r\n        // If operation returns a promise, wait for it\r\n        if (operationResult && typeof operationResult.then === 'function') {\r\n          operationResult.then((result) => {\r\n            transaction.oncomplete = () => resolve(result);\r\n          }).catch(reject);\r\n        } else {\r\n          // For synchronous operations, resolve on complete\r\n          transaction.oncomplete = () => resolve(operationResult);\r\n        }\r\n      } catch (error) {\r\n        reject(new TransactionError('Operation failed', error));\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Creates a promise-based wrapper for IDBRequest\r\n   * @param {IDBRequest} request - The IndexedDB request\r\n   * @returns {Promise} Resolves with the result\r\n   */\r\n  static promisifyRequest(request) {\r\n    return new Promise((resolve, reject) => {\r\n      request.onsuccess = () => resolve(request.result);\r\n      request.onerror = () => {\r\n        console.error('IDBRequest failed:', request.error.name, request.error.message);\r\n        reject(new TransactionError(`Request failed: ${request.error.name} - ${request.error.message}`, request.error));\r\n      };\r\n    });\r\n  }\r\n}","import { MigrationError } from './ErrorHandler.js';\r\nimport TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles schema migrations\r\n */\r\nexport default class MigrationManager {\r\n  /**\r\n   * Runs migrations from old version to new version\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {Array<Function>} migrations - Array of migration functions\r\n   * @param {number} fromVersion - Starting version\r\n   * @param {number} toVersion - Target version\r\n   */\r\n  static async runMigrations(db, migrations, fromVersion, toVersion) {\r\n    if (!migrations || fromVersion >= toVersion) return;\r\n\r\n    for (let i = fromVersion; i < toVersion; i++) {\r\n      const migrationIndex = i; // migrations[0] is for version 1->2\r\n\r\n      if (migrations[migrationIndex]) {\r\n        try {\r\n          await TransactionManager.execute(db, [], 'readwrite', (transaction) => {\r\n            return migrations[migrationIndex](db, transaction);\r\n          });\r\n        } catch (error) {\r\n          throw new MigrationError(`Migration from version ${i} to ${i + 1} failed`, error);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}","import { ConnectionError } from './ErrorHandler.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport MigrationManager from './MigrationManager.js';\r\n\r\n/**\r\n * Manages IndexedDB database connections\r\n */\r\nexport default class ConnectionManager {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n    this.db = null;\r\n    this.oldVersion = 0;\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>} The database instance\r\n   */\r\n  open() {\r\n    return new Promise((resolve, reject) => {\r\n      const indexedDB = globalThis.indexedDB || window?.indexedDB;\r\n      if (!indexedDB) {\r\n        reject(new ConnectionError('IndexedDB not supported'));\r\n        return;\r\n      }\r\n\r\n      const request = indexedDB.open(this.dbName, this.version);\r\n\r\n      request.onerror = () => {\r\n        reject(new ConnectionError('Failed to open database', request.error));\r\n      };\r\n\r\n      request.onupgradeneeded = (event) => {\r\n        this.db = event.target.result;\r\n        this.oldVersion = event.oldVersion;\r\n        SchemaManager.createSchema(this.db, this.schema);\r\n      };\r\n\r\n      request.onsuccess = async () => {\r\n        this.db = request.result;\r\n        if (this.oldVersion < this.version) {\r\n          try {\r\n            await MigrationManager.runMigrations(this.db, this.migrations, this.oldVersion, this.version);\r\n          } catch (error) {\r\n            reject(error);\r\n            return;\r\n          }\r\n        }\r\n        resolve(this.db);\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    if (this.db) {\r\n      this.db.close();\r\n      this.db = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is currently open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.db !== null;\r\n  }\r\n\r\n  /**\r\n   * Gets the current database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.db;\r\n  }\r\n}","import TransactionManager from './TransactionManager.js';\r\n\r\n/**\r\n * Handles advanced querying with filters and operators\r\n */\r\nexport default class QueryEngine {\r\n  /**\r\n   * Executes a query with filters using optimized index-aware approach\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (sort, limit, offset, etc.)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  static async query(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      // Analyze query and plan execution\r\n      const queryPlan = this.analyzeQuery(filters, store, options);\r\n\r\n      if (queryPlan.compoundFilters) {\r\n        // Handle compound queries ($and, $or)\r\n        return this.executeCompoundQuery(store, queryPlan.compoundFilters, queryPlan);\r\n      } else if (queryPlan.canUseIndex) {\r\n        // Execute using index cursor\r\n        return this.executeIndexQuery(store, queryPlan);\r\n      } else {\r\n        // Fall back to full scan with in-memory filtering\r\n        return this.executeFullScanQuery(store, filters, queryPlan);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query without executing it\r\n   * @param {IDBDatabase} db - Database instance\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  static async analyzeQueryPlan(db, storeName, filters = {}, options = {}) {\r\n    return TransactionManager.execute(db, storeName, 'readonly', async (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return this.analyzeQuery(filters, store, options);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Analyzes query to determine optimal execution plan\r\n   * @param {Object} filters - Query filters\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} options - Query options\r\n   * @returns {Object} Query execution plan\r\n   */\r\n  static analyzeQuery(filters, store, options) {\r\n    const plan = {\r\n      canUseIndex: false,\r\n      indexName: null,\r\n      keyRange: null,\r\n      postFilters: {},\r\n      compoundFilters: null, // For $and/$or operations\r\n      sortField: options.sort,\r\n      limit: options.limit,\r\n      offset: options.offset || 0,\r\n      estimatedCost: 0,\r\n      optimizationNotes: []\r\n    };\r\n\r\n    // Check if we have any filters\r\n    if (Object.keys(filters).length === 0) {\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Full table scan - no filters provided');\r\n      return plan; // No filters, will use full scan\r\n    }\r\n\r\n    // Check for compound operators\r\n    if (filters.$and || filters.$or) {\r\n      plan.compoundFilters = filters;\r\n      plan.estimatedCost = this.estimateFullScanCost(store);\r\n      plan.optimizationNotes.push('Compound query requires full scan');\r\n      // Compound queries require full scan for now\r\n      // TODO: Optimize compound queries with multiple indexes\r\n      return plan;\r\n    }\r\n\r\n    // Analyze each filter\r\n    for (const [field, value] of Object.entries(filters)) {\r\n      const indexName = this.findIndexForField(store, field);\r\n\r\n      if (indexName && this.canUseIndexForFilter(value)) {\r\n        // We can use an index for this filter\r\n        plan.canUseIndex = true;\r\n        plan.indexName = indexName;\r\n        plan.keyRange = this.createKeyRange(value);\r\n        plan.estimatedCost = this.estimateIndexQueryCost(store, indexName, value);\r\n        plan.optimizationNotes.push(`Using index '${indexName}' for field '${field}'`);\r\n      } else {\r\n        // This filter requires post-processing\r\n        plan.postFilters[field] = value;\r\n        if (!plan.canUseIndex) {\r\n          plan.estimatedCost = this.estimateFullScanCost(store);\r\n          plan.optimizationNotes.push(`Full scan required for non-indexed field '${field}'`);\r\n        } else {\r\n          plan.optimizationNotes.push(`Post-filtering required for field '${field}'`);\r\n        }\r\n      }\r\n    }\r\n\r\n    return plan;\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of a full table scan\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @returns {number} Estimated cost (higher = more expensive)\r\n   */\r\n  static estimateFullScanCost(store) {\r\n    // Simple estimation: assume we need to scan all records\r\n    // In a real implementation, this could use store statistics\r\n    return 100; // Base cost for full scan\r\n  }\r\n\r\n  /**\r\n   * Estimates cost of an index-based query\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} indexName - Index name\r\n   * @param {*} filterValue - Filter value\r\n   * @returns {number} Estimated cost\r\n   */\r\n  static estimateIndexQueryCost(store, indexName, filterValue) {\r\n    // Simple estimation based on filter type\r\n    if (typeof filterValue === 'object' && filterValue !== null) {\r\n      // Range queries are more expensive than exact matches\r\n      const op = Object.keys(filterValue)[0];\r\n      if (['$gt', '$gte', '$lt', '$lte'].includes(op)) {\r\n        return 20; // Range query\r\n      }\r\n    }\r\n    return 5; // Exact match or equality\r\n  }\r\n\r\n  /**\r\n   * Finds an index that can be used for the given field\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {string} field - Field name\r\n   * @returns {string|null} Index name or null\r\n   */\r\n  static findIndexForField(store, field) {\r\n    // Check if field is the key path\r\n    if (store.keyPath === field) {\r\n      return null; // Primary key doesn't need index\r\n    }\r\n\r\n    // Look for an index on this field\r\n    for (const indexName of store.indexNames) {\r\n      const index = store.index(indexName);\r\n      if (index.keyPath === field) {\r\n        return indexName;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Checks if a filter value can be optimized with an index\r\n   * @param {*} value - Filter value\r\n   * @returns {boolean}\r\n   */\r\n  static canUseIndexForFilter(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      // Check if it's a range operator\r\n      const operators = Object.keys(value);\r\n      return operators.length === 1 && ['$gt', '$gte', '$lt', '$lte', '$eq'].includes(operators[0]);\r\n    }\r\n\r\n    // Equality filter\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Creates IDBKeyRange from filter value\r\n   * @param {*} value - Filter value\r\n   * @returns {IDBKeyRange|null}\r\n   */\r\n  static createKeyRange(value) {\r\n    if (typeof value === 'object' && value !== null) {\r\n      const [op, val] = Object.entries(value)[0];\r\n\r\n      switch (op) {\r\n        case '$gt':\r\n          return IDBKeyRange.lowerBound(val, true);\r\n        case '$gte':\r\n          return IDBKeyRange.lowerBound(val);\r\n        case '$lt':\r\n          return IDBKeyRange.upperBound(val, true);\r\n        case '$lte':\r\n          return IDBKeyRange.upperBound(val);\r\n        case '$eq':\r\n          return IDBKeyRange.only(val);\r\n        default:\r\n          return null;\r\n      }\r\n    } else {\r\n      // Equality\r\n      return IDBKeyRange.only(value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes query using index cursor\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeIndexQuery(store, plan) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      let skipped = 0;\r\n\r\n      const index = store.index(plan.indexName);\r\n      const request = index.openCursor(plan.keyRange);\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          // Apply post-filters if any\r\n          if (Object.keys(plan.postFilters).length === 0 ||\r\n              this.matchesFilters(cursor.value, plan.postFilters)) {\r\n\r\n            // Handle offset\r\n            if (skipped < plan.offset) {\r\n              skipped++;\r\n            } else {\r\n              tempResults.push(cursor.value);\r\n\r\n              // For index queries, we need to collect all results first for sorting\r\n              // In a more advanced implementation, we could use multiple indexes\r\n            }\r\n          }\r\n\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and final limit/offset\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes compound query ($and, $or)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} compoundFilters - Compound filter object\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeCompoundQuery(store, compoundFilters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesCompoundFilters(cursor.value, compoundFilters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Executes query with full table scan (fallback)\r\n   * @param {IDBObjectStore} store - Object store\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Promise<Array>} Results\r\n   */\r\n  static async executeFullScanQuery(store, filters, plan = {}) {\r\n    const results = await new Promise((resolve, reject) => {\r\n      const tempResults = [];\r\n      const request = store.openCursor();\r\n\r\n      request.onsuccess = (event) => {\r\n        const cursor = event.target.result;\r\n\r\n        if (cursor) {\r\n          if (this.matchesFilters(cursor.value, filters)) {\r\n            tempResults.push(cursor.value);\r\n          }\r\n          cursor.continue();\r\n        } else {\r\n          resolve(tempResults);\r\n        }\r\n      };\r\n\r\n      request.onerror = () => reject(request.error);\r\n    });\r\n\r\n    // Apply sorting and pagination\r\n    return this.applySortingAndPagination(results, plan);\r\n  }\r\n\r\n  /**\r\n   * Applies sorting and pagination to results\r\n   * @param {Array} results - Query results\r\n   * @param {Object} plan - Query execution plan\r\n   * @returns {Array} Sorted and paginated results\r\n   */\r\n  static applySortingAndPagination(results, plan) {\r\n    let processedResults = [...results];\r\n\r\n    // Apply sorting if specified\r\n    if (plan.sortField) {\r\n      const [field, direction] = Object.entries(plan.sortField)[0];\r\n      processedResults.sort((a, b) => {\r\n        const aVal = a[field];\r\n        const bVal = b[field];\r\n\r\n        if (aVal < bVal) return direction === 1 ? -1 : 1;\r\n        if (aVal > bVal) return direction === 1 ? 1 : -1;\r\n        return 0;\r\n      });\r\n    }\r\n\r\n    // Apply offset and limit\r\n    if (plan.offset > 0) {\r\n      processedResults = processedResults.slice(plan.offset);\r\n    }\r\n\r\n    if (plan.limit > 0) {\r\n      processedResults = processedResults.slice(0, plan.limit);\r\n    }\r\n\r\n    return processedResults;\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches compound filters ($and, $or)\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} compoundFilters - Compound filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesCompoundFilters(record, compoundFilters) {\r\n    if (compoundFilters.$and) {\r\n      // All conditions must be true\r\n      return compoundFilters.$and.every(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    } else if (compoundFilters.$or) {\r\n      // At least one condition must be true\r\n      return compoundFilters.$or.some(condition =>\r\n        this.matchesFilters(record, { [Object.keys(condition)[0]]: Object.values(condition)[0] })\r\n      );\r\n    }\r\n\r\n    // Fallback to regular filters\r\n    return this.matchesFilters(record, compoundFilters);\r\n  }\r\n\r\n  /**\r\n   * Checks if a record matches the given filters\r\n   * @param {Object} record - Record to check\r\n   * @param {Object} filters - Filter criteria\r\n   * @returns {boolean}\r\n   */\r\n  static matchesFilters(record, filters) {\r\n    for (const [key, value] of Object.entries(filters)) {\r\n      if (key === '$and' || key === '$or') {\r\n        // Handle nested compound operators\r\n        if (!this.matchesCompoundFilters(record, { [key]: value })) {\r\n          return false;\r\n        }\r\n      } else if (typeof value === 'object' && value !== null) {\r\n        // Operator-based filter\r\n        if (!this.evaluateOperator(record[key], value)) {\r\n          return false;\r\n        }\r\n      } else {\r\n        // Equality filter\r\n        if (record[key] !== value) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Evaluates operator-based conditions\r\n   * @param {*} fieldValue - Value from the record\r\n   * @param {Object} operator - Operator object (e.g., { $gt: 5 })\r\n   * @returns {boolean}\r\n   */\r\n  static evaluateOperator(fieldValue, operator) {\r\n    const [op, value] = Object.entries(operator)[0];\r\n\r\n    switch (op) {\r\n      case '$gt':\r\n        return fieldValue > value;\r\n      case '$gte':\r\n        return fieldValue >= value;\r\n      case '$lt':\r\n        return fieldValue < value;\r\n      case '$lte':\r\n        return fieldValue <= value;\r\n      case '$eq':\r\n        return fieldValue === value;\r\n      case '$ne':\r\n        return fieldValue !== value;\r\n      case '$regex':\r\n        return new RegExp(value).test(fieldValue);\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n}","import ConnectionManager from './ConnectionManager.js';\r\nimport SchemaManager from './SchemaManager.js';\r\nimport TransactionManager from './TransactionManager.js';\r\nimport QueryEngine from './QueryEngine.js';\r\n\r\n/**\r\n * Main IndexedDB wrapper class\r\n */\r\nexport default class IDBWrapper {\r\n  constructor(dbName, version, schema, migrations = []) {\r\n    // Validate schema upfront\r\n    SchemaManager.validateSchema(schema);\r\n\r\n    this.dbName = dbName;\r\n    this.version = version;\r\n    this.schema = schema;\r\n    this.migrations = migrations;\r\n\r\n    this.connectionManager = new ConnectionManager(dbName, version, schema, migrations);\r\n  }\r\n\r\n  /**\r\n   * Opens the database connection\r\n   * @returns {Promise<IDBDatabase>}\r\n   */\r\n  async open() {\r\n    return this.connectionManager.open();\r\n  }\r\n\r\n  /**\r\n   * Closes the database connection\r\n   */\r\n  close() {\r\n    this.connectionManager.close();\r\n  }\r\n\r\n  /**\r\n   * Checks if the database is open\r\n   * @returns {boolean}\r\n   */\r\n  isOpen() {\r\n    return this.connectionManager.isOpen();\r\n  }\r\n\r\n  /**\r\n   * Gets the database instance\r\n   * @returns {IDBDatabase|null}\r\n   */\r\n  getDatabase() {\r\n    return this.connectionManager.getDatabase();\r\n  }\r\n\r\n  /**\r\n   * Creates a new record\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} data - Data to store\r\n   * @returns {Promise} Resolves with the key\r\n   */\r\n  async create(storeName, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.add(data));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads a record by key\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves with the record or undefined\r\n   */\r\n  async read(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readonly', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.get(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Updates a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @param {Object} data - Updated data\r\n   * @returns {Promise} Resolves when updated\r\n   */\r\n  async update(storeName, key, data) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      return new Promise((resolve, reject) => {\r\n        const getRequest = store.get(key);\r\n        getRequest.onsuccess = () => {\r\n          const existing = getRequest.result;\r\n          if (!existing) {\r\n            reject(new Error('Record not found'));\r\n            return;\r\n          }\r\n          const updatedData = { ...existing, ...data };\r\n          const putRequest = store.put(updatedData);\r\n          putRequest.onsuccess = () => resolve();\r\n          putRequest.onerror = () => reject(new TransactionError('Put failed', putRequest.error));\r\n        };\r\n        getRequest.onerror = () => reject(new TransactionError('Get failed', getRequest.error));\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Deletes a record\r\n   * @param {string} storeName - Object store name\r\n   * @param {*} key - Record key\r\n   * @returns {Promise} Resolves when deleted\r\n   */\r\n  async delete(storeName, key) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n      return TransactionManager.promisifyRequest(store.delete(key));\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Queries records with filters\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options (limit, offset, sort)\r\n   * @returns {Promise<Array>} Matching records\r\n   */\r\n  async query(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.query(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Analyzes a query plan without executing it\r\n   * @param {string} storeName - Object store name\r\n   * @param {Object} filters - Query filters\r\n   * @param {Object} options - Query options\r\n   * @returns {Promise<Object>} Query analysis with cost estimation\r\n   */\r\n  async analyzeQuery(storeName, filters = {}, options = {}) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return QueryEngine.analyzeQueryPlan(db, storeName, filters, options);\r\n  }\r\n\r\n  /**\r\n   * Performs bulk operations\r\n   * @param {string} storeName - Object store name\r\n   * @param {Array} operations - Array of operations\r\n   * @returns {Promise<Array>} Results of operations\r\n   */\r\n  async bulk(storeName, operations) {\r\n    const db = this.getDatabase();\r\n    if (!db) throw new Error('Database not open');\r\n\r\n    return TransactionManager.execute(db, storeName, 'readwrite', (transaction) => {\r\n      const store = transaction.objectStore(storeName);\r\n\r\n      const promises = operations.map(op => {\r\n        switch (op.type) {\r\n          case 'create':\r\n            return TransactionManager.promisifyRequest(store.add(op.data));\r\n          case 'update':\r\n            return TransactionManager.promisifyRequest(store.put(op.data, op.id));\r\n          case 'delete':\r\n            return TransactionManager.promisifyRequest(store.delete(op.id));\r\n          default:\r\n            throw new Error(`Unknown operation type: ${op.type}`);\r\n        }\r\n      });\r\n\r\n      return Promise.all(promises);\r\n    });\r\n  }\r\n}"],"names":["IDBError","Error","constructor","message","originalError","super","this","name","ConnectionError","SchemaError","MigrationError","TransactionError","SchemaManager","validateSchema","schema","stores","storeName","storeConfig","Object","entries","keyPath","indexes","indexName","indexConfig","unique","createSchema","db","objectStoreNames","contains","store","createObjectStore","autoIncrement","createIndex","checkSchemaConsistency","keys","TransactionManager","execute","storeNames","mode","operation","Promise","resolve","reject","transaction","operationResult","onerror","error","onabort","then","result","oncomplete","catch","promisifyRequest","request","onsuccess","console","MigrationManager","runMigrations","migrations","fromVersion","toVersion","i","migrationIndex","ConnectionManager","dbName","version","oldVersion","open","indexedDB","globalThis","window","onupgradeneeded","event","target","async","close","isOpen","getDatabase","QueryEngine","query","filters","options","objectStore","queryPlan","analyzeQuery","compoundFilters","executeCompoundQuery","canUseIndex","executeIndexQuery","executeFullScanQuery","analyzeQueryPlan","plan","keyRange","postFilters","sortField","sort","limit","offset","estimatedCost","optimizationNotes","length","estimateFullScanCost","push","$and","$or","field","value","findIndexForField","canUseIndexForFilter","createKeyRange","estimateIndexQueryCost","filterValue","op","includes","indexNames","index","operators","IDBKeyRange","only","val","lowerBound","upperBound","results","tempResults","skipped","openCursor","cursor","matchesFilters","continue","applySortingAndPagination","matchesCompoundFilters","processedResults","direction","a","b","aVal","bVal","slice","record","every","condition","values","some","key","evaluateOperator","fieldValue","operator","RegExp","test","IDBWrapper","connectionManager","create","data","add","read","get","update","getRequest","existing","updatedData","putRequest","put","delete","bulk","operations","promises","map","type","id","all"],"mappings":"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"}