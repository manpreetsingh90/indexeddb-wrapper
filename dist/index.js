!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).IDBWrapper={})}(this,function(e){"use strict";class t extends Error{constructor(e,t=null){super(e),this.name="IDBError",this.originalError=t}}class r extends t{constructor(e,t=null){super(e,t),this.name="ConnectionError"}}class n extends t{constructor(e,t=null){super(e,t),this.name="SchemaError"}}class o extends t{constructor(e,t=null){super(e,t),this.name="MigrationError"}}class s extends t{constructor(e,t=null){super(e,t),this.name="TransactionError",this.code="ERR_TRANSACTION_FAILED"}}class a extends s{constructor(e="Transaction became inactive",t=null){super(e,t),this.name="TransactionInactiveError",this.code="ERR_TRANSACTION_INACTIVE"}}class i extends s{constructor(e,t=null){super(`Transaction timeout after ${e}ms`,t),this.name="TransactionTimeoutError",this.code="ERR_TRANSACTION_TIMEOUT",this.timeout=e}}class c extends o{constructor(e,t=null){super(e,t),this.name="MigrationRollbackError",this.code="ERR_MIGRATION_ROLLBACK_FAILED"}}class l{static validateSchema(e){if(!e||"object"!=typeof e)throw new n("Schema must be an object");if(!e.stores||"object"!=typeof e.stores)throw new n("Schema must have a stores property");for(const[t,r]of Object.entries(e.stores)){if(!r||"object"!=typeof r)throw new n(`Store ${t} configuration must be an object`);if(!r.keyPath)throw new n(`Store ${t} must have a keyPath`);if(r.indexes){if("object"!=typeof r.indexes)throw new n(`Indexes for store ${t} must be an object`);for(const[e,o]of Object.entries(r.indexes)){if("object"!=typeof o)throw new n(`Index ${e} in store ${t} must be an object`);!o.keyPath&&o.unique}}}}static createSchema(e,t){this.validateSchema(t),this.createMigrationStore(e);for(const[r,n]of Object.entries(t.stores))if(!e.objectStoreNames.contains(r)){const t=e.createObjectStore(r,{keyPath:n.keyPath,autoIncrement:n.autoIncrement||!1});if(n.indexes)for(const[e,r]of Object.entries(n.indexes)){const n=r.keyPath||e;t.createIndex(e,n,{unique:r.unique||!1})}}}static createMigrationStore(e){const t="_migration_meta";e.objectStoreNames.contains(t)||e.createObjectStore(t,{keyPath:"id"})}static checkSchemaConsistency(e,t){for(const r of Object.keys(t.stores))if(!e.objectStoreNames.contains(r))return!1;return!0}}class u{static async execute(e,t,r,n,o={}){const{timeout:c=5e3,strictAsync:l=!0}=o;return new Promise((o,u)=>{const d=e.transaction(t,r);let m,h=!1;c>0&&(m=setTimeout(()=>{if(!h&&"active"===d.readyState)try{d.abort(),u(new i(c))}catch(e){u(new i(c))}},c)),d.onerror=()=>{h=!0,m&&clearTimeout(m),u(new s("Transaction failed",d.error))},d.onabort=()=>{h=!0,m&&clearTimeout(m),d.error&&"InvalidStateError"===d.error.name?u(new a("Transaction became inactive during operation")):u(new s("Transaction aborted"))};const g=new Set;(async e=>{try{return await this.executeWithSafety(e,n,{strictAsync:l,activePromises:g,transaction:d})}catch(e){throw new s("Operation failed",e)}})(d).then(e=>{d.oncomplete=()=>{h=!0,m&&clearTimeout(m),o(e)}}).catch(e=>{h=!0,m&&clearTimeout(m),u(e)})})}static async executeWithSafety(e,t,r){const{strictAsync:n,activePromises:o,transaction:s}=r,a=t(this.createMonitoredTransaction(e,r));if(a&&"function"==typeof a.then){o.add(a);try{const e=await a;return o.delete(a),e}catch(e){throw o.delete(a),e}}return a}static createMonitoredTransaction(e,t){return new Proxy(e,{get:(e,r)=>"objectStore"===r?r=>{if(e.error)throw new s("Transaction is in error state",e.error);if("versionchange"===e.mode);else if("finished"===e.readyState)throw new a("Transaction has already finished");try{const n=e.objectStore(r);return u.createMonitoredObjectStore(n,t)}catch(e){if("InvalidStateError"===e.name)throw new a("Cannot access object store - transaction is inactive");throw e}}:e[r]})}static createMonitoredObjectStore(e,t){const{strictAsync:r,activePromises:n}=t;return new Proxy(e,{get:(e,t)=>"function"==typeof e[t]?(...o)=>{const a=e[t](...o);if(a&&"function"==typeof a.then){if(r&&n.size>0)throw new s("Cannot start new async operation while another is pending. Use withTransaction() for complex async operations.");n.add(a),a.catch(()=>{n.delete(a)}).finally(()=>{n.delete(a)})}return a}:e[t]})}static promisifyRequest(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>{console.error("IDBRequest failed:",e.error.name,e.error.message),r(new s(`Request failed: ${e.error.name} - ${e.error.message}`,e.error))}})}}class d{static MIGRATION_STORE="_migration_meta";static async runMigrations(e,t,r,n,o=[]){if(!t||r>=n)return;await this.ensureMigrationStore(e);const s=await this.getCompletedMigrations(e),a=this.getPendingMigrations(t,r,n,s);if(0!==a.length){console.log(`Running ${a.length} pending migrations...`);for(const t of a)await this.runMigrationSafely(e,t,o);console.log("All migrations completed successfully")}else console.log("All migrations already completed")}static async ensureMigrationStore(e){e.objectStoreNames.contains(this.MIGRATION_STORE)||console.warn("Migration metadata store not found. This should be created during schema upgrade.")}static async getCompletedMigrations(e){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(t=>{const r=e.objectStore(this.MIGRATION_STORE).getAll();r.onsuccess=()=>{const e=r.result.filter(e=>"completed"===e.status).map(e=>e.id);t(e)},r.onerror=()=>t([])})):[]}static getPendingMigrations(e,t,r,n){return e.filter(e=>{const o=e.version||e.id;return o>t&&o<=r&&!n.includes(e.id)}).sort((e,t)=>(e.version||e.id)-(t.version||t.id))}static async runMigrationSafely(e,t,r=[]){const n=t.id,s=Date.now();console.log(`Starting migration: ${n}`);const a=await this.getMigrationStatus(e,n);if("in_progress"===a)return console.log(`Migration ${n} already in progress, attempting resume...`),this.resumeMigration(e,t,r);if("completed"!==a){await this.setMigrationStatus(e,n,"in_progress",{startTime:s});try{await this.executeMigrationWithCheckpointing(e,t,r);const o=Date.now();await this.setMigrationStatus(e,n,"completed",{startTime:s,endTime:o,duration:o-s}),console.log(`Migration ${n} completed successfully in ${o-s}ms`)}catch(a){if(console.error(`Migration ${n} failed:`,a),await this.setMigrationStatus(e,n,"failed",{startTime:s,error:a.message,stack:a.stack}),t.rollback)try{console.log(`Attempting rollback for migration ${n}...`),await this.rollbackMigration(e,t,r),await this.setMigrationStatus(e,n,"rolled_back",{startTime:s,rollbackTime:Date.now(),originalError:a.message}),console.log(`Rollback completed for migration ${n}`)}catch(t){throw console.error(`Rollback failed for migration ${n}:`,t),await this.setMigrationStatus(e,n,"rollback_failed",{startTime:s,originalError:a.message,rollbackError:t.message}),new c(`Migration ${n} failed and rollback unsuccessful`,t)}throw new o(`Migration ${n} failed`,a)}}else console.log(`Migration ${n} already completed`)}static async executeMigrationWithCheckpointing(e,t,r=[]){const n=t.id;if(t.checkpointed&&"function"==typeof t.up){let r=await this.getMigrationCheckpoint(e,n)||0;const o=t.batchSize||1e3;for(;;){const s=await t.up(e,r,o);if(s.completed)break;r=s.nextCheckpoint,await this.setMigrationCheckpoint(e,n,r),await new Promise(e=>setTimeout(e,0))}}else{const n=r.length>0?r:[this.MIGRATION_STORE];await u.execute(e,n,"readwrite",r=>t.up(e,r))}}static async resumeMigration(e,t,r=[]){const n=t.id,s=await this.getMigrationCheckpoint(e,n);if(null===s||!t.checkpointed)throw await this.setMigrationStatus(e,n,"failed",{error:"Migration interrupted and cannot be resumed"}),new o(`Migration ${n} was interrupted and cannot be resumed`);console.log(`Resuming migration ${n} from checkpoint ${s}`),await this.executeMigrationWithCheckpointing(e,t)}static async rollbackMigration(e,t,r=[]){const n=t.id;if(!t.rollback)throw new c(`No rollback function provided for migration ${n}`);{const n=r.length>0?r:[this.MIGRATION_STORE];await u.execute(e,n,"readwrite",r=>t.rollback(e,r))}}static async getMigrationStatus(e,t){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(r=>{const n=e.objectStore(this.MIGRATION_STORE).get(t);n.onsuccess=()=>{r(n.result?n.result.status:null)},n.onerror=()=>r(null)})):null}static async setMigrationStatus(e,t,r,n={}){if(!e.objectStoreNames.contains(this.MIGRATION_STORE))try{await this.createMigrationStore(e)}catch(e){return void console.warn("Could not create migration store:",e)}await u.execute(e,[this.MIGRATION_STORE],"readwrite",e=>new Promise((o,s)=>{const a=e.objectStore(this.MIGRATION_STORE),i={id:t,status:r,timestamp:Date.now(),...n},c=a.put(i);c.onsuccess=()=>o(),c.onerror=()=>s(c.error)}))}static async getMigrationCheckpoint(e,t){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(r=>{const n=e.objectStore(this.MIGRATION_STORE).get(`${t}_checkpoint`);n.onsuccess=()=>{r(n.result?n.result.checkpoint:null)},n.onerror=()=>r(null)})):null}static async setMigrationCheckpoint(e,t,r){e.objectStoreNames.contains(this.MIGRATION_STORE)&&await u.execute(e,[this.MIGRATION_STORE],"readwrite",e=>new Promise((n,o)=>{const s=e.objectStore(this.MIGRATION_STORE),a={id:`${t}_checkpoint`,checkpoint:r,timestamp:Date.now()},i=s.put(a);i.onsuccess=()=>n(),i.onerror=()=>o(i.error)}))}static async createMigrationStore(e){e.version>1&&console.warn("Migration store should be created during schema upgrade")}}class m{constructor(e,t,r,n=[]){this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.db=null,this.oldVersion=0}open(){return new Promise((e,t)=>{const n=globalThis.indexedDB||window?.indexedDB;if(!n)return void t(new r("IndexedDB not supported"));const o=n.open(this.dbName,this.version);o.onerror=()=>{t(new r("Failed to open database",o.error))},o.onupgradeneeded=e=>{this.db=e.target.result,this.oldVersion=e.oldVersion,l.createSchema(this.db,this.schema)},o.onsuccess=async()=>{if(this.db=o.result,this.oldVersion<this.version)try{const e=this.normalizeMigrations(this.migrations),t=Object.keys(this.schema.stores||{});await d.runMigrations(this.db,e,this.oldVersion,this.version,t)}catch(e){return void t(e)}e(this.db)}})}close(){this.db&&(this.db.close(),this.db=null)}isOpen(){return null!==this.db}getDatabase(){return this.db}normalizeMigrations(e){return e&&Array.isArray(e)?e.map((e,t)=>e&&"object"==typeof e&&e.id?e:"function"==typeof e?{id:`migration_${t+1}`,version:t+1,up:e,checkpointed:!1}:(console.warn(`Invalid migration at index ${t}:`,e),null)).filter(Boolean):[]}}class h{static async query(e,t,r={},n={}){return u.execute(e,t,"readonly",async e=>{const o=e.objectStore(t),s=this.analyzeQuery(r,o,n);return s.compoundFilters?this.executeCompoundQuery(o,s.compoundFilters,s):s.canUseIndex?this.executeIndexQuery(o,s):this.executeFullScanQuery(o,r,s)})}static async analyzeQueryPlan(e,t,r={},n={}){return u.execute(e,t,"readonly",async e=>{const o=e.objectStore(t);return this.analyzeQuery(r,o,n)})}static analyzeQuery(e,t,r){const n={canUseIndex:!1,indexName:null,keyRange:null,postFilters:{},compoundFilters:null,sortField:r.sort,limit:r.limit,offset:r.offset||0,estimatedCost:0,optimizationNotes:[]};if(0===Object.keys(e).length)return n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push("Full table scan - no filters provided"),n;if(e.$and||e.$or)return n.compoundFilters=e,n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push("Compound query requires full scan"),n;for(const[r,o]of Object.entries(e)){const e=this.findIndexForField(t,r);e&&this.canUseIndexForFilter(o)?(n.canUseIndex=!0,n.indexName=e,n.keyRange=this.createKeyRange(o),n.estimatedCost=this.estimateIndexQueryCost(t,e,o),n.optimizationNotes.push(`Using index '${e}' for field '${r}'`)):(n.postFilters[r]=o,n.canUseIndex?n.optimizationNotes.push(`Post-filtering required for field '${r}'`):(n.estimatedCost=this.estimateFullScanCost(t),n.optimizationNotes.push(`Full scan required for non-indexed field '${r}'`)))}return n}static estimateFullScanCost(e){return 100}static estimateIndexQueryCost(e,t,r){if("object"==typeof r&&null!==r){const e=Object.keys(r)[0];if(["$gt","$gte","$lt","$lte"].includes(e))return 20}return 5}static findIndexForField(e,t){if(e.keyPath===t)return null;for(const r of e.indexNames){if(e.index(r).keyPath===t)return r}return null}static canUseIndexForFilter(e){if("object"==typeof e&&null!==e){const t=Object.keys(e);return 1===t.length&&["$gt","$gte","$lt","$lte","$eq"].includes(t[0])}return!0}static createKeyRange(e){if("object"!=typeof e||null===e)return IDBKeyRange.only(e);{const[t,r]=Object.entries(e)[0];switch(t){case"$gt":return IDBKeyRange.lowerBound(r,!0);case"$gte":return IDBKeyRange.lowerBound(r);case"$lt":return IDBKeyRange.upperBound(r,!0);case"$lte":return IDBKeyRange.upperBound(r);case"$eq":return IDBKeyRange.only(r);default:return null}}}static async executeIndexQuery(e,t){const r=await new Promise((r,n)=>{const o=[];let s=0;const a=e.index(t.indexName).openCursor(t.keyRange);a.onsuccess=e=>{const n=e.target.result;n?((0===Object.keys(t.postFilters).length||this.matchesFilters(n.value,t.postFilters))&&(s<t.offset?s++:o.push(n.value)),n.continue()):r(o)},a.onerror=()=>n(a.error)});return this.applySortingAndPagination(r,t)}static async executeCompoundQuery(e,t,r={}){const n=await new Promise((r,n)=>{const o=[],s=e.openCursor();s.onsuccess=e=>{const n=e.target.result;n?(this.matchesCompoundFilters(n.value,t)&&o.push(n.value),n.continue()):r(o)},s.onerror=()=>n(s.error)});return this.applySortingAndPagination(n,r)}static async executeFullScanQuery(e,t,r={}){const n=await new Promise((r,n)=>{const o=[],s=e.openCursor();s.onsuccess=e=>{const n=e.target.result;n?(this.matchesFilters(n.value,t)&&o.push(n.value),n.continue()):r(o)},s.onerror=()=>n(s.error)});return this.applySortingAndPagination(n,r)}static applySortingAndPagination(e,t){let r=[...e];if(t.sortField){const[e,n]=Object.entries(t.sortField)[0];r.sort((t,r)=>{const o=t[e],s=r[e];return o<s?1===n?-1:1:o>s?1===n?1:-1:0})}return t.offset>0&&(r=r.slice(t.offset)),t.limit>0&&(r=r.slice(0,t.limit)),r}static matchesCompoundFilters(e,t){return t.$and?t.$and.every(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):t.$or?t.$or.some(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):this.matchesFilters(e,t)}static matchesFilters(e,t){for(const[r,n]of Object.entries(t))if("$and"===r||"$or"===r){if(!this.matchesCompoundFilters(e,{[r]:n}))return!1}else if("object"==typeof n&&null!==n){if(!this.evaluateOperator(e[r],n))return!1}else if(e[r]!==n)return!1;return!0}static evaluateOperator(e,t){const[r,n]=Object.entries(t)[0];switch(r){case"$gt":return e>n;case"$gte":return e>=n;case"$lt":return e<n;case"$lte":return e<=n;case"$eq":return e===n;case"$ne":return e!==n;case"$regex":return new RegExp(n).test(e);default:return!1}}}class g{static calculateObjectSize(e){if(null==e)return 0;if("object"!=typeof e)return"string"==typeof e?2*e.length:"boolean"==typeof e?1:"number"==typeof e?8:0;if(Array.isArray(e)){let t=0;for(const r of e)t+=this.calculateObjectSize(r);return t+8*e.length}const t=new WeakSet,r=e=>{if(null==e)return 0;if("object"!=typeof e)return this.calculateObjectSize(e);if(t.has(e))return 0;t.add(e);let n=0;if(Array.isArray(e)){for(const t of e)n+=r(t);n+=8*e.length}else{for(const t in e)e.hasOwnProperty(t)&&(n+=2*t.length,n+=r(e[t]));n+=16*Object.keys(e).length}return n};return r(e)}static measureCloningPerformance(e){const t=performance.now(),r=this.calculateObjectSize(e);try{const n=structuredClone(e);return{size:r,cloneTime:performance.now()-t,success:!0,cloned:n}}catch(e){return{size:r,cloneTime:performance.now()-t,success:!1,error:e.message}}}static assessPerformance(e){const t={small:1024,medium:1048576,large:10485760,huge:52428800};let r="small",n=null,o=null;return e>=t.huge?(r="huge",n="Extremely large object may cause performance issues",o="Consider breaking into smaller chunks or using external storage"):e>=t.large?(r="large",n="Large object may impact performance",o="Consider optimizing data structure or using pagination"):e>=t.medium&&(r="medium",n="Medium-sized object - monitor performance"),{level:r,size:e,sizeKB:Math.round(e/1024),sizeMB:Math.round(e/1048576*100)/100,warning:n,recommendation:o,thresholds:t}}static logPerformanceWarning(e,t,r={}){const n=this.measureCloningPerformance(t),o=this.assessPerformance(n.size);if(o.warning){const t=`[Performance Warning] ${e}: ${o.warning}\n        Size: ${o.sizeMB}MB (${o.sizeKB}KB)\n        ${o.recommendation||""}\n        Context: ${JSON.stringify(r)}`;if(console.warn(t),"huge"===o.level&&"development"===process.env.NODE_ENV)throw new Error(`Performance violation: ${t}`)}return{metrics:n,assessment:o,logged:!!o.warning}}static async monitorTransaction(e,t){const r=performance.now();try{const n=await t(),o={operation:e,duration:performance.now()-r,success:!0,timestamp:Date.now()};return o.duration>100&&console.warn(`[Slow Transaction] ${e} took ${o.duration.toFixed(2)}ms`),{result:n,metrics:o}}catch(t){const n={operation:e,duration:performance.now()-r,success:!1,error:t.message,timestamp:Date.now()};throw console.error(`[Transaction Error] ${e} failed after ${n.duration.toFixed(2)}ms:`,t),t}}static createMonitoredFunction(e,t){return async(...r)=>{const n=performance.now();try{for(let e=0;e<r.length;e++){const n=r[e];n&&"object"==typeof n&&this.logPerformanceWarning(`${t}(arg${e})`,n,{argIndex:e})}const o=await e.apply(this,r),s=performance.now()-n;return s>50&&console.warn(`[Slow Operation] ${t} took ${s.toFixed(2)}ms`),o}catch(e){const r=performance.now()-n;throw console.error(`[Operation Error] ${t} failed after ${r.toFixed(2)}ms:`,e),e}}}static getPerformanceStats(){return{timestamp:Date.now(),memory:void 0!==performance.memory?{used:performance.memory.usedJSHeapSize,total:performance.memory.totalJSHeapSize,limit:performance.memory.jsHeapSizeLimit}:null,timing:performance.timing?{navigationStart:performance.timing.navigationStart,loadEventEnd:performance.timing.loadEventEnd,domContentLoaded:performance.timing.domContentLoadedEventEnd-performance.timing.navigationStart}:null}}}e.ConnectionError=r,e.IDBError=t,e.IDBWrapper=class{constructor(e,t,r,n=[]){l.validateSchema(r),this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.connectionManager=new m(e,t,r,n)}async open(){return this.connectionManager.open()}close(){this.connectionManager.close()}isOpen(){return this.connectionManager.isOpen()}getDatabase(){return this.connectionManager.getDatabase()}async create(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return g.logPerformanceWarning("IDBWrapper.create",t,{storeName:e}),g.monitorTransaction(`create(${e})`,()=>u.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return u.promisifyRequest(n.add(t))})).then(e=>e.result)}async read(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return u.execute(r,e,"readonly",r=>{const n=r.objectStore(e);return u.promisifyRequest(n.get(t))})}async update(e,t,r){const n=this.getDatabase();if(!n)throw new Error("Database not open");return g.logPerformanceWarning("IDBWrapper.update",r,{storeName:e,key:t}),g.monitorTransaction(`update(${e})`,()=>u.execute(n,e,"readwrite",n=>{const o=n.objectStore(e);return new Promise((e,n)=>{const s=o.get(t);s.onsuccess=()=>{const t=s.result;if(!t)return void n(new Error("Record not found"));const a={...t,...r},i=o.put(a);i.onsuccess=()=>e(),i.onerror=()=>n(new TransactionError("Put failed",i.error))},s.onerror=()=>n(new TransactionError("Get failed",s.error))})})).then(e=>e.result)}async delete(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return u.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return u.promisifyRequest(n.delete(t))})}async query(e,t={},r={}){const n=this.getDatabase();if(!n)throw new Error("Database not open");return g.monitorTransaction(`query(${e})`,()=>h.query(n,e,t,r)).then(e=>e.result)}async analyzeQuery(e,t={},r={}){const n=this.getDatabase();if(!n)throw new Error("Database not open");return h.analyzeQueryPlan(n,e,t,r)}async bulk(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");const n=t.reduce((e,t)=>e+g.calculateObjectSize(t.data||{}),0);return g.logPerformanceWarning("IDBWrapper.bulk",{operations:t,totalSize:n},{storeName:e,operationCount:t.length}),g.monitorTransaction(`bulk(${e}, ${t.length} ops)`,()=>u.execute(r,e,"readwrite",r=>{const n=r.objectStore(e),o=t.map(e=>{switch(e.type){case"create":return u.promisifyRequest(n.add(e.data));case"update":return u.promisifyRequest(n.put(e.data,e.id));case"delete":return u.promisifyRequest(n.delete(e.id));default:throw new Error(`Unknown operation type: ${e.type}`)}});return Promise.all(o)})).then(e=>e.result)}async withTransaction(e,t,r,n={}){const o=this.getDatabase();if(!o)throw new Error("Database not open");const s={timeout:n.timeout||5e3,strictAsync:!1!==n.strictAsync,...n};return u.execute(o,e,t,r,s)}async safeBulk(e,t,r={}){return this.withTransaction(e,"readwrite",async r=>{const n=r.objectStore(e),o=[];for(const e of t){let t;switch(e.type){case"create":t=await u.promisifyRequest(n.add(e.data));break;case"update":t=await u.promisifyRequest(n.put(e.data,e.id));break;case"delete":t=await u.promisifyRequest(n.delete(e.id));break;default:throw new Error(`Unknown operation type: ${e.type}`)}o.push(t)}return o},r)}},e.MigrationError=o,e.SchemaError=n,e.TransactionError=s,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
