!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).IDBWrapper={})}(this,function(e){"use strict";class t extends Error{constructor(e,t=null){super(e),this.name="IDBError",this.originalError=t}}class r extends t{constructor(e,t=null){super(e,t),this.name="ConnectionError"}}class o extends t{constructor(e,t=null){super(e,t),this.name="SchemaError"}}class a extends t{constructor(e,t=null){super(e,t),this.name="MigrationError"}}class n extends t{constructor(e,t=null){super(e,t),this.name="TransactionError",this.code="ERR_TRANSACTION_FAILED"}}class i extends n{constructor(e="Transaction became inactive",t=null){super(e,t),this.name="TransactionInactiveError",this.code="ERR_TRANSACTION_INACTIVE"}}class s extends n{constructor(e,t=null){super(`Transaction timeout after ${e}ms`,t),this.name="TransactionTimeoutError",this.code="ERR_TRANSACTION_TIMEOUT",this.timeout=e}}class c extends a{constructor(e,t=null){super(e,t),this.name="MigrationRollbackError",this.code="ERR_MIGRATION_ROLLBACK_FAILED"}}class l{static validateSchema(e){if(!e||"object"!=typeof e)throw new o("Schema must be an object");if(!e.stores||"object"!=typeof e.stores)throw new o("Schema must have a stores property");for(const[t,r]of Object.entries(e.stores)){if(!r||"object"!=typeof r)throw new o(`Store ${t} configuration must be an object`);if(!r.keyPath)throw new o(`Store ${t} must have a keyPath`);if(r.indexes){if("object"!=typeof r.indexes)throw new o(`Indexes for store ${t} must be an object`);for(const[e,a]of Object.entries(r.indexes)){if("object"!=typeof a)throw new o(`Index ${e} in store ${t} must be an object`);!a.keyPath&&a.unique}}}}static createSchema(e,t){this.validateSchema(t),this.createMigrationStore(e);for(const[r,o]of Object.entries(t.stores))if(!e.objectStoreNames.contains(r)){const t=e.createObjectStore(r,{keyPath:o.keyPath,autoIncrement:o.autoIncrement||!1});if(o.indexes)for(const[e,r]of Object.entries(o.indexes)){const o=r.keyPath||e;t.createIndex(e,o,{unique:r.unique||!1})}}}static createMigrationStore(e){const t="_migration_meta";e.objectStoreNames.contains(t)||e.createObjectStore(t,{keyPath:"id"})}static checkSchemaConsistency(e,t){for(const r of Object.keys(t.stores))if(!e.objectStoreNames.contains(r))return!1;return!0}}class u{static async execute(e,t,r,o,a={}){const{timeout:c=5e3,strictAsync:l=!0}=a;return new Promise((a,u)=>{const d=e.transaction(t,r);let h,m=!1;c>0&&(h=setTimeout(()=>{if(!m&&"active"===d.readyState)try{d.abort(),u(new s(c))}catch(e){u(new s(c))}},c)),d.onerror=()=>{m=!0,h&&clearTimeout(h),u(new n("Transaction failed",d.error))},d.onabort=()=>{m=!0,h&&clearTimeout(h),d.error&&"InvalidStateError"===d.error.name?u(new i("Transaction became inactive during operation")):u(new n("Transaction aborted"))};const p=new Set;(async e=>{try{return await this.executeWithSafety(e,o,{strictAsync:l,activePromises:p,transaction:d})}catch(e){throw new n("Operation failed",e)}})(d).then(e=>{d.oncomplete=()=>{m=!0,h&&clearTimeout(h),a(e)}}).catch(e=>{m=!0,h&&clearTimeout(h),u(e)})})}static async executeWithSafety(e,t,r){const{strictAsync:o,activePromises:a,transaction:n}=r,i=t(this.createMonitoredTransaction(e,r));if(i&&"function"==typeof i.then){a.add(i);try{const e=await i;return a.delete(i),e}catch(e){throw a.delete(i),e}}return i}static createMonitoredTransaction(e,t){return new Proxy(e,{get:(e,r)=>"objectStore"===r?r=>{if(e.error)throw new n("Transaction is in error state",e.error);if("versionchange"===e.mode);else if("finished"===e.readyState)throw new i("Transaction has already finished");try{const o=e.objectStore(r);return u.createMonitoredObjectStore(o,t)}catch(e){if("InvalidStateError"===e.name)throw new i("Cannot access object store - transaction is inactive");throw e}}:e[r]})}static createMonitoredObjectStore(e,t){const{strictAsync:r,activePromises:o}=t;return new Proxy(e,{get:(e,t)=>"function"==typeof e[t]?(...a)=>{const i=e[t](...a);if(i&&"function"==typeof i.then){if(r&&o.size>0)throw new n("Cannot start new async operation while another is pending. Use withTransaction() for complex async operations.");o.add(i),i.catch(()=>{o.delete(i)}).finally(()=>{o.delete(i)})}return i}:e[t]})}static promisifyRequest(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>{console.error("IDBRequest failed:",e.error.name,e.error.message),r(new n(`Request failed: ${e.error.name} - ${e.error.message}`,e.error))}})}}class d{static MIGRATION_STORE="_migration_meta";static async runMigrations(e,t,r,o,a=[]){if(!t||r>=o)return;await this.ensureMigrationStore(e);const n=await this.getCompletedMigrations(e),i=this.getPendingMigrations(t,r,o,n);if(0!==i.length){console.log(`Running ${i.length} pending migrations...`);for(const t of i)await this.runMigrationSafely(e,t,a);console.log("All migrations completed successfully")}else console.log("All migrations already completed")}static async ensureMigrationStore(e){e.objectStoreNames.contains(this.MIGRATION_STORE)||console.warn("Migration metadata store not found. This should be created during schema upgrade.")}static async getCompletedMigrations(e){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(t=>{const r=e.objectStore(this.MIGRATION_STORE).getAll();r.onsuccess=()=>{const e=r.result.filter(e=>"completed"===e.status).map(e=>e.id);t(e)},r.onerror=()=>t([])})):[]}static getPendingMigrations(e,t,r,o){return e.filter(e=>{const a=e.version||e.id;return a>t&&a<=r&&!o.includes(e.id)}).sort((e,t)=>(e.version||e.id)-(t.version||t.id))}static async runMigrationSafely(e,t,r=[]){const o=t.id,n=Date.now();console.log(`Starting migration: ${o}`);const i=await this.getMigrationStatus(e,o);if("in_progress"===i)return console.log(`Migration ${o} already in progress, attempting resume...`),this.resumeMigration(e,t,r);if("completed"!==i){await this.setMigrationStatus(e,o,"in_progress",{startTime:n});try{await this.executeMigrationWithCheckpointing(e,t,r);const a=Date.now();await this.setMigrationStatus(e,o,"completed",{startTime:n,endTime:a,duration:a-n}),console.log(`Migration ${o} completed successfully in ${a-n}ms`)}catch(i){if(console.error(`Migration ${o} failed:`,i),await this.setMigrationStatus(e,o,"failed",{startTime:n,error:i.message,stack:i.stack}),t.rollback)try{console.log(`Attempting rollback for migration ${o}...`),await this.rollbackMigration(e,t,r),await this.setMigrationStatus(e,o,"rolled_back",{startTime:n,rollbackTime:Date.now(),originalError:i.message}),console.log(`Rollback completed for migration ${o}`)}catch(t){throw console.error(`Rollback failed for migration ${o}:`,t),await this.setMigrationStatus(e,o,"rollback_failed",{startTime:n,originalError:i.message,rollbackError:t.message}),new c(`Migration ${o} failed and rollback unsuccessful`,t)}throw new a(`Migration ${o} failed`,i)}}else console.log(`Migration ${o} already completed`)}static async executeMigrationWithCheckpointing(e,t,r=[]){const o=t.id;if(t.checkpointed&&"function"==typeof t.up){let r=await this.getMigrationCheckpoint(e,o)||0;const a=t.batchSize||1e3;for(;;){const n=await t.up(e,r,a);if(n.completed)break;r=n.nextCheckpoint,await this.setMigrationCheckpoint(e,o,r),await new Promise(e=>setTimeout(e,0))}}else{const o=r.length>0?r:[this.MIGRATION_STORE];await u.execute(e,o,"readwrite",r=>t.up(e,r))}}static async resumeMigration(e,t,r=[]){const o=t.id,n=await this.getMigrationCheckpoint(e,o);if(null===n||!t.checkpointed)throw await this.setMigrationStatus(e,o,"failed",{error:"Migration interrupted and cannot be resumed"}),new a(`Migration ${o} was interrupted and cannot be resumed`);console.log(`Resuming migration ${o} from checkpoint ${n}`),await this.executeMigrationWithCheckpointing(e,t)}static async rollbackMigration(e,t,r=[]){const o=t.id;if(!t.rollback)throw new c(`No rollback function provided for migration ${o}`);{const o=r.length>0?r:[this.MIGRATION_STORE];await u.execute(e,o,"readwrite",r=>t.rollback(e,r))}}static async getMigrationStatus(e,t){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(r=>{const o=e.objectStore(this.MIGRATION_STORE).get(t);o.onsuccess=()=>{r(o.result?o.result.status:null)},o.onerror=()=>r(null)})):null}static async setMigrationStatus(e,t,r,o={}){if(!e.objectStoreNames.contains(this.MIGRATION_STORE))try{await this.createMigrationStore(e)}catch(e){return void console.warn("Could not create migration store:",e)}await u.execute(e,[this.MIGRATION_STORE],"readwrite",e=>new Promise((a,n)=>{const i=e.objectStore(this.MIGRATION_STORE),s={id:t,status:r,timestamp:Date.now(),...o},c=i.put(s);c.onsuccess=()=>a(),c.onerror=()=>n(c.error)}))}static async getMigrationCheckpoint(e,t){return e.objectStoreNames.contains(this.MIGRATION_STORE)?u.execute(e,[this.MIGRATION_STORE],"readonly",e=>new Promise(r=>{const o=e.objectStore(this.MIGRATION_STORE).get(`${t}_checkpoint`);o.onsuccess=()=>{r(o.result?o.result.checkpoint:null)},o.onerror=()=>r(null)})):null}static async setMigrationCheckpoint(e,t,r){e.objectStoreNames.contains(this.MIGRATION_STORE)&&await u.execute(e,[this.MIGRATION_STORE],"readwrite",e=>new Promise((o,a)=>{const n=e.objectStore(this.MIGRATION_STORE),i={id:`${t}_checkpoint`,checkpoint:r,timestamp:Date.now()},s=n.put(i);s.onsuccess=()=>o(),s.onerror=()=>a(s.error)}))}static async createMigrationStore(e){e.version>1&&console.warn("Migration store should be created during schema upgrade")}}class h{constructor(e,t,r,o=[],a=null){this.dbName=e,this.version=t,this.schema=r,this.migrations=o,this.tabCoordinator=a,this.db=null,this.oldVersion=0}open(){return new Promise((e,t)=>{const o=globalThis.indexedDB||window?.indexedDB;if(!o)return void t(new r("IndexedDB not supported"));const a=o.open(this.dbName,this.version);a.onerror=()=>{t(new r("Failed to open database",a.error))},a.onupgradeneeded=e=>{this.db=e.target.result,this.oldVersion=e.oldVersion,this.tabCoordinator&&this.oldVersion<this.version&&this.tabCoordinator.announceMigrationStart(`upgrade-${this.oldVersion}-${this.version}`,this.version),l.createSchema(this.db,this.schema)},a.onsuccess=async()=>{if(this.db=a.result,this.oldVersion<this.version)try{const e=this.normalizeMigrations(this.migrations),t=Object.keys(this.schema.stores||{});await d.runMigrations(this.db,e,this.oldVersion,this.version,t),this.tabCoordinator&&this.tabCoordinator.announceMigrationComplete(`upgrade-${this.oldVersion}-${this.version}`,this.version)}catch(e){return void t(e)}e(this.db)}})}close(){this.db&&(this.db.close(),this.db=null)}isOpen(){return null!==this.db}getDatabase(){return this.db}normalizeMigrations(e){return e&&Array.isArray(e)?e.map((e,t)=>e&&"object"==typeof e&&e.id?e:"function"==typeof e?{id:`migration_${t+1}`,version:t+1,up:e,checkpointed:!1}:(console.warn(`Invalid migration at index ${t}:`,e),null)).filter(Boolean):[]}}class m{static async query(e,t,r={},o={}){return u.execute(e,t,"readonly",async e=>{const a=e.objectStore(t),n=this.analyzeQuery(r,a,o);return n.compoundFilters?this.executeCompoundQuery(a,n.compoundFilters,n):n.canUseIndex?this.executeIndexQuery(a,n):this.executeFullScanQuery(a,r,n)})}static async analyzeQueryPlan(e,t,r={},o={}){return u.execute(e,t,"readonly",async e=>{const a=e.objectStore(t);return this.analyzeQuery(r,a,o)})}static analyzeQuery(e,t,r){const o={canUseIndex:!1,indexName:null,keyRange:null,postFilters:{},compoundFilters:null,sortField:r.sort,limit:r.limit,offset:r.offset||0,estimatedCost:0,optimizationNotes:[]};if(0===Object.keys(e).length)return o.estimatedCost=this.estimateFullScanCost(t),o.optimizationNotes.push("Full table scan - no filters provided"),o;if(e.$and||e.$or)return o.compoundFilters=e,o.estimatedCost=this.estimateFullScanCost(t),o.optimizationNotes.push("Compound query requires full scan"),o;for(const[r,a]of Object.entries(e)){const e=this.findIndexForField(t,r);e&&this.canUseIndexForFilter(a)?(o.canUseIndex=!0,o.indexName=e,o.keyRange=this.createKeyRange(a),o.estimatedCost=this.estimateIndexQueryCost(t,e,a),o.optimizationNotes.push(`Using index '${e}' for field '${r}'`)):(o.postFilters[r]=a,o.canUseIndex?o.optimizationNotes.push(`Post-filtering required for field '${r}'`):(o.estimatedCost=this.estimateFullScanCost(t),o.optimizationNotes.push(`Full scan required for non-indexed field '${r}'`)))}return o}static estimateFullScanCost(e){return 100}static estimateIndexQueryCost(e,t,r){if("object"==typeof r&&null!==r){const e=Object.keys(r)[0];if(["$gt","$gte","$lt","$lte"].includes(e))return 20}return 5}static findIndexForField(e,t){if(e.keyPath===t)return null;for(const r of e.indexNames){if(e.index(r).keyPath===t)return r}return null}static canUseIndexForFilter(e){if("object"==typeof e&&null!==e){const t=Object.keys(e);return 1===t.length&&["$gt","$gte","$lt","$lte","$eq"].includes(t[0])}return!0}static createKeyRange(e){if("object"!=typeof e||null===e)return IDBKeyRange.only(e);{const[t,r]=Object.entries(e)[0];switch(t){case"$gt":return IDBKeyRange.lowerBound(r,!0);case"$gte":return IDBKeyRange.lowerBound(r);case"$lt":return IDBKeyRange.upperBound(r,!0);case"$lte":return IDBKeyRange.upperBound(r);case"$eq":return IDBKeyRange.only(r);default:return null}}}static async executeIndexQuery(e,t){const r=await new Promise((r,o)=>{const a=[];let n=0;const i=e.index(t.indexName).openCursor(t.keyRange);i.onsuccess=e=>{const o=e.target.result;o?((0===Object.keys(t.postFilters).length||this.matchesFilters(o.value,t.postFilters))&&(n<t.offset?n++:a.push(o.value)),o.continue()):r(a)},i.onerror=()=>o(i.error)});return this.applySortingAndPagination(r,t)}static async executeCompoundQuery(e,t,r={}){const o=await new Promise((r,o)=>{const a=[],n=e.openCursor();n.onsuccess=e=>{const o=e.target.result;o?(this.matchesCompoundFilters(o.value,t)&&a.push(o.value),o.continue()):r(a)},n.onerror=()=>o(n.error)});return this.applySortingAndPagination(o,r)}static async executeFullScanQuery(e,t,r={}){const o=await new Promise((r,o)=>{const a=[],n=e.openCursor();n.onsuccess=e=>{const o=e.target.result;o?(this.matchesFilters(o.value,t)&&a.push(o.value),o.continue()):r(a)},n.onerror=()=>o(n.error)});return this.applySortingAndPagination(o,r)}static applySortingAndPagination(e,t){let r=[...e];if(t.sortField){const[e,o]=Object.entries(t.sortField)[0];r.sort((t,r)=>{const a=t[e],n=r[e];return a<n?1===o?-1:1:a>n?1===o?1:-1:0})}return t.offset>0&&(r=r.slice(t.offset)),t.limit>0&&(r=r.slice(0,t.limit)),r}static matchesCompoundFilters(e,t){return t.$and?t.$and.every(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):t.$or?t.$or.some(t=>this.matchesFilters(e,{[Object.keys(t)[0]]:Object.values(t)[0]})):this.matchesFilters(e,t)}static matchesFilters(e,t){for(const[r,o]of Object.entries(t))if("$and"===r||"$or"===r){if(!this.matchesCompoundFilters(e,{[r]:o}))return!1}else if("object"==typeof o&&null!==o){if(!this.evaluateOperator(e[r],o))return!1}else if(e[r]!==o)return!1;return!0}static evaluateOperator(e,t){const[r,o]=Object.entries(t)[0];switch(r){case"$gt":return e>o;case"$gte":return e>=o;case"$lt":return e<o;case"$lte":return e<=o;case"$eq":return e===o;case"$ne":return e!==o;case"$regex":return new RegExp(o).test(e);default:return!1}}}class p{static calculateObjectSize(e){if(null==e)return 0;if("object"!=typeof e)return"string"==typeof e?2*e.length:"boolean"==typeof e?1:"number"==typeof e?8:0;if(Array.isArray(e)){let t=0;for(const r of e)t+=this.calculateObjectSize(r);return t+8*e.length}const t=new WeakSet,r=e=>{if(null==e)return 0;if("object"!=typeof e)return this.calculateObjectSize(e);if(t.has(e))return 0;t.add(e);let o=0;if(Array.isArray(e)){for(const t of e)o+=r(t);o+=8*e.length}else{for(const t in e)e.hasOwnProperty(t)&&(o+=2*t.length,o+=r(e[t]));o+=16*Object.keys(e).length}return o};return r(e)}static measureCloningPerformance(e){const t=performance.now(),r=this.calculateObjectSize(e);try{const o=structuredClone(e);return{size:r,cloneTime:performance.now()-t,success:!0,cloned:o}}catch(e){return{size:r,cloneTime:performance.now()-t,success:!1,error:e.message}}}static assessPerformance(e){const t={small:1024,medium:1048576,large:10485760,huge:52428800};let r="small",o=null,a=null;return e>=t.huge?(r="huge",o="Extremely large object may cause performance issues",a="Consider breaking into smaller chunks or using external storage"):e>=t.large?(r="large",o="Large object may impact performance",a="Consider optimizing data structure or using pagination"):e>=t.medium&&(r="medium",o="Medium-sized object - monitor performance"),{level:r,size:e,sizeKB:Math.round(e/1024),sizeMB:Math.round(e/1048576*100)/100,warning:o,recommendation:a,thresholds:t}}static logPerformanceWarning(e,t,r={}){const o=this.measureCloningPerformance(t),a=this.assessPerformance(o.size);if(a.warning){const t=`[Performance Warning] ${e}: ${a.warning}\n        Size: ${a.sizeMB}MB (${a.sizeKB}KB)\n        ${a.recommendation||""}\n        Context: ${JSON.stringify(r)}`;if(console.warn(t),"huge"===a.level&&"development"===process.env.NODE_ENV)throw new Error(`Performance violation: ${t}`)}return{metrics:o,assessment:a,logged:!!a.warning}}static async monitorTransaction(e,t){const r=performance.now();try{const o=await t(),a={operation:e,duration:performance.now()-r,success:!0,timestamp:Date.now()};return a.duration>100&&console.warn(`[Slow Transaction] ${e} took ${a.duration.toFixed(2)}ms`),{result:o,metrics:a}}catch(t){const o={operation:e,duration:performance.now()-r,success:!1,error:t.message,timestamp:Date.now()};throw console.error(`[Transaction Error] ${e} failed after ${o.duration.toFixed(2)}ms:`,t),t}}static createMonitoredFunction(e,t){return async(...r)=>{const o=performance.now();try{for(let e=0;e<r.length;e++){const o=r[e];o&&"object"==typeof o&&this.logPerformanceWarning(`${t}(arg${e})`,o,{argIndex:e})}const a=await e.apply(this,r),n=performance.now()-o;return n>50&&console.warn(`[Slow Operation] ${t} took ${n.toFixed(2)}ms`),a}catch(e){const r=performance.now()-o;throw console.error(`[Operation Error] ${t} failed after ${r.toFixed(2)}ms:`,e),e}}}static getPerformanceStats(){return{timestamp:Date.now(),memory:void 0!==performance.memory?{used:performance.memory.usedJSHeapSize,total:performance.memory.totalJSHeapSize,limit:performance.memory.jsHeapSizeLimit}:null,timing:performance.timing?{navigationStart:performance.timing.navigationStart,loadEventEnd:performance.timing.loadEventEnd,domContentLoaded:performance.timing.domContentLoadedEventEnd-performance.timing.navigationStart}:null}}}class f{constructor(e,t={}){this.dbName=e,this.options={channelName:`idb-${e}`,heartbeatInterval:5e3,lockTimeout:3e4,maxRetries:3,retryDelay:1e3,...t},this.channel=null,this.isLeader=!1,this.tabId=this.generateTabId(),this.heartbeatTimer=null,this.lockQueue=new Map,this.activeLocks=new Set,this.lastHeartbeat=Date.now(),this.init()}init(){try{this.channel=new BroadcastChannel(this.options.channelName),this.setupChannelListeners(),this.startHeartbeat(),this.announcePresence(),console.log(`[TabCoordinator] Initialized for database '${this.dbName}' with tab ID ${this.tabId}`)}catch(e){console.warn("[TabCoordinator] BroadcastChannel not supported, running in single-tab mode"),this.fallbackMode=!0}}generateTabId(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}setupChannelListeners(){this.channel&&(this.channel.onmessage=e=>{this.handleMessage(e.data)},window.addEventListener("beforeunload",()=>{this.announceDeparture()}),document.addEventListener("visibilitychange",()=>{document.hidden?this.announceInactive():this.announceActive()}))}handleMessage(e){const{type:t,tabId:r,data:o,timestamp:a}=e;if(r!==this.tabId)switch(t){case"presence":this.handlePresence(r,o);break;case"departure":this.handleDeparture(r);break;case"heartbeat":this.handleHeartbeat(r,a);break;case"lock_request":this.handleLockRequest(r,o);break;case"lock_release":this.handleLockRelease(r,o);break;case"lock_granted":this.handleLockGranted(o);break;case"lock_denied":this.handleLockDenied(o);break;case"migration_start":this.handleMigrationStart(r,o);break;case"migration_complete":this.handleMigrationComplete(r,o)}}startHeartbeat(){this.heartbeatTimer=setInterval(()=>{this.sendHeartbeat(),this.checkForDeadTabs()},this.options.heartbeatInterval)}sendHeartbeat(){this.broadcast({type:"heartbeat",tabId:this.tabId,timestamp:Date.now()})}checkForDeadTabs(){const e=Date.now(),t=3*this.options.heartbeatInterval;for(const[r,o]of this.lockQueue)e-o.lastSeen>t&&(console.warn(`[TabCoordinator] Cleaning up dead tab lock: ${r}`),this.lockQueue.delete(r),this.activeLocks.delete(r))}announcePresence(){this.broadcast({type:"presence",tabId:this.tabId,data:{userAgent:navigator.userAgent,url:window.location.href,timestamp:Date.now()}})}announceDeparture(){this.broadcast({type:"departure",tabId:this.tabId,timestamp:Date.now()}),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.channel&&this.channel.close()}announceActive(){this.broadcast({type:"presence",tabId:this.tabId,data:{active:!0,timestamp:Date.now()}})}announceInactive(){this.broadcast({type:"presence",tabId:this.tabId,data:{active:!1,timestamp:Date.now()}})}broadcast(e){this.channel&&!this.fallbackMode&&this.channel.postMessage(e)}handlePresence(e,t){this.updateTabLastSeen(e),this.lockQueue.has(e)||console.log(`[TabCoordinator] Tab ${e} joined`)}handleDeparture(e){console.log(`[TabCoordinator] Tab ${e} departed`),this.cleanupTabLocks(e)}handleHeartbeat(e,t){this.updateTabLastSeen(e)}updateTabLastSeen(e){for(const[t,r]of this.lockQueue)r.tabId===e&&(r.lastSeen=Date.now())}cleanupTabLocks(e){const t=[];for(const[r,o]of this.lockQueue)o.tabId===e&&t.push(r);for(const r of t)this.lockQueue.delete(r),this.activeLocks.delete(r),console.log(`[TabCoordinator] Released lock ${r} from departed tab ${e}`)}async requestLock(e,t={}){return this.fallbackMode?Promise.resolve():new Promise((r,o)=>{const a={id:e,tabId:this.tabId,timestamp:Date.now(),timeout:t.timeout||this.options.lockTimeout,resolve:r,reject:o};this.activeLocks.has(e)?r():(this.lockQueue.set(e,a),this.broadcast({type:"lock_request",tabId:this.tabId,data:{lockId:e,timeout:a.timeout}}),setTimeout(()=>{this.lockQueue.has(e)&&(this.lockQueue.delete(e),o(new Error(`Lock request timeout: ${e}`)))},a.timeout))})}releaseLock(e){this.fallbackMode||(this.activeLocks.delete(e),this.lockQueue.delete(e),this.broadcast({type:"lock_release",tabId:this.tabId,data:{lockId:e}}))}handleLockRequest(e,t){const{lockId:r}=t;this.activeLocks.has(r)?this.broadcast({type:"lock_denied",tabId:this.tabId,data:{lockId:r,requestingTab:e}}):this.broadcast({type:"lock_granted",tabId:this.tabId,data:{lockId:r,requestingTab:e}})}handleLockRelease(e,t){}handleLockGranted(e){const{lockId:t}=e,r=this.lockQueue.get(t);r&&r.tabId===this.tabId&&(this.activeLocks.add(t),r.resolve())}handleLockDenied(e){const{lockId:t}=e,r=this.lockQueue.get(t);r&&r.tabId===this.tabId&&this.retryLockRequest(r)}retryLockRequest(e){const{id:t,retryCount:r=0}=e;if(r>=this.options.maxRetries)return e.reject(new Error(`Lock request failed after ${this.options.maxRetries} retries: ${t}`)),void this.lockQueue.delete(t);e.retryCount=r+1;const o=this.options.retryDelay*Math.pow(2,r);setTimeout(()=>{this.broadcast({type:"lock_request",tabId:this.tabId,data:{lockId:t,timeout:e.timeout}})},o)}announceMigrationStart(e,t){this.broadcast({type:"migration_start",tabId:this.tabId,data:{migrationId:e,version:t,timestamp:Date.now()}})}announceMigrationComplete(e,t){this.broadcast({type:"migration_complete",tabId:this.tabId,data:{migrationId:e,version:t,timestamp:Date.now()}})}handleMigrationStart(e,t){console.log(`[TabCoordinator] Migration started in tab ${e}: ${t.migrationId} -> v${t.version}`)}handleMigrationComplete(e,t){console.log(`[TabCoordinator] Migration completed in tab ${e}: ${t.migrationId} -> v${t.version}`)}getStatus(){return{tabId:this.tabId,isLeader:this.isLeader,activeLocks:Array.from(this.activeLocks),queuedLocks:Array.from(this.lockQueue.keys()),fallbackMode:this.fallbackMode,channelSupported:!!this.channel}}destroy(){this.announceDeparture(),this.heartbeatTimer&&clearInterval(this.heartbeatTimer),this.channel&&this.channel.close()}}class b{static validateDatabaseName(e){if(!e||"string"!=typeof e)throw new Error("Database name must be a non-empty string");if(0===e.length||e.length>100)throw new Error("Database name must be between 1 and 100 characters");if(/[<>:"|?*\x00-\x1f]/.test(e))throw new Error("Database name contains invalid characters");if(["system","admin","root","config","settings"].includes(e.toLowerCase()))throw new Error("Database name is reserved");return!0}static validateStoreName(e){if(!e||"string"!=typeof e)throw new Error("Store name must be a non-empty string");if(0===e.length||e.length>100)throw new Error("Store name must be between 1 and 100 characters");if(!/^[a-zA-Z0-9_-]+$/.test(e))throw new Error("Store name must contain only letters, numbers, underscores, and hyphens");if(e.startsWith("_"))throw new Error("Store name cannot start with underscore");return!0}static validateKey(e){if(!["string","number","object"].includes(typeof e))throw new Error("Key must be a string, number, or object (for compound keys)");if("string"==typeof e&&e.length>1e3)throw new Error("String key is too long (max 1000 characters)");if("number"==typeof e&&(!isFinite(e)||isNaN(e)))throw new Error("Key cannot be NaN or infinite");if("object"==typeof e&&null!==e)if(Array.isArray(e)){if(0===e.length||e.length>10)throw new Error("Compound key array must have 1-10 elements");e.forEach((e,t)=>{try{this.validateKey(e)}catch(e){throw new Error(`Compound key element ${t}: ${e.message}`)}})}else this.validateObjectForSecurity(e,"key");return!0}static validateDataObject(e,t="data"){if(null==e)return!0;if("object"!=typeof e)throw new Error(`${t} must be an object`);this.validateObjectForSecurity(e,t);const r=this.estimateObjectSize(e);if(r>10485760)throw new Error(`${t} is too large (${Math.round(r/1024/1024)}MB)`);return!0}static validateObjectForSecurity(e,t="object"){if("object"!=typeof e||null===e)return!0;const r=["__proto__","prototype","constructor"];for(const o of r)if(o in e)throw new Error(`Dangerous property '${o}' found in ${t}`);const o=(e,a="")=>{if("object"==typeof e&&null!==e)for(const n in e)if(Object.prototype.hasOwnProperty.call(e,n)){const i=a?`${a}.${n}`:n;if(r.includes(n))throw new Error(`Dangerous property '${n}' found in ${t} at ${i}`);if(n.length>100)throw new Error(`Property name too long in ${t} at ${i}`);"object"==typeof e[n]&&null!==e[n]&&o(e[n],i)}};return o(e),!0}static sanitizeString(e,t={}){if("string"!=typeof e)return e;let r=e;return r=r.replace(/\x00/g,""),t.trim&&(r=r.trim()),t.maxLength&&r.length>t.maxLength&&(r=r.substring(0,t.maxLength)),r}static validateQueryFilters(e){if(null==e)return!0;if("object"!=typeof e)throw new Error("Query filters must be an object");const t=(e,r=0)=>{if(r>5)throw new Error("Query filters are too deeply nested");if("object"==typeof e&&null!==e)for(const o in e)Object.prototype.hasOwnProperty.call(e,o)&&t(e[o],r+1)};return t(e),this.validateObjectForSecurity(e,"query filters"),!0}static validateSchema(e){if(!e||"object"!=typeof e)throw new Error("Schema must be an object");if(!e.stores||"object"!=typeof e.stores)throw new Error("Schema must have a stores property");const t=Object.keys(e.stores);if(0===t.length)throw new Error("Schema must define at least one store");if(t.length>100)throw new Error("Schema cannot define more than 100 stores");for(const r of t){this.validateStoreName(r);const t=e.stores[r];if(!t||"object"!=typeof t)throw new Error(`Store '${r}' configuration must be an object`);if(t.indexes){if("object"!=typeof t.indexes)throw new Error(`Indexes for store '${r}' must be an object`);const e=Object.keys(t.indexes);if(e.length>50)throw new Error(`Store '${r}' cannot have more than 50 indexes`);for(const t of e)if(0===t.length||t.length>100)throw new Error(`Index name '${t}' in store '${r}' must be 1-100 characters`)}}return!0}static estimateObjectSize(e){if(null==e)return 0;if("string"==typeof e)return 2*e.length;if("boolean"==typeof e)return 1;if("number"==typeof e)return 8;if("object"!=typeof e)return 0;let t=0;const r=new WeakSet,o=e=>{if(null!=e&&"object"==typeof e&&!r.has(e))if(r.add(e),Array.isArray(e)){t+=8*e.length;for(const r of e)"string"==typeof r?t+=2*r.length:"object"==typeof r?o(r):t+=8}else for(const r in e)if(Object.prototype.hasOwnProperty.call(e,r)){t+=2*r.length;const a=e[r];"string"==typeof a?t+=2*a.length:"object"==typeof a?o(a):t+=8}};return o(e),t}static createSafeCopy(e){if(null==e)return e;try{return structuredClone(e)}catch(t){try{return JSON.parse(JSON.stringify(e))}catch(e){throw new Error("Cannot create safe copy of object")}}}static validateMigrationFunction(e){if("function"!=typeof e)throw new Error("Migration must be a function");const t=e.toString(),r=[/eval\s*\(/,/Function\s*\(/,/setTimeout\s*\(/,/setInterval\s*\(/,/XMLHttpRequest/,/fetch\s*\(/,/import\s*\(/,/require\s*\(/];for(const e of r)if(e.test(t))throw new Error("Migration function contains potentially dangerous code");return!0}static performSecurityAudit(e){const t={passed:!0,warnings:[],errors:[]};try{e.dbName&&this.validateDatabaseName(e.dbName),e.schema&&this.validateSchema(e.schema),e.storeName&&this.validateStoreName(e.storeName),void 0!==e.key&&this.validateKey(e.key),void 0!==e.data&&this.validateDataObject(e.data),e.filters&&this.validateQueryFilters(e.filters),e.migrations&&Array.isArray(e.migrations)&&e.migrations.forEach((e,r)=>{try{"function"==typeof e&&this.validateMigrationFunction(e)}catch(e){t.errors.push(`Migration ${r}: ${e.message}`)}})}catch(e){t.passed=!1,t.errors.push(e.message)}return t}}e.ConnectionError=r,e.IDBError=t,e.IDBWrapper=class{constructor(e,t,r,o=[],a={}){b.validateDatabaseName(e),b.validateSchema(r),o&&Array.isArray(o)&&o.forEach((e,t)=>{"function"==typeof e&&b.validateMigrationFunction(e)}),this.dbName=e,this.version=t,this.schema=r,this.migrations=o,this.options={enableTabCoordination:!0,enableSecurityValidation:!0,...a},this.options.enableTabCoordination&&"undefined"!=typeof BroadcastChannel&&(this.tabCoordinator=new f(e)),this.connectionManager=new h(e,t,r,o,this.tabCoordinator)}async open(){return this.connectionManager.open()}close(){this.connectionManager.close()}isOpen(){return this.connectionManager.isOpen()}getDatabase(){return this.connectionManager.getDatabase()}async withCoordination(e,t){if(!this.tabCoordinator)return t();await this.tabCoordinator.requestLock(e);try{return await t()}finally{this.tabCoordinator.releaseLock(e)}}getCoordinationStatus(){return this.tabCoordinator?this.tabCoordinator.getStatus():{enabled:!1,reason:"BroadcastChannel not supported or disabled"}}async create(e,t){return this.options.enableSecurityValidation&&(b.validateStoreName(e),b.validateDataObject(t,`create(${e}) data`)),this.withCoordination(`write-${e}`,async()=>{const r=this.getDatabase();if(!r)throw new Error("Database not open");const o=b.createSafeCopy(t);return p.logPerformanceWarning("IDBWrapper.create",o,{storeName:e}),p.monitorTransaction(`create(${e})`,()=>u.execute(r,e,"readwrite",t=>{const r=t.objectStore(e);return u.promisifyRequest(r.add(o))})).then(e=>e.result)})}async read(e,t){return this.options.enableSecurityValidation&&(b.validateStoreName(e),b.validateKey(t)),this.withCoordination(`read-${e}`,async()=>{const r=this.getDatabase();if(!r)throw new Error("Database not open");return p.monitorTransaction(`read(${e})`,()=>u.execute(r,e,"readonly",r=>{const o=r.objectStore(e);return u.promisifyRequest(o.get(t))})).then(e=>e.result)})}async update(e,t,r){return this.options.enableSecurityValidation&&(b.validateStoreName(e),b.validateKey(t),b.validateDataObject(r,`update(${e}) data`)),this.withCoordination(`write-${e}`,async()=>{const o=this.getDatabase();if(!o)throw new Error("Database not open");const a=b.createSafeCopy(r);return p.logPerformanceWarning("IDBWrapper.update",a,{storeName:e,key:t}),p.monitorTransaction(`update(${e})`,()=>u.execute(o,e,"readwrite",r=>{const o=r.objectStore(e);return new Promise((e,r)=>{const n=o.get(t);n.onsuccess=()=>{const t=n.result;if(!t)return void r(new Error("Record not found"));const i={...t,...a},s=o.put(i);s.onsuccess=()=>e(),s.onerror=()=>r(new TransactionError("Put failed",s.error))},n.onerror=()=>r(new TransactionError("Get failed",n.error))})})).then(e=>e.result)})}async delete(e,t){return this.options.enableSecurityValidation&&(b.validateStoreName(e),b.validateKey(t)),this.withCoordination(`write-${e}`,async()=>{const r=this.getDatabase();if(!r)throw new Error("Database not open");return p.monitorTransaction(`delete(${e})`,()=>u.execute(r,e,"readwrite",r=>{const o=r.objectStore(e);return u.promisifyRequest(o.delete(t))})).then(e=>e.result)})}async query(e,t={},r={}){return this.options.enableSecurityValidation&&(b.validateStoreName(e),b.validateQueryFilters(t)),this.withCoordination(`read-${e}`,async()=>{const o=this.getDatabase();if(!o)throw new Error("Database not open");return p.monitorTransaction(`query(${e})`,()=>m.query(o,e,t,r)).then(e=>e.result)})}async analyzeQuery(e,t={},r={}){const o=this.getDatabase();if(!o)throw new Error("Database not open");return m.analyzeQueryPlan(o,e,t,r)}async bulk(e,t){if(this.options.enableSecurityValidation){if(b.validateStoreName(e),!Array.isArray(t))throw new Error("Bulk operations must be an array");if(0===t.length)throw new Error("Bulk operations array cannot be empty");if(t.length>1e3)throw new Error("Bulk operations cannot exceed 1000 items");t.forEach((e,t)=>{if(!e||"object"!=typeof e)throw new Error(`Bulk operation ${t} must be an object`);if(!e.type||"string"!=typeof e.type)throw new Error(`Bulk operation ${t} must have a valid type`);if(!["create","update","delete"].includes(e.type))throw new Error(`Bulk operation ${t} has invalid type: ${e.type}`);if("delete"!==e.type&&!e.data)throw new Error(`Bulk operation ${t} (${e.type}) must have data`);if(("update"===e.type||"delete"===e.type)&&void 0===e.id)throw new Error(`Bulk operation ${t} (${e.type}) must have an id`);e.data&&b.validateDataObject(e.data,`bulk operation ${t} data`),void 0!==e.id&&b.validateKey(e.id)})}return this.withCoordination(`bulk-${e}`,async()=>{const r=this.getDatabase();if(!r)throw new Error("Database not open");const o=t.map(e=>({...e,data:e.data?b.createSafeCopy(e.data):void 0})),a=o.reduce((e,t)=>e+p.calculateObjectSize(t.data||{}),0);return p.logPerformanceWarning("IDBWrapper.bulk",{operations:o,totalSize:a},{storeName:e,operationCount:t.length}),p.monitorTransaction(`bulk(${e}, ${t.length} ops)`,()=>u.execute(r,e,"readwrite",t=>{const r=t.objectStore(e),a=o.map(e=>{switch(e.type){case"create":return u.promisifyRequest(r.add(e.data));case"update":return u.promisifyRequest(r.put(e.data,e.id));case"delete":return u.promisifyRequest(r.delete(e.id));default:throw new Error(`Unknown operation type: ${e.type}`)}});return Promise.all(a)})).then(e=>e.result)})}async withTransaction(e,t,r,o={}){const a=this.getDatabase();if(!a)throw new Error("Database not open");const n={timeout:o.timeout||5e3,strictAsync:!1!==o.strictAsync,...o};return u.execute(a,e,t,r,n)}async safeBulk(e,t,r={}){return this.withTransaction(e,"readwrite",async r=>{const o=r.objectStore(e),a=[];for(const e of t){let t;switch(e.type){case"create":t=await u.promisifyRequest(o.add(e.data));break;case"update":t=await u.promisifyRequest(o.put(e.data,e.id));break;case"delete":t=await u.promisifyRequest(o.delete(e.id));break;default:throw new Error(`Unknown operation type: ${e.type}`)}a.push(t)}return a},r)}},e.MigrationError=a,e.SchemaError=o,e.TransactionError=n,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
