!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).IDBWrapper={})}(this,function(e){"use strict";class t extends Error{constructor(e,t=null){super(e),this.name="IDBError",this.originalError=t}}class r extends t{constructor(e,t=null){super(e,t),this.name="ConnectionError"}}class n extends t{constructor(e,t=null){super(e,t),this.name="SchemaError"}}class s extends t{constructor(e,t=null){super(e,t),this.name="MigrationError"}}class o extends t{constructor(e,t=null){super(e,t),this.name="TransactionError"}}class a{static validateSchema(e){if(!e||"object"!=typeof e)throw new n("Schema must be an object");if(!e.stores||"object"!=typeof e.stores)throw new n("Schema must have a stores property");for(const[t,r]of Object.entries(e.stores)){if(!r||"object"!=typeof r)throw new n(`Store ${t} configuration must be an object`);if(!r.keyPath)throw new n(`Store ${t} must have a keyPath`);if(r.indexes){if("object"!=typeof r.indexes)throw new n(`Indexes for store ${t} must be an object`);for(const[e,s]of Object.entries(r.indexes)){if("object"!=typeof s)throw new n(`Index ${e} in store ${t} must be an object`);!s.keyPath&&s.unique}}}}static createSchema(e,t){this.validateSchema(t);for(const[r,n]of Object.entries(t.stores))if(!e.objectStoreNames.contains(r)){const t=e.createObjectStore(r,{keyPath:n.keyPath,autoIncrement:n.autoIncrement||!1});if(n.indexes)for(const[e,r]of Object.entries(n.indexes)){const n=r.keyPath||e;t.createIndex(e,n,{unique:r.unique||!1})}}}static checkSchemaConsistency(e,t){for(const r of Object.keys(t.stores))if(!e.objectStoreNames.contains(r))return!1;return!0}}class i{static async execute(e,t,r,n){return new Promise((s,a)=>{const i=e.transaction(t,r);let c;i.onerror=()=>{a(new o("Transaction failed",i.error))},i.onabort=()=>{a(new o("Transaction aborted"))};try{c=n(i),c&&"function"==typeof c.then?c.then(e=>{i.oncomplete=()=>s(e)}).catch(a):i.oncomplete=()=>s(c)}catch(e){a(new o("Operation failed",e))}})}static promisifyRequest(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=()=>r(new o("Request failed",e.error))})}}class c{static async runMigrations(e,t,r,n){if(t&&!(r>=n))for(let o=r;o<n;o++){const r=o;if(t[r])try{await i.execute(e,[],"readwrite",n=>t[r](e,n))}catch(e){throw new s(`Migration from version ${o} to ${o+1} failed`,e)}}}}class u{constructor(e,t,r,n=[]){this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.db=null,this.oldVersion=0}open(){return new Promise((e,t)=>{if(!window.indexedDB)return void t(new r("IndexedDB not supported"));const n=indexedDB.open(this.dbName,this.version);n.onerror=()=>{t(new r("Failed to open database",n.error))},n.onupgradeneeded=e=>{this.db=e.target.result,this.oldVersion=e.oldVersion,a.createSchema(this.db,this.schema)},n.onsuccess=async()=>{if(this.db=n.result,this.oldVersion<this.version)try{await c.runMigrations(this.db,this.migrations,this.oldVersion,this.version)}catch(e){return void t(e)}e(this.db)}})}close(){this.db&&(this.db.close(),this.db=null)}isOpen(){return null!==this.db}getDatabase(){return this.db}}class h{static async query(e,t,r={}){return i.execute(e,t,"readonly",async e=>{const n=e.objectStore(t),s=[];if(0===Object.keys(r).length)return new Promise((e,t)=>{const r=n.openCursor();r.onsuccess=t=>{const r=t.target.result;r?(s.push(r.value),r.continue()):e(s)},r.onerror=()=>t(r.error)});return(await new Promise((e,t)=>{const r=n.openCursor(),s=[];r.onsuccess=t=>{const r=t.target.result;r?(s.push(r.value),r.continue()):e(s)},r.onerror=()=>t(r.error)})).filter(e=>this.matchesFilters(e,r))})}static matchesFilters(e,t){for(const[r,n]of Object.entries(t))if("object"==typeof n&&null!==n){if(!this.evaluateOperator(e[r],n))return!1}else if(e[r]!==n)return!1;return!0}static evaluateOperator(e,t){const[r,n]=Object.entries(t)[0];switch(r){case"$gt":return e>n;case"$gte":return e>=n;case"$lt":return e<n;case"$lte":return e<=n;case"$eq":return e===n;case"$ne":return e!==n;case"$regex":return new RegExp(n).test(e);default:return!1}}}e.ConnectionError=r,e.IDBError=t,e.IDBWrapper=class{constructor(e,t,r,n=[]){a.validateSchema(r),this.dbName=e,this.version=t,this.schema=r,this.migrations=n,this.connectionManager=new u(e,t,r,n)}async open(){return this.connectionManager.open()}close(){this.connectionManager.close()}isOpen(){return this.connectionManager.isOpen()}getDatabase(){return this.connectionManager.getDatabase()}async create(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return i.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return i.promisifyRequest(n.add(t))})}async read(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return i.execute(r,e,"readonly",r=>{const n=r.objectStore(e);return i.promisifyRequest(n.get(t))})}async update(e,t,r){const n=this.getDatabase();if(!n)throw new Error("Database not open");return i.execute(n,e,"readwrite",n=>{const s=n.objectStore(e);return i.promisifyRequest(s.put(r,t))})}async delete(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return i.execute(r,e,"readwrite",r=>{const n=r.objectStore(e);return i.promisifyRequest(n.delete(t))})}async query(e,t={}){const r=this.getDatabase();if(!r)throw new Error("Database not open");return h.query(r,e,t)}async bulk(e,t){const r=this.getDatabase();if(!r)throw new Error("Database not open");return i.execute(r,e,"readwrite",r=>{const n=r.objectStore(e),s=t.map(e=>{switch(e.type){case"create":return i.promisifyRequest(n.add(e.data));case"update":return i.promisifyRequest(n.put(e.data,e.id));case"delete":return i.promisifyRequest(n.delete(e.id));default:throw new Error(`Unknown operation type: ${e.type}`)}});return Promise.all(s)})}},e.MigrationError=s,e.SchemaError=n,e.TransactionError=o,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=index.js.map
